    const URLBlacklist = []

    async function compressImage(file, options = {}) {
            const {
                quality = 0.8, maxWidth = 800, maxHeight = 800
            } = options;

            // --- æ–°å¢ï¼šå¤„ç†GIFåŠ¨å›¾ ---
            // å¦‚æœæ–‡ä»¶æ˜¯GIFï¼Œåˆ™ä¸ç»è¿‡canvaså‹ç¼©ï¼Œç›´æ¥è¿”å›åŸå§‹æ–‡ä»¶æ•°æ®ä»¥ä¿ç•™åŠ¨ç”»
            if (file.type === 'image/gif') {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            // --- å¯¹å…¶ä»–é™æ€å›¾ç‰‡ï¼ˆå¦‚PNG, JPGï¼‰è¿›è¡Œå‹ç¼© ---
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onerror = reject;
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onerror = reject;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        // å¯¹äºæœ‰é€æ˜èƒŒæ™¯çš„PNGå›¾ç‰‡ï¼Œå…ˆå¡«å……ä¸€ä¸ªç™½è‰²èƒŒæ™¯
                        // è¿™æ ·å¯ä»¥é˜²æ­¢é€æ˜åŒºåŸŸåœ¨è½¬æ¢æˆJPEGæ—¶å˜é»‘
                        if (file.type === 'image/png') {
                            ctx.fillStyle = '#FFFFFF'; // ç™½è‰²èƒŒæ™¯
                            ctx.fillRect(0, 0, width, height);
                        }

                        ctx.drawImage(img, 0, 0, width, height);

                        // --- å…³é”®ä¿®æ­£ï¼šå°†è¾“å‡ºæ ¼å¼æ”¹ä¸º 'image/jpeg' ---
                        // JPEGæ ¼å¼å¯ä»¥æ˜¾è‘—å‡å°æ–‡ä»¶å¤§å°ï¼Œé¿å…æµè§ˆå™¨å¤„ç†è¶…å¤§Base64å­—ç¬¦ä¸²æ—¶å´©æºƒ
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressedDataUrl);
                    };
                };
            });
        }
    // geminiå¦‚æœæ˜¯å¤šä¸ªå¯†é’¥, é‚£ä¹ˆéšæœºè·å–ä¸€ä¸ª
    function getRandomValue(str) {
        // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«é€—å·
        if (str.includes(',')) {
            // ç”¨é€—å·åˆ†éš”å­—ç¬¦ä¸²å¹¶ç§»é™¤å¤šä½™ç©ºæ ¼
            const arr = str.split(',').map(item => item.trim());
            // ç”Ÿæˆéšæœºç´¢å¼• (0 åˆ° arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // è¿”å›éšæœºå…ƒç´ 
            return arr[randomIndex];
        }
        // æ²¡æœ‰é€—å·åˆ™ç›´æ¥è¿”å›åŸå­—ç¬¦ä¸²
        return str;
    }
    const toastElement = document.getElementById('toast-notification');
const showToast = (message) => {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), 3000);
        };
        const pad = (num) => num.toString().padStart(2, '0');
// â–¼â–¼â–¼ è¯·å¤åˆ¶ä»¥ä¸‹å®Œæ•´ä»£ç ï¼Œæ›¿æ¢åŸæ–‡ä»¶ä¸­çš„ callAiApi å‡½æ•° â–¼â–¼â–¼

async function callAiApi(messages, customApiSettings = null) {
    // è·å–è®¾ç½®ï¼Œæ”¯æŒä¼ å…¥è‡ªå®šä¹‰è®¾ç½®ï¼ˆç”¨äºå•†åŸç­‰ç‹¬ç«‹APIåœºæ™¯ï¼‰
    const settings = customApiSettings || db.apiSettings;
    const { provider, url, key, model } = settings;

    if (!url || !key || !model) {
        throw new Error('APIè®¾ç½®ä¸å®Œæ•´ï¼Œè¯·æ£€æŸ¥è®¾ç½®ã€‚');
    }

    // æ£€æŸ¥é»‘åå•
    if (typeof URLBlacklist !== 'undefined') {
        const banApi = URLBlacklist.some((api) => url.indexOf(api) !== -1);
        if (banApi) {
            throw new Error('æ­¤APIç½‘å€å·²åŠ å…¥é»‘åå•ï¼Œè¯·å‹¿ä½¿ç”¨');
        }
    }

    let endpoint = url;
    let headers = { 'Content-Type': 'application/json' };
    let requestBody;

    // --- é’ˆå¯¹ Google Gemini çš„ç‰¹æ®Šå¤„ç† (ä¿®å¤ 400 æŠ¥é”™çš„æ ¸å¿ƒ) ---
    if (provider === 'gemini') {
        // 1. ç¡®ä¿ endpoint æ ¼å¼æ­£ç¡®
        // ç§»é™¤æœ«å°¾çš„ /v1 æˆ– /chat/completions ç­‰ OpenAI é£æ ¼çš„åç¼€
        let baseUrl = url.replace(/\/v1\/chat\/completions\/?$/, '').replace(/\/v1\/?$/, '');
        // æ„å»º Gemini ä¸“ç”¨ endpoint
        endpoint = `${baseUrl}/v1beta/models/${model}:generateContent?key=${getRandomValue(key)}`;
        
        // 2. æå– System Prompt (Gemini è¦æ±‚å•ç‹¬æ”¾)
        const systemMessage = messages.find(m => m.role === 'system');
        const systemInstruction = systemMessage ? { parts: [{ text: systemMessage.content }] } : undefined;

        // 3. è½¬æ¢æ¶ˆæ¯æ ¼å¼ (OpenAI -> Gemini)
        const contents = messages
            .filter(m => m.role !== 'system') // è¿‡æ»¤æ‰ systemï¼Œå› ä¸ºä¸Šé¢å·²ç»æå–äº†
            .map(msg => {
                // æ˜ å°„è§’è‰²ï¼šassistant -> model
                const role = msg.role === 'assistant' ? 'model' : 'user';
                
                let parts = [];
                
                // å¤„ç†å†…å®¹ (æ”¯æŒçº¯æ–‡æœ¬å’Œæ•°ç»„æ ¼å¼çš„å›¾ç‰‡)
                if (Array.isArray(msg.content)) {
                    // å¦‚æœ content æ˜¯æ•°ç»„ (é€šå¸¸åŒ…å«å›¾ç‰‡)
                    msg.content.forEach(item => {
                        if (item.type === 'text') {
                            parts.push({ text: item.text });
                        } else if (item.type === 'image' && item.source && item.source.data) {
                            // å…¼å®¹ Claude é£æ ¼çš„å›¾ç‰‡æ•°æ®
                            parts.push({ inline_data: { mime_type: item.source.media_type, data: item.source.data } });
                        } else if (item.type === 'image_url' && item.image_url && item.image_url.url) {
                            // å…¼å®¹ OpenAI é£æ ¼çš„å›¾ç‰‡ URL (å¦‚æœæ˜¯ base64)
                            const match = item.image_url.url.match(/^data:(image\/.+);base64,(.*)$/);
                            if (match) {
                                parts.push({ inline_data: { mime_type: match[1], data: match[2] } });
                            }
                        }
                    });
                } else {
                    // æ™®é€šçº¯æ–‡æœ¬
                    parts.push({ text: msg.content || '' });
                }
                
                return { role, parts };
            });

        requestBody = {
            contents: contents,
            generationConfig: {
                // å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´æ¸©åº¦ç­‰å‚æ•°
            }
        };
        
        if (systemInstruction) {
            requestBody.system_instruction = systemInstruction;
        }

    } 
    // --- å…¶ä»–æœåŠ¡å•† (OpenAI, DeepSeek, Claude, NewAPI ç­‰) ---
    else {
        // ç¡®ä¿ endpoint æŒ‡å‘ chat/completions
        if (!endpoint.endsWith('/chat/completions')) {
            endpoint = endpoint.replace(/\/+$/, '') + '/v1/chat/completions';
            // ä¿®æ­£å¯èƒ½çš„é‡å¤ v1 (ä¾‹å¦‚ç”¨æˆ·å¡«äº† .../v1ï¼Œç»“æœå˜æˆäº† .../v1/v1/chat...)
            endpoint = endpoint.replace(/\/v1\/v1\//, '/v1/'); 
        }

        headers['Authorization'] = `Bearer ${getRandomValue(key)}`;
        
        requestBody = {
            model,
            messages,
            stream: false // è¿™é‡Œçš„è°ƒç”¨é€šå¸¸ä¸éœ€è¦æµå¼
        };
    }

    // å‘é€è¯·æ±‚
    const response = await fetch(endpoint, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
        const errorText = await response.text();
        console.error("API Error Response:", errorText);
        if (errorText.trim().startsWith('<')) {
            throw new Error(`APIè¿”å›äº†ä¸€ä¸ªé”™è¯¯é¡µé¢(HTML)ï¼Œè€Œä¸æ˜¯JSONæ•°æ®ã€‚å¯èƒ½åœ°å€å¡«å†™é”™è¯¯ã€‚`);
        }
        throw new Error(`AIæœåŠ¡è¯·æ±‚å¤±è´¥: ${response.status} ${errorText}`);
    }

    const data = await response.json();

    // è§£æå“åº”å†…å®¹
    if (provider === 'gemini') {
        if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts) {
            return data.candidates[0].content.parts[0].text;
        }
    } else {
        if (data.choices && data.choices.length > 0 && data.choices[0].message) {
            return data.choices[0].message.content;
        }
    }
    
    console.error("æ— æ³•è§£æçš„APIå“åº”:", data);
    throw new Error('æœªèƒ½ä»APIå“åº”ä¸­è§£æå‡ºæœ‰æ•ˆçš„æ–‡æœ¬å†…å®¹ã€‚');
}
// â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

    document.addEventListener('DOMContentLoaded', () => {
    

        // --- Initial HTML Injection ---
        // (è¯·æ‰¾åˆ°æ–‡ä»¶ä¸­çš„æ—§ 'api-settings-screen'.innerHTML ä»£ç ï¼Œå¹¶ç”¨ä¸‹é¢çš„ä»£ç å®Œæ•´æ›¿æ¢å®ƒ)



// START: ä¿®æ­£åŠ¨æ€ç”Ÿæˆå±å¹•çš„è¿”å›æŒ‰é’® (å®Œæ•´æ›¿æ¢)
// â–¼â–¼â–¼ ç¬¬ä¸€æ­¥ï¼šè¯·å¤åˆ¶è¿™æ®µä»£ç ï¼Œå®Œæ•´æ›¿æ¢åŸæ¥çš„ api-settings-screen.innerHTML èµ‹å€¼éƒ¨åˆ† â–¼â–¼â–¼
document.getElementById('api-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">â€¹</button><div class="title-container"><h1 class="title">API è®¾ç½®</h1></div><div class="placeholder"></div></header><main class="content"><form id="api-form"><div class="form-group"><label for="api-provider">API æœåŠ¡å•†</label><select id="api-provider" name="provider"><option value="newapi">NewAPI (è‡ªå®šä¹‰)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option></select>
<div class="api-presets-embedded" style="margin-top:12px;">
<div id="api-presets-control" style="margin:12px 0;padding:12px;border-radius:8px;border:1px solid var(--border-color, #eee);background:var(--panel-bg, #fff);box-shadow:var(--panel-shadow, none);">
  <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px;">
    <label style="min-width:86px;color:var(--muted,#666);">API é¢„è®¾ï¼š</label>
    <select id="api-preset-select" style="flex:1;padding:8px;border-radius:6px;border:1px solid #ddd;">
      <option value="">â€” é€‰æ‹© API é¢„è®¾ â€”</option>
    </select>
    <button id="api-apply-preset" class="btn btn-primary" style="margin-left:8px;padding:6px 10px;">åº”ç”¨</button>
  </div>
  <div style="display:flex;gap:8px;align-items:center;">
    <button id="api-save-preset" class="btn" style="padding:6px 10px;">å¦å­˜ä¸ºé¢„è®¾</button>
    <button id="api-manage-presets" class="btn" style="padding:6px 10px;">ç®¡ç†</button>
    <div style="flex:1"></div>
    <button id="api-import-presets" class="btn" style="padding:6px 10px;">å¯¼å…¥</button>
    <button id="api-export-presets" class="btn" style="padding:6px 10px;">å¯¼å‡º</button>
  </div>
</div>

<div id="api-presets-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.35);z-index:9999;align-items:center;justify-content:center;">
  <div style="width:640px;max-width:94%;background:var(--panel-bg,#fff);padding:16px;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.12);">
    <h3 style="margin:0 0 12px 0;">API é¢„è®¾ç®¡ç†</h3>
    <div id="api-presets-list" style="max-height:360px;overflow:auto;border:1px solid #f0f0f0;padding:8px;border-radius:6px;"></div>
    <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end;">
      <button id="api-close-modal" class="btn btn-primary">å…³é—­</button>
    </div>
  </div>
</div>
</div>
</div><div class="form-group"><label for="api-url">API åœ°å€ï¼ˆåç¼€ä¸ç”¨æ·»åŠ /v1ï¼‰</label><input type="url" id="api-url" name="url" placeholder="é€‰æ‹©æœåŠ¡å•†å¯è‡ªåŠ¨å¡«å†™" required></div><div class="form-group"><label for="api-key">å¯†é’¥ (Key)</label><input type="password" id="api-key" name="key" placeholder="è¯·è¾“å…¥ä½ çš„APIå¯†é’¥" required></div><button type="button" class="btn btn-secondary" id="fetch-models-btn"><span class="btn-text">ç‚¹å‡»æ‹‰å–æ¨¡å‹</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">é€‰æ‹©æ¨¡å‹</label><select id="api-model" name="model" required><option value="">è¯·å…ˆæ‹‰å–æ¨¡å‹åˆ—è¡¨</option></select></div>

<!-- === Minimax TTS è¯­éŸ³è®¾ç½® === -->
<div class="form-group" style="margin-top: 30px; border-top: 2px solid #fce4ec; padding-top: 20px;">
    <h3 style="color: var(--secondary-color); margin-bottom: 15px;">ğŸ¤ Minimax TTS è¯­éŸ³è®¾ç½®</h3>
    
    <label for="minimax-group-id">Group ID</label>
    <input type="text" id="minimax-group-id" placeholder="è¾“å…¥ Minimax Group ID">
    
    <label for="minimax-api-key" style="margin-top: 15px;">API Key</label>
    <input type="password" id="minimax-api-key" placeholder="è¾“å…¥ Minimax API Key">
    
    <label for="minimax-model-select" style="margin-top: 15px;">è¯­éŸ³æ¨¡å‹</label>
    <select id="minimax-model-select" class="form-control">
        <option value="speech-01">speech-01 (é»˜è®¤)</option>
        <option value="speech-02">speech-02</option>
        <option value="speech-01-turbo">speech-01-turbo (å¿«é€Ÿ)</option>
    </select>
    
    <label for="minimax-domain-select" style="margin-top: 15px;">æ¥å£åŸŸå</label>
    <select id="minimax-domain-select" class="form-control">
        <option value="https://api.minimax.chat">ğŸ‡¨ğŸ‡³ å›½å†… (api.minimax.chat)</option>
        <option value="https://api.minimaxi.chat">ğŸŒ æµ·å¤– (api.minimaxi.chat)</option>
    </select>
    
    <p style="font-size: 12px; color: #888; margin-top: 10px;">
        ğŸ’¡ æç¤ºï¼šMinimax TTSç”¨äºè¯­éŸ³åˆæˆåŠŸèƒ½ï¼Œå¯åœ¨èŠå¤©ä¸­æ’­æ”¾AIçš„è¯­éŸ³æ¶ˆæ¯ã€‚
        <a href="https://www.minimaxi.com/" target="_blank" style="color: var(--primary-color);">å‰å¾€æ³¨å†Œ</a>
    </p>
</div>

<!-- æ–°å¢ï¼šæ—¶é—´æ„ŸçŸ¥å¼€å…³ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border: 1px solid #fce4ec; border-radius: 10px; background-color: #fff8fa;">
    <label for="time-perception-switch" style="margin-bottom: 0; color: var(--secondary-color); font-weight: 600;">æ—¶é—´æ„ŸçŸ¥åŠ å¼º</label>
    <input type="checkbox" id="time-perception-switch" style="width: auto; height: 20px; width: 20px;">
</div>

<div class="form-group" style="border-top: 1px solid #eee; padding-top: 20px; margin-top: 20px;">
    <label for="ai-block-duration">AIè‡ªåŠ¨è§£å°æ—¶é—´ (åˆ†é’Ÿ)</label>
    <input type="number" id="ai-block-duration" min="0" placeholder="0 æˆ–ç•™ç©ºè¡¨ç¤ºæ°¸ä¸è‡ªåŠ¨è§£å°">
</div>
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; border-top: 1px solid #eee; padding-top: 20px;">
    <label for="force-html-theater" style="margin-bottom: 0;">ç”ŸæˆHTMLå°å‰§åœº</label>
    <input type="checkbox" id="force-html-theater" style="width: auto; height: 20px;">
</div>
<div class="form-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px;">
    <label for="ai-auto-post-moment" style="margin-bottom: 0;">AIè‡ªåŠ¨å‘å¸ƒåŠ¨æ€</label>
    <input type="checkbox" id="ai-auto-post-moment" style="width: auto; height: 20px;">
</div>
<button type="submit" class="btn btn-primary" id="save-btn"><span class="btn-text">ä¿ å­˜</span><div class="spinner"></div></button>
</form></main>`;
// â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²

document.getElementById('wallpaper-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">â€¹</button><div class="title-container"><h1 class="title">æ›´æ¢å£çº¸</h1></div><div class="placeholder"></div></header><main class="content"><div class="wallpaper-preview" id="wallpaper-preview"><span>å½“å‰å£çº¸é¢„è§ˆ</span></div><input type="file" id="wallpaper-upload" accept="image/*" style="display: none;"><label for="wallpaper-upload" class="btn btn-primary">ä»ç›¸å†Œé€‰æ‹©æ–°å£çº¸</label></main>`;
// --- æ–°ä»£ç å¼€å§‹ ---
document.getElementById('font-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">â€¹</button><div class="title-container"><h1 class="title">å­—ä½“è®¾ç½®</h1></div><div class="placeholder"></div></header><main class="content">
    
    <div id="font-presets-control" style="margin:15px 0; padding:15px; border-radius:12px; border:1px solid #fce4ec; background:#fff8fa;">
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:12px;">
        <label style="color:var(--secondary-color); font-weight:600;">å­—ä½“é¢„è®¾</label>
        <select id="font-preset-select" style="flex:1; padding:8px; border-radius:8px; border:1px solid #fce4ec;"></select>
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="font-apply-preset" class="btn btn-primary btn-small">åº”ç”¨</button>
        <button id="font-save-preset" class="btn btn-secondary btn-small">å¦å­˜</button>
        <button id="font-manage-presets" class="btn btn-neutral btn-small">ç®¡ç†</button>
      </div>
    </div>
    <form id="font-settings-form">
        <div class="form-group">
            <label for="font-url">å­—ä½“é“¾æ¥ (ttf, woff, woff2)</label>
            <input type="url" id="font-url" placeholder="https://.../font.ttf" required>
        </div>
        <p style="font-size:12px; color:#888; text-align:center;">ç¤ºä¾‹: https://lf3-static.bytednsdoc.com/obj/eden-cn/jplptk/ljhwZthlaukjlkulzlp/portal/fonts/HarmonyOS_Sans_SC_Regular.woff2</p>
        <button type="submit" class="btn btn-primary">åº”ç”¨å­—ä½“</button>
        <button type="button" class="btn btn-neutral" id="restore-default-font-btn" style="margin-top: 15px;">æ¢å¤é»˜è®¤å­—ä½“</button>
    </form>
</main>`;
// --- æ–°ä»£ç ç»“æŸ ---
document.getElementById('customize-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">â€¹</button><div class="title-container"><h1 class="title">ä¸»å±å¹•è‡ªå®šä¹‰</h1></div><div class="placeholder"></div></header><main class="content"><form id="customize-form"></form></main>`;
document.getElementById('tutorial-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">â€¹</button><div class="title-container"><h1 class="title">æ•™ç¨‹</h1></div><div class="placeholder"></div></header><main class="content" id="tutorial-content-area"></main>`;
// END: ä¿®æ­£åŠ¨æ€ç”Ÿæˆå±å¹•çš„è¿”å›æŒ‰é’®
        
// ============ Minimax TTS åŠŸèƒ½ä»£ç  å¼€å§‹ ============

/**
 * æ’­æ”¾ TTS è¯­éŸ³
 * @param {HTMLElement} bodyElement - è¯­éŸ³æ¶ˆæ¯æ°”æ³¡çš„bodyå…ƒç´ 
 */
async function playTtsAudio(bodyElement) {
    const text = decodeURIComponent(bodyElement.dataset.text);
    const voiceId = bodyElement.dataset.voiceId;
    const button = bodyElement.querySelector('.voice-play-btn'); 
    const spinner = bodyElement.querySelector('.loading-spinner');

    const ttsPlayer = document.getElementById('tts-audio-player');
    if (!ttsPlayer) {
        console.error('TTSæ’­æ”¾å™¨å…ƒç´ ä¸å­˜åœ¨');
        return;
    }
    
    // å¦‚æœæ­£åœ¨æ’­æ”¾åŒä¸€æ¡è¯­éŸ³ï¼Œåˆ™æš‚åœ
    if (!ttsPlayer.paused && ttsPlayer.dataset.currentText === text && ttsPlayer.dataset.currentVoiceId === voiceId) {
        ttsPlayer.pause();
        return;
    }

    // æš‚åœå½“å‰æ’­æ”¾å¹¶é‡ç½®æ‰€æœ‰æŒ‰é’®
    ttsPlayer.pause();
    document.querySelectorAll('.voice-play-btn').forEach(btn => btn.textContent = 'â–¶');

    // æ£€æŸ¥ç¼“å­˜ï¼ˆä½¿ç”¨å…¨å±€å˜é‡ ttsCacheï¼‰
    const cacheKey = `tts_${voiceId}_${text}`;
    let cachedAudio = ttsCache.get(cacheKey); // âœ… æ”¹ä¸ºä½¿ç”¨å…¨å±€å˜é‡

    if (cachedAudio) {
        console.log("ä»ç¼“å­˜æ’­æ”¾ TTS éŸ³é¢‘...");
        await playAudioFromData(cachedAudio.url, cachedAudio.type, text, voiceId, bodyElement); 
        return;
    }

    // æ— ç¼“å­˜ï¼Œè¯·æ±‚API
    console.log("æ— ç¼“å­˜ï¼Œæ­£åœ¨è¯·æ±‚ Minimax TTS API...");
    if(button) button.style.display = 'none';
    if(spinner) spinner.style.display = 'block';

    // è·å–é…ç½®ï¼ˆä½¿ç”¨å…¨å±€å˜é‡ ttsConfigï¼‰
    const minimaxGroupId = ttsConfig.minimaxGroupId || localStorage.getItem('minimax-group-id') || '';
    const minimaxApiKey = ttsConfig.minimaxApiKey || localStorage.getItem('minimax-api-key') || '';
    const minimaxModel = ttsConfig.minimaxModel || localStorage.getItem('minimax-model') || 'speech-01';
    const minimaxDomain = ttsConfig.minimaxDomain || 'https://api.minimax.chat';
    
    if (!minimaxGroupId || !minimaxApiKey) {
        alert("é…ç½®é”™è¯¯ï¼šè¯·å…ˆåœ¨APIè®¾ç½®ä¸­å¡«å†™æ‚¨çš„ Minimax Group ID å’Œ API Keyã€‚");
        if(spinner) spinner.style.display = 'none';
        if(button) button.style.display = 'flex';
        return;
    }

    try {
        const response = await fetch(`${minimaxDomain}/v1/text_to_speech?GroupId=${minimaxGroupId}`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${minimaxApiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                text: text,
                voice_id: voiceId,
                model: minimaxModel,
                speed: 1.0, 
                vol: 1.0, 
                pitch: 0,
            })
        });

        if (!response.ok) {
            let errorMsg = `API è¿”å›é”™è¯¯: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg = errorData.base_resp?.status_msg || JSON.stringify(errorData);
            } catch(e) {
                errorMsg = await response.text();
            }
            throw new Error(errorMsg);
        }

        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        await playAudioFromData(audioUrl, audioBlob.type, text, voiceId, bodyElement); 

        // ä¿å­˜åˆ°ç¼“å­˜ï¼ˆä½¿ç”¨å…¨å±€å˜é‡ ttsCacheï¼‰
        const reader = new FileReader();
        reader.onloadend = function() {
            ttsCache.set(cacheKey, { url: reader.result, type: audioBlob.type }); // âœ… æ”¹ä¸ºä½¿ç”¨å…¨å±€å˜é‡
            console.log("TTS éŸ³é¢‘å·²ä¿å­˜åˆ°ç¼“å­˜ã€‚");
        }
        reader.readAsDataURL(audioBlob);

    } catch (error) {
        console.error("Minimax TTS API è°ƒç”¨å¤±è´¥:", error);
        alert(`è¯­éŸ³ç”Ÿæˆå¤±è´¥ï¼š${error.message}`);
    } finally {
        if(spinner) spinner.style.display = 'none';
        if(button) button.style.display = 'flex';
    }
}

/**
 * æ’­æ”¾éŸ³é¢‘æ•°æ®
 */
function playAudioFromData(audioSrc, audioType, text, voiceId, bodyElement) { 
    return new Promise((resolve, reject) => {
        const ttsPlayer = document.getElementById('tts-audio-player');

        ttsPlayer.src = audioSrc;
        ttsPlayer.type = audioType;
        ttsPlayer.dataset.currentText = text;
        ttsPlayer.dataset.currentVoiceId = voiceId;

        const playPromise = ttsPlayer.play();

        if (playPromise !== undefined) {
            playPromise.then(() => {
                const button = bodyElement.querySelector('.voice-play-btn');
                if (button) button.textContent = 'âšâš'; 
                resolve();
            }).catch(error => {
                console.error("éŸ³é¢‘æ’­æ”¾å¤±è´¥:", error);
                reject(error);
            });
        }

        ttsPlayer.onended = () => {
            const button = bodyElement.querySelector('.voice-play-btn');
            if (button) button.textContent = 'â–¶'; 
        };
        ttsPlayer.onpause = () => {
            const button = bodyElement.querySelector('.voice-play-btn');
            if (button) button.textContent = 'â–¶';
        };
    });
}

/**
 * åˆ‡æ¢æ˜¾ç¤ºè¯­éŸ³æ–‡å­—
 */
function toggleVoiceTranscript(bodyElement) {
    const bubble = bodyElement.closest('.message-bubble');
    if (!bubble) return;

    const transcriptEl = bubble.querySelector('.voice-transcript');
    const text = decodeURIComponent(bodyElement.dataset.text);

    if (transcriptEl && transcriptEl.style.display === 'block') {
        transcriptEl.style.display = 'none';
    } else if (transcriptEl) {
        transcriptEl.textContent = text;
        transcriptEl.style.display = 'block';
    }
}

// ============ Minimax TTS åŠŸèƒ½ä»£ç  ç»“æŸ ============

        // --- Global Variables and Constants ---
        const colorThemes = {
            'white_pink': {
                name: 'ç™½/ç²‰',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(255,204,204,0.9)', text: '#A56767'}
            },
            'white_blue': {
                name: 'ç™½/è“',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
            'white_yellow': {
                name: 'ç™½/é»„',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(249,237,105,0.9)', text: '#8B7E4B'}
            },
            'white_green': {
                name: 'ç™½/ç»¿',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(188,238,188,0.9)', text: '#4F784F'}
            },
            'white_purple': {
                name: 'ç™½/ç´«',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'black_red': {
                name: 'é»‘/çº¢',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgb(226,62,87,0.9)', text: '#fff'}
            },
            'black_green': {
                name: 'é»‘/ç»¿',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(119,221,119,0.9)', text: '#2E5C2E'}
            },
            'black_white': {
                name: 'é»‘/ç™½',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(245,245,245,0.9)', text: '#333'}
            },
            'white_black': {
                name: 'ç™½/é»‘',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(50,50,50,0.85)', text: '#F5F5F5'}
            },
            'yellow_purple': {
                name: 'é»„/ç´«',
                received: {bg: 'rgba(255,250,205,0.9)', text: '#8B7E4B'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'pink_blue': {
                name: 'ç²‰/è“',
                received: {bg: 'rgba(255,231,240,0.9)', text: '#7C6770'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
        };
const defaultIcons = {
            'chat-list-screen': {name: '404', url: 'https://i.postimg.cc/VvQB8dQT/chan-143.png'},
            'api-settings-screen': {name: 'api', url: 'https://i.postimg.cc/50FqT8GL/chan-125.png'},
            'wallpaper-screen': {name: 'å£çº¸', url: 'https://i.postimg.cc/3wqFttL3/chan-90.png'},
            'world-book-screen': {name: 'ä¸–ç•Œä¹¦', url: 'https://i.postimg.cc/prCWkrKT/chan-74.png'},
            'customize-screen': {name: 'è‡ªå®šä¹‰', url: 'https://i.postimg.cc/vZVdC7gt/chan-133.png'},
            'font-settings-screen': {name: 'å­—ä½“', url: 'https://i.postimg.cc/FzVtC0x4/chan-21.png'},
            'tutorial-screen': {name: 'æ•™ç¨‹', url: 'https://i.postimg.cc/6QgNzCFf/chan-118.png'},
            'ai-character-select-screen': {name: 'AIæ‰‹æœº', url: 'https://i.postimg.cc/9Q8B2X3D/chan-101.png'},
            'renderer-screen': {name: 'æ¸²æŸ“å™¨', url: 'https://i.postimg.cc/zX7d2b2S/image.png'},
            'mall-screen': {name: 'å•†åŸ', url: 'https://i.postimg.cc/PqYkx23B/shop-icon.png'},
            'soul-bond-app-icon': {name: 'å¿ƒçµç¾ç»Š', url: 'https://i.postimg.cc/P5pQd2Xp/image.png'},
            'day-mode-btn': {name: '', url: 'https://i.postimg.cc/Jz0tYqnT/chan-145.png'},
            'night-mode-btn': {name: '', url: 'https://i.postimg.cc/htYvkdQK/chan-146.png'},
            'record-label': { name: 'å”±ç‰‡æ ‡ç­¾ (åœ†å½¢)', url: 'https://i.postimg.cc/nzP9sgxr/chan-125.png' },
            'record-sleeve': { name: 'å”±ç‰‡å°å¥— (æ–¹å½¢)', url: 'https://i.postimg.cc/KzC3q4w3/image.png' },
            'decorative-component': { name: 'è£…é¥°ç»„ä»¶ (æ–¹å½¢)', url: '' },
   // --- æ–°å¢ï¼šAIæ‰‹æœºå†…éƒ¨Appå›¾æ ‡ (PeekåŠŸèƒ½ - å…¨éƒ¨ç»Ÿä¸€åˆ° peek- å‰ç¼€) ---
            'ai-space-peek-messages': { name: 'æ¶ˆæ¯', icon: 'https://i.postimg.cc/Kvs4tDh5/export202509181826424260.png' },
            'ai-space-peek-memos': { name: 'å¤‡å¿˜å½•', icon: 'https://i.postimg.cc/JzD0xH1C/export202509181829064550.png' },
            'ai-space-peek-cart': { name: 'è´­ç‰©è½¦', icon: 'https://i.postimg.cc/pLwT6VTh/export202509181830143960.png' },
            'ai-space-peek-transfer': { name: 'ä¸­è½¬ç«™', icon: 'https://i.postimg.cc/63wQBHCB/export202509181831140230.png' },
            'ai-space-peek-browser': { name: 'æµè§ˆå™¨', icon: 'https://i.postimg.cc/SKcsF02Z/export202509181830445980.png' },
            'ai-space-peek-album': { name: 'ç›¸å†Œ', icon: 'https://i.postimg.cc/qBcdpqNc/export202509221549335970.png' },
            'ai-space-peek-unlock': { name: 'unlockï¼', icon: 'https://i.postimg.cc/28zNyYWs/export202509221542593320.png' },
            'ai-space-peek-signal': { name: 'å¿ƒåŠ¨è®¯å·', icon: 'https://i.postimg.cc/tJ0g1C0m/heart.png' },
            'ai-space-peek-music': { name: 'éŸ³ä¹', icon: 'https://i.postimg.cc/d10J4VzR/image.png' },
        };

        let db = {
            characters: [],
            groups: [],
            apiSettings: {},
            wallpaper: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg',
            wallpaper2: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg', // æ–°å¢ï¼šç¬¬äºŒé¡µå£çº¸
            myStickers: [],
            homeScreenMode: 'night',
            worldBooks: [],
            fontUrl: '',
            customIcons: {},
            customWidgets: [], // <-- æ·»åŠ è¿™ä¸€è¡Œ
            playlist: [], // <-- æ–°å¢
            musicPlayerSettings: { // <-- æ–°å¢
                volume: 0.8,
                playbackMode: 'sequential', 
                },
                renderers: [],
        rendererCategories: []
        };
// ============ TTS è¯­éŸ³åˆæˆç›¸å…³å˜é‡ ============
let ttsCache = new Map(); // TTSéŸ³é¢‘ç¼“å­˜
let ttsConfig = {
    minimaxGroupId: '',
    minimaxApiKey: '',
    minimaxModel: 'speech-01',
    minimaxDomain: 'https://api.minimax.chat'
};
// ============================================

        let currentQuotedMessageId = null, currentChatId = null, currentChatType = null, isGenerating = false, longPressTimer = null;
        let isSending = false; // ğŸ†• é˜²æ­¢é‡å¤å‘é€ç”¨æˆ·æ¶ˆæ¯çš„é”
        inputElement = null;
        let isInScreenshotMode = false;
let selectedMessagesForScreenshot = new Set();
let notificationQueue = [];
let isNotificationShowing = false;
            isInMultiSelectMode = false, editingMessageId = null, currentPage = 1, currentTransferMessageId = null,
            currentEditingWorldBookId = null, currentStickerActionTarget = null,
            currentGroupAction = {type: null, recipients: []};
            let isFavoriteProcessing = false; // ç”¨äºé˜²æ­¢æ”¶è—æŒ‰é’®è¢«åŒå‡»
            let currentStickerCategory = 'all'; // ğŸ†• å½“å‰é€‰ä¸­çš„è¡¨æƒ…åŒ…åˆ†ç»„ï¼ˆ'all' = å…¨éƒ¨ï¼‰
            let isStickerSelectionMode = false; // ğŸ†• æ˜¯å¦å¤„äºå¤šé€‰æ¨¡å¼
            let selectedStickerIds = new Set(); // ğŸ†• é€‰ä¸­çš„è¡¨æƒ…åŒ… ID é›†åˆ
// â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
            let audioPlayer = null;
        let currentSongIndex = -1;
        let isPlaying = false;
        let sharedWithChatIds = new Set();
        let shuffleOrder = [];
        let parsedLyrics = [];
        let currentLyricIndex = -1;
        let isAiCalling = false; // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦æ˜¯AIå‘èµ·çš„å‘¼å«
            let isVoiceCallActive = false, voiceCallTranscript = [], voiceCallStartTime = null, callTimerInterval = null, currentCallTargetId = null;
let isCallRinging = false; // <-- æ–°å¢å˜é‡ï¼Œæ ‡è®°æ˜¯å¦å¤„äºæ­£åœ¨å“é“ƒçŠ¶æ€
let callInitiationTimeout = null; // <-- æ–°å¢å˜é‡ï¼Œç”¨äºå­˜æ”¾å‘¼å«è¶…æ—¶è®¡æ—¶å™¨
        let selectedMessageIds = new Set();
        const MESSAGES_PER_PAGE = 50;

        // --- DOM Element Cache ---
        const screens = document.querySelectorAll('.screen'),
            toastElement = document.getElementById('toast-notification'),
            homeScreen = document.getElementById('home-screen'),
            chatListContainer = document.getElementById('chat-list-container'),
            noChatsPlaceholder = document.getElementById('no-chats-placeholder'),
            addChatBtn = document.getElementById('add-chat-btn'),
            addCharModal = document.getElementById('add-char-modal'),
            addCharForm = document.getElementById('add-char-form'),
            chatRoomScreen = document.getElementById('chat-room-screen'),
            chatRoomHeaderDefault = document.getElementById('chat-room-header-default'),
            chatRoomHeaderSelect = document.getElementById('chat-room-header-select'),
            cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn'),
            multiSelectTitle = document.getElementById('multi-select-title'),
            chatRoomTitle = document.getElementById('chat-room-title'),
            chatRoomStatusText = document.getElementById('chat-room-status-text'),
            messageArea = document.getElementById('message-area'),
            messageInputDefault = document.getElementById('message-input-default'),
            messageInput = document.getElementById('message-input'),
            sendMessageBtn = document.getElementById('send-message-btn'),
            getReplyBtn = document.getElementById('get-reply-btn'),
            typingIndicator = document.getElementById('typing-indicator'),
            chatSettingsBtn = document.getElementById('chat-settings-btn'),
            settingsSidebar = document.getElementById('chat-settings-sidebar'),
            settingsForm = document.getElementById('chat-settings-form'),
            messageEditBar = document.getElementById('message-edit-bar'),
            messageEditInput = document.getElementById('message-edit-input'),
            saveEditBtn = document.getElementById('save-edit-btn'),
            cancelEditBtn = document.getElementById('cancel-edit-btn'),
            multiSelectBar = document.getElementById('multi-select-bar'),
            selectCount = document.getElementById('select-count'),
            deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const stickerToggleBtn = document.getElementById('sticker-toggle-btn'),
            stickerModal = document.getElementById('sticker-modal'),
            stickerGridContainer = document.getElementById('sticker-grid-container'),
            addNewStickerBtn = document.getElementById('add-new-sticker-btn'),
            addStickerModal = document.getElementById('add-sticker-modal'),
            addStickerModalTitle = document.getElementById('add-sticker-modal-title'),
            addStickerForm = document.getElementById('add-sticker-form'),
            stickerEditIdInput = document.getElementById('sticker-edit-id'),
            stickerPreview = document.getElementById('sticker-preview'),
            stickerNameInput = document.getElementById('sticker-name'),
            stickerUrlInput = document.getElementById('sticker-url-input'),
            stickerFileUpload = document.getElementById('sticker-file-upload');
            const searchResultsScreen = document.getElementById('search-results-screen'),
            searchResultsList = document.getElementById('search-results-list'),
            noResultsPlaceholder = document.getElementById('no-search-results-placeholder'),
            // â–¼â–¼â–¼ æ–°å¢ä»¥ä¸‹å˜é‡ â–¼â–¼â–¼
            searchModal = document.getElementById('search-modal'),
            searchModalForm = document.getElementById('search-modal-form'),
            searchModalInput = document.getElementById('search-modal-input');
            const voiceCallBtn = document.getElementById('voice-call-btn');
const voiceCallOverlay = document.getElementById('voice-call-overlay');
const callAvatar = document.getElementById('call-avatar');
const callName = document.getElementById('call-name');
const callStatus = document.getElementById('call-status');
const ringingView = document.getElementById('ringing-view');
const incomingButtons = document.getElementById('incoming-buttons');
const outgoingButtons = document.getElementById('outgoing-buttons');
const activeCallView = document.getElementById('active-call-view');
const callTranscriptArea = document.getElementById('call-transcript-area');
const hangupCallBtn = document.getElementById('hangup-call-btn');
const callInput = document.getElementById('call-input');
const sendCallMessageBtn = document.getElementById('send-call-message-btn');
const declineCallBtn = document.getElementById('decline-call-btn');
const acceptCallBtn = document.getElementById('accept-call-btn');
const cancelCallBtn = document.getElementById('cancel-call-btn');
        const stickerActionSheet = document.getElementById('sticker-actionsheet'),
            editStickerBtn = document.getElementById('edit-sticker-btn'),
            deleteStickerBtn = document.getElementById('delete-sticker-btn');
        const voiceMessageBtn = document.getElementById('voice-message-btn'),
            sendVoiceModal = document.getElementById('send-voice-modal'),
            sendVoiceForm = document.getElementById('send-voice-form'),
            voiceTextInput = document.getElementById('voice-text-input'),
            voiceDurationPreview = document.getElementById('voice-duration-preview');
        const photoVideoBtn = document.getElementById('photo-video-btn'),
            sendPvModal = document.getElementById('send-pv-modal'),
            sendPvForm = document.getElementById('send-pv-form'),
            pvTextInput = document.getElementById('pv-text-input');
        const imageRecognitionBtn = document.getElementById('image-recognition-btn'),
            imageUploadInput = document.getElementById('image-upload-input');
        const walletBtn = document.getElementById('wallet-btn'),
            sendTransferModal = document.getElementById('send-transfer-modal'),
            sendTransferForm = document.getElementById('send-transfer-form'),
            transferAmountInput = document.getElementById('transfer-amount-input'),
            transferRemarkInput = document.getElementById('transfer-remark-input');
        const receiveTransferActionSheet = document.getElementById('receive-transfer-actionsheet'),
            acceptTransferBtn = document.getElementById('accept-transfer-btn'),
            returnTransferBtn = document.getElementById('return-transfer-btn');
        const giftBtn = document.getElementById('gift-btn'), sendGiftModal = document.getElementById('send-gift-modal'),
            sendGiftForm = document.getElementById('send-gift-form'),
            giftDescriptionInput = document.getElementById('gift-description-input');
        const timeSkipBtn = document.getElementById('time-skip-btn'),
            timeSkipModal = document.getElementById('time-skip-modal'),
            timeSkipForm = document.getElementById('time-skip-form'),
            timeSkipInput = document.getElementById('time-skip-input');
        const clearChatHistoryBtn = document.getElementById('clear-chat-history-btn');
        const worldBookListContainer = document.getElementById('world-book-list-container'),
            noWorldBooksPlaceholder = document.getElementById('no-world-books-placeholder'),
            addWorldBookBtn = document.getElementById('add-world-book-btn'),
            editWorldBookScreen = document.getElementById('edit-world-book-screen'),
            editWorldBookForm = document.getElementById('edit-world-book-form'),
            worldBookIdInput = document.getElementById('world-book-id'),
            worldBookNameInput = document.getElementById('world-book-name'),
            worldBookContentInput = document.getElementById('world-book-content');
        const linkWorldBookBtn = document.getElementById('link-world-book-btn'),
            worldBookSelectionModal = document.getElementById('world-book-selection-modal'),
            worldBookSelectionList = document.getElementById('world-book-selection-list'),
            saveWorldBookSelectionBtn = document.getElementById('save-world-book-selection-btn');
        const fontSettingsForm = document.getElementById('font-settings-form'),
            fontUrlInput = document.getElementById('font-url'),
            restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
        const createGroupBtn = document.getElementById('create-group-btn'),
            createGroupModal = document.getElementById('create-group-modal'),
            createGroupForm = document.getElementById('create-group-form'),
            memberSelectionList = document.getElementById('member-selection-list'),
            groupNameInput = document.getElementById('group-name-input'),
            groupSettingsSidebar = document.getElementById('group-settings-sidebar'),
            groupSettingsForm = document.getElementById('group-settings-form'),
            groupMembersListContainer = document.getElementById('group-members-list-container'),
            editGroupMemberModal = document.getElementById('edit-group-member-modal'),
            editGroupMemberForm = document.getElementById('edit-group-member-form');
        const addMemberActionSheet = document.getElementById('add-member-actionsheet'),
            inviteExistingMemberBtn = document.getElementById('invite-existing-member-btn'),
            createNewMemberBtn = document.getElementById('create-new-member-btn'),
            inviteMemberModal = document.getElementById('invite-member-modal'),
            inviteMemberSelectionList = document.getElementById('invite-member-selection-list'),
            confirmInviteBtn = document.getElementById('confirm-invite-btn'),
            createMemberForGroupModal = document.getElementById('create-member-for-group-modal'),
            createMemberForGroupForm = document.getElementById('create-member-for-group-form');
        const customizeForm = document.getElementById('customize-form'),
            tutorialContentArea = document.getElementById('tutorial-content-area');
        const groupRecipientSelectionModal = document.getElementById('group-recipient-selection-modal'),
            groupRecipientSelectionList = document.getElementById('group-recipient-selection-list'),
            confirmGroupRecipientBtn = document.getElementById('confirm-group-recipient-btn'),
            groupRecipientSelectionTitle = document.getElementById('group-recipient-selection-title');
        const linkGroupWorldBookBtn = document.getElementById('link-group-world-book-btn');
// --- NEW: File System Elements ---
const fileBtn = document.getElementById('file-btn'),
      sendFileModal = document.getElementById('send-file-modal'),
      sendFileForm = document.getElementById('send-file-form'),
      fileNameInput = document.getElementById('file-name-input'),
      fileContentInput = document.getElementById('file-content-input');
 // --- NEW: Location System Elements ---
const locationBtn = document.getElementById('location-btn'),
      sendLocationModal = document.getElementById('send-location-modal'),
      sendLocationForm = document.getElementById('send-location-form'),
      locationMainInput = document.getElementById('location-main-input'),
      locationDetailInput = document.getElementById('location-detail-input'),
      displayLocationModal = document.getElementById('display-location-modal'),
      displayLocationMap = document.getElementById('display-location-map'),
      displayLocationMain = document.getElementById('display-location-main'),
      displayLocationDetail = document.getElementById('display-location-detail'),
      closeLocationDisplayBtn = document.getElementById('close-location-display-btn');
        // --- Utility and Core Functions ---
        // --- ä¼˜åŒ–çš„æ•°æ®å­˜å‚¨ç³»ç»Ÿ ---
        class OptimizedDataStorage {
            constructor() {
                // åˆ›å»ºæ•°æ®åº“
                this.db = new Dexie('ç« é±¼å–·å¢¨æœºDB_V2');

                // å®šä¹‰æ•°æ®åº“ç»“æ„
                this.db.version(1).stores({
                    // åŸºç¡€æ•°æ®å­˜å‚¨
                    storage: 'key, value, timestamp',
                    // æ¶ˆæ¯åˆ†å—å­˜å‚¨
                    messageChunks: 'id, chatId, chatType, chunkIndex, messages, timestamp',
                    // å…ƒæ•°æ®å­˜å‚¨
                    metadata: 'key, value, timestamp'
                });

                // LRUç¼“å­˜é…ç½®
                this.cache = new Map();
                this.maxCacheSize = 50; // æœ€å¤§ç¼“å­˜50ä¸ªæ•°æ®å—
                this.chunkSize = 100; // æ¯ä¸ªæ•°æ®å—100æ¡æ¶ˆæ¯

                // æ€§èƒ½ç›‘æ§
                this.performanceMetrics = {
                    cacheHits: 0,
                    cacheMisses: 0,
                    operationTimes: [],
                    memoryUsage: 0
                };
            }



            // LRUç¼“å­˜ç®¡ç†
            updateCache(key, value) {
                if (this.cache.has(key)) {
                    this.cache.delete(key);
                }
                this.cache.set(key, value);

                if (this.cache.size > this.maxCacheSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }

                // æ›´æ–°å†…å­˜ä½¿ç”¨é‡ä¼°ç®—
                this.performanceMetrics.memoryUsage = JSON.stringify([...this.cache.values()]).length;
            }

            // ä»ç¼“å­˜è·å–æ•°æ®
            getFromCache(key) {
                if (this.cache.has(key)) {
                    const value = this.cache.get(key);
                    // ç§»åˆ°æœ€åï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
                    this.cache.delete(key);
                    this.cache.set(key, value);
                    this.performanceMetrics.cacheHits++;
                    return value;
                }
                this.performanceMetrics.cacheMisses++;
                return null;
            }

            // ä¿å­˜åŸºç¡€æ•°æ®ï¼ˆéæ¶ˆæ¯æ•°æ®ï¼‰
            async saveData(key, data) {
                const startTime = Date.now();
                try {
                    const item = {
                        key: key,
                        value: JSON.stringify(data),
                        timestamp: Date.now()
                    };

                    await this.db.storage.put(item);
                    this.updateCache(key, data);
                    console.log(`æ•°æ®å·²ä¿å­˜: ${key}`);
                    return true;
                } catch (error) {
                    console.error('ä¿å­˜æ•°æ®å¤±è´¥:', error);
                    return false;
                }
            }

            // è·å–åŸºç¡€æ•°æ®
            async getData(key) {
                const startTime = Date.now();
                try {
                    // å…ˆæ£€æŸ¥ç¼“å­˜
                    const cached = this.getFromCache(key);
                    if (cached !== null) {
                        return cached;
                    }

                    const item = await this.db.storage.get(key);
                    if (item) {
                        const data = JSON.parse(item.value);
                        this.updateCache(key, data);
                        return data;
                    } else {
                        console.log(`æœªæ‰¾åˆ°æ•°æ®: ${key}`);
                        return null;
                    }
                } catch (error) {
                    console.error('è·å–æ•°æ®å¤±è´¥:', error);
                    return null;
                }
            }

            // ä¿å­˜èŠå¤©æ¶ˆæ¯ï¼ˆåˆ†å—å­˜å‚¨ï¼‰
            async saveChatMessages(chatId, chatType, messages) {
                const startTime = Date.now();
                try {
                    // æ¸…é™¤è¯¥èŠå¤©çš„æ‰€æœ‰ç°æœ‰åˆ†å—
                    await this.db.messageChunks.where('chatId').equals(chatId).and(chunk => chunk.chatType === chatType).delete();

                    // å°†æ¶ˆæ¯åˆ†å—å­˜å‚¨
                    const chunks = [];
                    for (let i = 0; i < messages.length; i += this.chunkSize) {
                        const chunkMessages = messages.slice(i, i + this.chunkSize);
                        const chunkId = `${chatId}_${chatType}_${Math.floor(i / this.chunkSize)}`;

                        chunks.push({
                            id: chunkId,
                            chatId: chatId,
                            chatType: chatType,
                            chunkIndex: Math.floor(i / this.chunkSize),
                            messages: chunkMessages,
                            timestamp: Date.now()
                        });
                    }

                    if (chunks.length > 0) {
                        await this.db.messageChunks.bulkPut(chunks);
                    }

                    // æ›´æ–°ç¼“å­˜
                    const cacheKey = `messages_${chatId}_${chatType}`;
                    this.updateCache(cacheKey, messages);

                    console.log(`æ¶ˆæ¯å·²åˆ†å—ä¿å­˜: ${chatId} (${chunks.length}ä¸ªåˆ†å—)`);
                    return true;
                } catch (error) {
                    console.error('ä¿å­˜æ¶ˆæ¯å¤±è´¥:', error);
                    return false;
                }
            }

            // è·å–èŠå¤©æ¶ˆæ¯ï¼ˆæŒ‰éœ€åŠ è½½ï¼‰
            async getChatMessages(chatId, chatType, limit = null, offset = 0) {
                const startTime = Date.now();
                try {
                    const cacheKey = `messages_${chatId}_${chatType}`;

                    // å¦‚æœæ²¡æœ‰é™åˆ¶ï¼Œå…ˆæ£€æŸ¥ç¼“å­˜
                    if (!limit) {
                        const cached = this.getFromCache(cacheKey);
                        if (cached !== null) {
                            return cached;
                        }
                    }

                    // ä»æ•°æ®åº“è·å–åˆ†å—
                    const chunks = await this.db.messageChunks
                        .where('chatId').equals(chatId)
                        .and(chunk => chunk.chatType === chatType)
                        .sortBy('chunkIndex');

                    if (chunks.length === 0) {
                        return [];
                    }

                    // åˆå¹¶æ‰€æœ‰æ¶ˆæ¯
                    let allMessages = [];
                    chunks.forEach(chunk => {
                        allMessages = allMessages.concat(chunk.messages);
                    });

                    // å¦‚æœæ²¡æœ‰é™åˆ¶ï¼Œæ›´æ–°ç¼“å­˜
                    if (!limit) {
                        this.updateCache(cacheKey, allMessages);
                    }

                    // åº”ç”¨åˆ†é¡µ
                    if (limit) {
                        const result = allMessages.slice(offset, offset + limit);
                        return result;
                    }

                    return allMessages;
                } catch (error) {
                    console.error('è·å–æ¶ˆæ¯å¤±è´¥:', error);
                    return [];
                }
            }

            // æ·»åŠ å•æ¡æ¶ˆæ¯ï¼ˆå¢é‡æ›´æ–°ï¼‰
            async addMessage(chatId, chatType, message) {
                const startTime = Date.now();
                try {
                    // Find the last chunk for this chat
                    const lastChunk = await this.db.messageChunks
                        .where({ chatId: chatId, chatType: chatType })
                        .last();

                    if (lastChunk && lastChunk.messages.length < this.chunkSize) {
                        // Last chunk has space, update it
                        lastChunk.messages.push(message);
                        await this.db.messageChunks.put(lastChunk);
                    } else {
                        // No last chunk or it's full, create a new one
                        const newChunkIndex = lastChunk ? lastChunk.chunkIndex + 1 : 0;
                        const newChunkId = `${chatId}_${chatType}_${newChunkIndex}`;
                        const newChunk = {
                            id: newChunkId,
                            chatId: chatId,
                            chatType: chatType,
                            chunkIndex: newChunkIndex,
                            messages: [message],
                            timestamp: Date.now()
                        };
                        await this.db.messageChunks.put(newChunk);
                    }

                    // Invalidate the full history cache for this chat
                    const cacheKey = `messages_${chatId}_${chatType}`;
                    if (this.cache.has(cacheKey)) {
                        this.cache.delete(cacheKey);
                    }
                    
                    console.log(`æ¶ˆæ¯å·²å¢é‡æ·»åŠ : ${chatId}`);
                    return true;
                } catch (error) {
                    console.error('å¢é‡æ·»åŠ æ¶ˆæ¯å¤±è´¥:', error);
                    return false;
                }
            }

            // åˆ é™¤æ¶ˆæ¯
            async deleteMessage(chatId, chatType, messageId) {
                const startTime = Date.now();
                try {
                    const chunks = await this.db.messageChunks
                        .where({ chatId: chatId, chatType: chatType })
                        .toArray();

                    for (const chunk of chunks) {
                        const messageIndex = chunk.messages.findIndex(msg => msg.id === messageId);
                        if (messageIndex !== -1) {
                            chunk.messages.splice(messageIndex, 1);
                            if (chunk.messages.length > 0) {
                                await this.db.messageChunks.put(chunk);
                            } else {
                                // Delete the chunk if it's empty
                                await this.db.messageChunks.delete(chunk.id);
                            }
                            
                            // Invalidate cache
                            const cacheKey = `messages_${chatId}_${chatType}`;
                            if (this.cache.has(cacheKey)) {
                                this.cache.delete(cacheKey);
                            }
                            console.log(`æ¶ˆæ¯å·²åˆ é™¤: ${messageId}`);
                            return true;
                        }
                    }
                    console.warn(`åˆ é™¤å¤±è´¥: æœªæ‰¾åˆ°æ¶ˆæ¯ ${messageId}`);
                    return false;
                } catch (error) {
                    console.error('åˆ é™¤æ¶ˆæ¯å¤±è´¥:', error);
                    return false;
                }
            }

            // æ›´æ–°æ¶ˆæ¯
            async updateMessage(chatId, chatType, messageId, updatedMessage) {
                const startTime = Date.now();
                try {
                    const chunks = await this.db.messageChunks
                        .where({ chatId: chatId, chatType: chatType })
                        .toArray();

                    for (const chunk of chunks) {
                        const messageIndex = chunk.messages.findIndex(msg => msg.id === messageId);
                        if (messageIndex !== -1) {
                            // Merge updates into the existing message object
                            chunk.messages[messageIndex] = { ...chunk.messages[messageIndex], ...updatedMessage };
                            await this.db.messageChunks.put(chunk);
                            
                            // Invalidate cache
                            const cacheKey = `messages_${chatId}_${chatType}`;
                            if (this.cache.has(cacheKey)) {
                                this.cache.delete(cacheKey);
                            }
                            console.log(`æ¶ˆæ¯å·²æ›´æ–°: ${messageId}`);
                            return true;
                        }
                    }
                    console.warn(`æ›´æ–°å¤±è´¥: æœªæ‰¾åˆ°æ¶ˆæ¯ ${messageId}`);
                    return false;
                } catch (error) {
                    console.error('æ›´æ–°æ¶ˆæ¯å¤±è´¥:', error);
                    return false;
                }
            }

            // æ¸…ç©ºèŠå¤©è®°å½•
            async clearChatMessages(chatId, chatType) {
                const startTime = Date.now();
                try {
                    await this.db.messageChunks.where('chatId').equals(chatId).and(chunk => chunk.chatType === chatType).delete();

                    // æ¸…é™¤ç¼“å­˜
                    const cacheKey = `messages_${chatId}_${chatType}`;
                    this.cache.delete(cacheKey);


                    return true;
                } catch (error) {
                    console.error('æ¸…ç©ºæ¶ˆæ¯å¤±è´¥:', error);

                    return false;
                }
            }

            // åˆ é™¤æ•°æ®
            async removeData(key) {
                const startTime = Date.now();
                try {
                    await this.db.storage.delete(key);
                    this.cache.delete(key);
                    console.log(`æ•°æ®å·²åˆ é™¤: ${key}`);

                    return true;
                } catch (error) {
                    console.error('åˆ é™¤æ•°æ®å¤±è´¥:', error);

                    return false;
                }
            }

            // æ¸…ç©ºæ‰€æœ‰æ•°æ®
            async clearAll() {
                const startTime = Date.now();
                try {
                    await this.db.storage.clear();
                    await this.db.messageChunks.clear();
                    await this.db.metadata.clear();
                    this.cache.clear();
                    console.log('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º');

                    return true;
                } catch (error) {
                    console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error);

                    return false;
                }
            }

            // è·å–æ‰€æœ‰å­˜å‚¨çš„é”®
            async getAllKeys() {
                try {
                    const storageItems = await this.db.storage.toArray();
                    return storageItems.map(item => item.key);
                } catch (error) {
                    console.error('è·å–æ‰€æœ‰é”®å¤±è´¥:', error);
                    return [];
                }
            }

            // è·å–å­˜å‚¨ä¿¡æ¯
            async getStorageInfo() {
                const startTime = Date.now();
                try {
                    const [storageItems, messageChunks] = await Promise.all([
                        this.db.storage.toArray(),
                        this.db.messageChunks.toArray()
                    ]);

                    const storageSize = storageItems.reduce((sum, item) => sum + item.value.length, 0);
                    const messageSize = messageChunks.reduce((sum, chunk) => sum + JSON.stringify(chunk.messages).length, 0);
                    const totalSize = storageSize + messageSize;

                    const info = {
                        itemCount: storageItems.length,
                        chunkCount: messageChunks.length,
                        totalSize: totalSize,
                        storageSize: storageSize,
                        messageSize: messageSize,
                        cacheSize: this.cache.size,
                        items: storageItems.map(item => ({
                            key: item.key,
                            size: item.value.length,
                            timestamp: new Date(item.timestamp).toLocaleString()
                        }))
                    };

                    // æ›´æ–°æ˜¾ç¤º
                    this.updateStorageDisplay(info);

                    return info;
                } catch (error) {
                    console.error('è·å–å­˜å‚¨ä¿¡æ¯å¤±è´¥:', error);

                    return null;
                }
            }

            // æ›´æ–°å­˜å‚¨ä¿¡æ¯æ˜¾ç¤º
            updateStorageDisplay(info) {
                const monitor = document.getElementById('performance-monitor');
                if (!monitor) return;

                document.getElementById('storage-size').textContent = `${(info.totalSize / 1024).toFixed(1)} KB`;
                document.getElementById('chunk-count').textContent = info.chunkCount.toString();

                // è®¾ç½®å­˜å‚¨å¤§å°é¢œè‰²æŒ‡ç¤ºå™¨
                const sizeElement = document.getElementById('storage-size');
                const sizeKB = info.totalSize / 1024;
                if (sizeKB < 1000) sizeElement.className = 'metric-value good';
                else if (sizeKB < 5000) sizeElement.className = 'metric-value warning';
                else sizeElement.className = 'metric-value error';
            }

            // æ•°æ®è¿ç§»æ–¹æ³•ï¼ˆä»æ—§ç‰ˆæœ¬è¿ç§»ï¼‰
            async migrateFromOldStorage() {
                const startTime = Date.now();
                let oldDb = null;
                let migrationSuccess = false;

                try {
                    // å°è¯•ä»æ—§æ•°æ®åº“è·å–æ•°æ®
                    oldDb = new Dexie('ç« é±¼å–·å¢¨æœºDB');
                    oldDb.version(1).stores({
                        storage: 'key, value, timestamp'
                    });

                    // æ£€æŸ¥æ—§æ•°æ®åº“æ˜¯å¦å­˜åœ¨æ•°æ®
                    const oldData = await oldDb.storage.get('ç« é±¼å–·å¢¨æœº');
                    if (oldData) {
                        console.log('æ£€æµ‹åˆ°æ—§æ•°æ®åº“ï¼Œå¼€å§‹è¿ç§»...');
                        const data = JSON.parse(oldData.value);

                        // è¿ç§»åŸºç¡€æ•°æ®
                        const { characters, groups, ...baseData } = data;
                        await this.saveData('ç« é±¼å–·å¢¨æœº', baseData);

                        let migratedCharacters = 0;
                        let migratedGroups = 0;

                        // è¿ç§»è§’è‰²æ¶ˆæ¯
                        if (characters) {
                            for (const char of characters) {
                                if (char.history && char.history.length > 0) {
                                    await this.saveChatMessages(char.id, 'private', char.history);
                                }
                                // ä¿å­˜è§’è‰²ä¿¡æ¯ï¼ˆä¸åŒ…å«historyï¼‰
                                const { history, ...charData } = char;
                                charData.history = []; // ä¿æŒå…¼å®¹æ€§
                                await this.saveData(`character_${char.id}`, charData);
                                migratedCharacters++;
                            }
                        }

                        // è¿ç§»ç¾¤ç»„æ¶ˆæ¯
                        if (groups) {
                            for (const group of groups) {
                                if (group.history && group.history.length > 0) {
                                    await this.saveChatMessages(group.id, 'group', group.history);
                                }
                                // ä¿å­˜ç¾¤ç»„ä¿¡æ¯ï¼ˆä¸åŒ…å«historyï¼‰
                                const { history, ...groupData } = group;
                                groupData.history = []; // ä¿æŒå…¼å®¹æ€§
                                await this.saveData(`group_${group.id}`, groupData);
                                migratedGroups++;
                            }
                        }

                        migrationSuccess = true;
                        console.log(`æ•°æ®è¿ç§»å®Œæˆ: ${migratedCharacters}ä¸ªè§’è‰², ${migratedGroups}ä¸ªç¾¤ç»„`);

                        // è¿ç§»æˆåŠŸåç«‹å³åˆ é™¤æ—§æ•°æ®åº“
                        try {
                            console.log('å¼€å§‹åˆ é™¤æ—§æ•°æ®åº“...');

                            // å…³é—­æ•°æ®åº“è¿æ¥
                            if (oldDb.isOpen()) {
                                oldDb.close();
                            }

                            // åˆ é™¤æ•´ä¸ªæ•°æ®åº“
                            await oldDb.delete();
                            console.log('æ—§æ•°æ®åº“åˆ é™¤æˆåŠŸ');

                            // éªŒè¯åˆ é™¤æ˜¯å¦æˆåŠŸ
                            const deletedDb = new Dexie('ç« é±¼å–·å¢¨æœºDB');
                            try {
                                deletedDb.version(1).stores({
                                    storage: 'key, value, timestamp'
                                });
                                const testData = await deletedDb.storage.get('ç« é±¼å–·å¢¨æœº');
                                if (!testData) {
                                    console.log('æ—§æ•°æ®åº“åˆ é™¤éªŒè¯æˆåŠŸ');
                                } else {
                                    console.warn('æ—§æ•°æ®åº“å¯èƒ½æœªå®Œå…¨åˆ é™¤');
                                }
                                deletedDb.close();
                            } catch (verifyError) {
                                // å¦‚æœæ— æ³•è®¿é—®ï¼Œè¯´æ˜åˆ é™¤æˆåŠŸ
                                console.log('æ—§æ•°æ®åº“åˆ é™¤éªŒè¯æˆåŠŸï¼ˆæ•°æ®åº“ä¸å­˜åœ¨ï¼‰');
                            }

                        } catch (deleteError) {
                            console.error('åˆ é™¤æ—§æ•°æ®åº“å¤±è´¥ï¼Œä½†ä¸å½±å“ä¸»è¦åŠŸèƒ½:', deleteError);
                            // å°è¯•æ¸…ç©ºæ•°æ®è€Œä¸æ˜¯åˆ é™¤æ•°æ®åº“
                            try {
                                if (!oldDb.isOpen()) {
                                    await oldDb.open();
                                }
                                await oldDb.storage.clear();
                                console.log('å·²æ¸…ç©ºæ—§æ•°æ®åº“å†…å®¹');
                                oldDb.close();
                            } catch (clearError) {
                                console.error('æ¸…ç©ºæ—§æ•°æ®åº“ä¹Ÿå¤±è´¥:', clearError);
                            }
                        }

                        return true;
                    } else {
                        console.log('æœªå‘ç°æ—§æ•°æ®åº“æ•°æ®');
                        // å³ä½¿æ²¡æœ‰æ•°æ®ï¼Œä¹Ÿå°è¯•åˆ é™¤å¯èƒ½å­˜åœ¨çš„ç©ºæ•°æ®åº“
                        try {
                            if (oldDb.isOpen()) {
                                oldDb.close();
                            }
                            await oldDb.delete();
                            console.log('å·²åˆ é™¤ç©ºçš„æ—§æ•°æ®åº“');
                        } catch (deleteError) {
                            // åˆ é™¤å¤±è´¥å¯èƒ½æ˜¯å› ä¸ºæ•°æ®åº“ä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸çš„
                            console.log('æ—§æ•°æ®åº“ä¸å­˜åœ¨æˆ–å·²åˆ é™¤');
                        }
                        return false;
                    }


                    return false;
                } catch (error) {
                    console.error('æ•°æ®è¿ç§»å¤±è´¥:', error);

                    // å³ä½¿è¿ç§»å¤±è´¥ï¼Œä¹Ÿå°è¯•æ¸…ç†æ—§æ•°æ®åº“è¿æ¥
                    if (oldDb) {
                        try {
                            if (oldDb.isOpen()) {
                                oldDb.close();
                                console.log('å·²å…³é—­æ—§æ•°æ®åº“è¿æ¥');
                            }
                        } catch (closeError) {
                            console.error('å…³é—­æ—§æ•°æ®åº“è¿æ¥å¤±è´¥:', closeError);
                        }
                    }

                    return false;
                } finally {
                    // ç¡®ä¿åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½è®°å½•è¿ç§»è€—æ—¶
                    const duration = Date.now() - startTime;
                    console.log(`æ•°æ®è¿ç§»æ“ä½œå®Œæˆï¼Œè€—æ—¶: ${duration}ms, æˆåŠŸ: ${migrationSuccess}`);
                }
            }
        }

        const dataStorage = new OptimizedDataStorage();

        // å…¼å®¹æ€§é€‚é…å™¨ - ä¿æŒåŸæœ‰APIæ¥å£
        const saveData = async (data) => {
            const dbData = data ? data : db;

            // ä¿®æ”¹ï¼šåˆ†ç¦»å‡ºæ‰€æœ‰éœ€è¦ç‹¬ç«‹ä¿å­˜çš„é‡è¦æ•°æ®
            const { 
                characters, 
                groups, 
                worldBooks, 
                apiSettings,
                customIcons,
                wallpaper,
                wallpaper2,
                aiSpaceWallpaper,
                homeProfile,
                // ... ä½ æœªæ¥å¯èƒ½å¢åŠ çš„å…¶ä»–é¡¶å±‚å¤æ‚æ•°æ®
                ...baseData // å‰©ä½™çš„ç®€å•æ•°æ®
            } = dbData;

            // ä¿å­˜å‰©ä½™çš„åŸºç¡€æ•°æ®
            await dataStorage.saveData('ç« é±¼å–·å¢¨æœº', baseData);

            // æ–°å¢ï¼šä¸ºæ¯ä¸€é¡¹é‡è¦æ•°æ®åˆ›å»ºç‹¬ç«‹çš„ä¿å­˜é€šé“
            if (worldBooks) await dataStorage.saveData('worldBooks_data', worldBooks);
            if (apiSettings) await dataStorage.saveData('apiSettings_data', apiSettings);
            if (customIcons) await dataStorage.saveData('customIcons_data', customIcons);
            if (wallpaper) await dataStorage.saveData('wallpaper_data', wallpaper);
            if (wallpaper2) await dataStorage.saveData('wallpaper2_data', wallpaper2);
            if (aiSpaceWallpaper) await dataStorage.saveData('aiSpaceWallpaper_data', aiSpaceWallpaper);
            if (homeProfile) await dataStorage.saveData('homeProfile_data', homeProfile);


            // åˆ†åˆ«ä¿å­˜è§’è‰²å’Œç¾¤ç»„æ•°æ®ï¼ˆåŒ…å«æ¶ˆæ¯ï¼‰
            if (characters) {
                for (const char of characters) {
                    // ä¿å­˜æ¶ˆæ¯åˆ°åˆ†å—å­˜å‚¨
                    if (char.history && char.history.length > 0) {
                        await dataStorage.saveChatMessages(char.id, 'private', char.history);
                    }
                    // ä¿å­˜è§’è‰²åŸºç¡€ä¿¡æ¯ï¼ˆä¸åŒ…å«historyï¼‰
                    const { history, ...charData } = char;
                    charData.history = []; // ä¿æŒå…¼å®¹æ€§
                    await dataStorage.saveData(`character_${char.id}`, charData);
                }
            }

            if (groups) {
                for (const group of groups) {
                    // ä¿å­˜æ¶ˆæ¯åˆ°åˆ†å—å­˜å‚¨
                    if (group.history && group.history.length > 0) {
                        await dataStorage.saveChatMessages(group.id, 'group', group.history);
                    }
                    // ä¿å­˜ç¾¤ç»„åŸºç¡€ä¿¡æ¯ï¼ˆä¸åŒ…å«historyï¼‰
                    const { history, ...groupData } = group;
                    groupData.history = []; // ä¿æŒå…¼å®¹æ€§
                    await dataStorage.saveData(`group_${group.id}`, groupData);
                }
            }

            return Promise.resolve();
        };


   // â–¼â–¼â–¼ è¯·ä»è¿™é‡Œå¼€å§‹ï¼Œä¸€ç›´å¤åˆ¶åˆ°æœ€ä¸‹é¢çš„â€œå¤åˆ¶ç»“æŸâ€æ³¨é‡Š â–¼â–¼â–¼
        const loadData = async () => {
            // é¦–å…ˆå°è¯•æ•°æ®è¿ç§»
            await dataStorage.migrateFromOldStorage();

            // æ£€æŸ¥localStorageä¸­çš„æ—§æ•°æ®
            const oldData = localStorage.getItem('gemini-chat-app-db');
            if (oldData) {
                console.log('æ£€æµ‹åˆ°localStorageä¸­çš„æ—§æ•°æ®ï¼Œå¼€å§‹è¿ç§»...');
                await saveData(JSON.parse(oldData));
                localStorage.removeItem('gemini-chat-app-db');
                console.log('localStorageæ—§æ•°æ®è¿ç§»å®Œæˆå¹¶å·²æ¸…ç†');
            }

            // é¢å¤–çš„å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿æ—§æ•°æ®åº“å®Œå…¨æ¸…ç†
            try {
                const safetyCheckDb = new Dexie('ç« é±¼å–·å¢¨æœºDB');
                safetyCheckDb.version(1).stores({
                    storage: 'key, value, timestamp'
                });

                const residualData = await safetyCheckDb.storage.get('ç« é±¼å–·å¢¨æœº');
                if (residualData) {
                    console.warn('å‘ç°æ®‹ç•™çš„æ—§æ•°æ®åº“æ•°æ®ï¼Œæ‰§è¡Œå¼ºåˆ¶æ¸…ç†...');
                    await safetyCheckDb.storage.clear();
                    safetyCheckDb.close();
                    await safetyCheckDb.delete();
                    console.log('æ®‹ç•™æ—§æ•°æ®åº“å·²å¼ºåˆ¶æ¸…ç†');
                } else {
                    safetyCheckDb.close();
                }
            } catch (safetyError) {
                // å¦‚æœæ— æ³•è®¿é—®æ—§æ•°æ®åº“ï¼Œè¯´æ˜å·²ç»è¢«æ­£ç¡®åˆ é™¤
                console.log('æ—§æ•°æ®åº“å®‰å…¨æ£€æŸ¥å®Œæˆï¼ˆæ•°æ®åº“ä¸å­˜åœ¨ï¼‰');
            }

            // åŠ è½½åŸºç¡€æ•°æ®
            let data = await dataStorage.getData('ç« é±¼å–·å¢¨æœº');
            if (data) {
                db = { ...db, ...data };
            }
    // --- æ–°å¢ï¼šä»ç‹¬ç«‹é€šé“åŠ è½½æ‰€æœ‰é‡è¦æ•°æ® ---

            // --- å…¼å®¹æ—§ç‰ˆä¸–ç•Œä¹¦æ•°æ®çš„è¿ç§»é€»è¾‘ ---
            const loadedWorldBooks = await dataStorage.getData('worldBooks_data');
            if (loadedWorldBooks && loadedWorldBooks.length > 0) {
                // å¦‚æœæ–°çš„ä¸“ç”¨ä½ç½®æœ‰æ•°æ®ï¼Œå°±ä¼˜å…ˆä½¿ç”¨å®ƒ
                db.worldBooks = loadedWorldBooks;
            } else if (db.worldBooks && db.worldBooks.length > 0) {
                // å¦‚æœä¸“ç”¨ä½ç½®æ²¡æ•°æ®ï¼Œä½†æˆ‘ä»¬ä»æ—§çš„å¤§åŒ…é‡Œè¯»å‡ºäº†ä¸–ç•Œä¹¦æ•°æ®
                // å°±æŠŠå®ƒä¿å­˜åˆ°æ–°çš„ä¸“ç”¨ä½ç½®ï¼Œå®Œæˆæ•°æ®â€œæ¬å®¶â€
                await dataStorage.saveData('worldBooks_data', db.worldBooks);
                console.log('å·²æˆåŠŸå°†æ—§ç‰ˆä¸–ç•Œä¹¦æ•°æ®è¿ç§»åˆ°æ–°å­˜å‚¨ä½ç½®ã€‚');
            } else {
                // å¦‚æœä¸¤è¾¹éƒ½æ²¡æœ‰ï¼Œé‚£æ‰æ˜¯çœŸçš„æ²¡æœ‰ä¸–ç•Œä¹¦
                db.worldBooks = [];
            }
            // --- è¿ç§»é€»è¾‘ç»“æŸ ---
  // â–¼â–¼â–¼ åœ¨è¿™é‡Œæ·»åŠ æ–°çš„ä»£ç  â–¼â–¼â–¼
            // --- æ–°å¢ï¼šä¸ºæ—§ç‰ˆä¸–ç•Œä¹¦æ•°æ®æ·»åŠ åˆ†ç±»å…¼å®¹ ---
            if (db.worldBooks && db.worldBooks.length > 0) {
                db.worldBooks.forEach(book => {
                    if (book.categoryId === undefined) {
                        book.categoryId = 'uncategorized';
                    }
                });
            }
            // --- å…¼å®¹ä»£ç ç»“æŸ ---
            // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
            db.apiSettings = await dataStorage.getData('apiSettings_data') || {};
            db.customIcons = await dataStorage.getData('customIcons_data') || {};
            db.wallpaper = await dataStorage.getData('wallpaper_data') || 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            db.wallpaper2 = await dataStorage.getData('wallpaper2_data') || 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            db.aiSpaceWallpaper = await dataStorage.getData('aiSpaceWallpaper_data') || '';
            db.homeProfile = await dataStorage.getData('homeProfile_data') || { name: 'ç‚¹å‡»è®¾ç½®æ˜µç§°', signature: 'ç‚¹å‡»è®¾ç½®ä¸ªæ€§ç­¾å', avatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg', heroBg: 'https://i.postimg.cc/wM57022X/image.png' };
            // --- æ–°å¢ç»“æŸ ---

            // (åœ¨ loadData å‡½æ•°å†…éƒ¨ï¼Œé è¿‘å…¶ä»– if (!db.xxx) çš„åœ°æ–¹æ·»åŠ )
if (!db.avatarFrames) {
    db.avatarFrames = []; // åˆå§‹åŒ–å…¨å±€å¤´åƒæ¡†åˆ—è¡¨
}
db.characters.forEach(c => {
    if (c.avatarFrameUrl === undefined) c.avatarFrameUrl = null;
    if (c.myAvatarFrameUrl === undefined) c.myAvatarFrameUrl = null;
});
db.groups.forEach(g => {
    if (g.me.avatarFrameUrl === undefined) g.me.avatarFrameUrl = null;
    g.members.forEach(m => {
        if (m.avatarFrameUrl === undefined) m.avatarFrameUrl = null;
    });
});
            if (db.uncategorizedCollapsed === undefined) {
    db.uncategorizedCollapsed = false; // é»˜è®¤ä¸æŠ˜å 
}// åˆå§‹åŒ–é»˜è®¤å€¼
            if (!db.apiSettings) db.apiSettings = {};
if (!db.wallet) {
    db.wallet = {
        balance: 0.00,
        passwordEnabled: false,
        password: null,
        transactions: []
    };
}
            if (!db.wallpaper) db.wallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            if (!db.wallpaper2) db.wallpaper2 = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg'; // æ–°å¢
            if (!db.myStickers) db.myStickers = [];
          if (!db.aiSpaceWallpaper) db.aiSpaceWallpaper = ''; // ä¸ºAIæ‰‹æœºå£çº¸åˆå§‹åŒ–é»˜è®¤å€¼
            if (!db.homeScreenMode) db.homeScreenMode = 'night';
            if (!db.worldBooks) db.worldBooks = [];
            if (!db.fontUrl) db.fontUrl = '';
            if (!db.customIcons) db.customIcons = {};
if (!db.homeProfile) {
                db.homeProfile = {
                    name: 'ç‚¹å‡»è®¾ç½®æ˜µç§°',
                    signature: 'ç‚¹å‡»è®¾ç½®ä¸ªæ€§ç­¾å',
                    avatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                    heroBg: 'https://i.postimg.cc/wM57022X/image.png'
                };
            }

            
            if (!db.worldBooks) db.worldBooks = []; // å…¼å®¹æ€§æ£€æŸ¥
            // --- ç»“æŸ ---

            // é‡å»ºcharacterså’Œgroupsåˆ—è¡¨
            // ç”±äºsaveDataæ—¶è¿™ä¸¤ä¸ªå­—æ®µè¢«æ’é™¤ï¼Œéœ€è¦ä»å­˜å‚¨ä¸­é‡æ–°æ„å»º
            db.characters = [];
            db.groups = [];

            // è·å–æ‰€æœ‰å­˜å‚¨çš„é”®ï¼Œæ‰¾å‡ºè§’è‰²å’Œç¾¤ç»„æ•°æ®
            const allKeys = await dataStorage.getAllKeys();
            const characterKeys = allKeys.filter(key => key.startsWith('character_'));
            const groupKeys = allKeys.filter(key => key.startsWith('group_'));

            console.log(`å‘ç° ${characterKeys.length} ä¸ªè§’è‰²æ•°æ®, ${groupKeys.length} ä¸ªç¾¤ç»„æ•°æ®`);

            // åŠ è½½è§’è‰²æ•°æ®
            const characterPromises = characterKeys.map(async (key) => {
                const charId = key.replace('character_', '');
                const charData = await dataStorage.getData(key);
                if (charData) {
                    // æŒ‰éœ€åŠ è½½æ¶ˆæ¯å†å²
                    charData.history = await dataStorage.getChatMessages(charId, 'private');

                    // è®¾ç½®é»˜è®¤å€¼
                    if (charData.isPinned === undefined) charData.isPinned = false;
                    if (charData.status === undefined) charData.status = 'åœ¨çº¿';
                    if (!charData.worldBookIds) charData.worldBookIds = [];
                    if (charData.customBubbleCss === undefined) charData.customBubbleCss = '';
                    if (charData.useCustomBubbleCss === undefined) charData.useCustomBubbleCss = false;
// ä¸ºæ—§æ•°æ®å…¼å®¹ç”¨æˆ·æ—¥è®°
                    return charData;
                }
                return null;
            });

            // åŠ è½½ç¾¤ç»„æ•°æ®
            const groupPromises = groupKeys.map(async (key) => {
                const groupId = key.replace('group_', '');
                const groupData = await dataStorage.getData(key);
                if (groupData) {
                    // æŒ‰éœ€åŠ è½½æ¶ˆæ¯å†å²
                    groupData.history = await dataStorage.getChatMessages(groupId, 'group');

                    // è®¾ç½®é»˜è®¤å€¼
                    if (groupData.isPinned === undefined) groupData.isPinned = false;
                    if (!groupData.worldBookIds) groupData.worldBookIds = [];
                    if (groupData.customBubbleCss === undefined) groupData.customBubbleCss = '';
                    if (groupData.useCustomBubbleCss === undefined) groupData.useCustomBubbleCss = false;

                    return groupData;
                }
                return null;
            });

            // ç­‰å¾…æ‰€æœ‰æ•°æ®åŠ è½½å®Œæˆ
            const [loadedCharacters, loadedGroups] = await Promise.all([
                Promise.all(characterPromises),
                Promise.all(groupPromises)
            ]);

            // è¿‡æ»¤æ‰nullå€¼å¹¶èµ‹å€¼ç»™db
            db.characters = loadedCharacters.filter(char => char !== null);
            db.groups = loadedGroups.filter(group => group !== null);

            console.log(`æˆåŠŸåŠ è½½ ${db.characters.length} ä¸ªè§’è‰², ${db.groups.length} ä¸ªç¾¤ç»„`);
            console.log('å®Œæ•´æ•°æ®åº“å¯¹è±¡:', db);

         
            return Promise.resolve();
        };
// â–²â–²â–² å¤åˆ¶ç»“æŸ â–²â–²â–²

// ===== ğŸ†• è¡¨æƒ…åŒ…åˆ†ç»„åŠŸèƒ½ï¼šæ•°æ®è¿ç§»å‡½æ•° =====
/**
 * è¿ç§»æ—§ç‰ˆè¡¨æƒ…åŒ…æ•°æ®åˆ°åˆ†ç»„ç‰ˆæœ¬
 * - ä¸ºæ—§è¡¨æƒ…åŒ…æ·»åŠ  group å­—æ®µï¼ˆnull = æœªåˆ†ç±»ï¼‰
 * - ä¸ºæ—§è¡¨æƒ…åŒ…æ·»åŠ  lastUsedTime å­—æ®µ
 */
async function migrateStickersToGroupVersion() {
    let needSave = false;
    
    if (!db.myStickers) {
        db.myStickers = [];
        return;
    }
    
    db.myStickers.forEach(sticker => {
        // æ£€æŸ¥æ˜¯å¦å·²æœ‰ group å­—æ®µï¼ˆå·²è¿ç§»è¿‡ï¼‰
        if (sticker.group === undefined) {
            sticker.group = null;  // å½’å…¥"æœªåˆ†ç±»"
            needSave = true;
        }
        
        // æ£€æŸ¥æ˜¯å¦å·²æœ‰ lastUsedTimeï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
        if (!sticker.lastUsedTime) {
            sticker.lastUsedTime = Date.now();
            needSave = true;
        }
    });
    
    if (needSave) {
        await saveData();
        console.log('âœ… è¡¨æƒ…åŒ…æ•°æ®å·²è¿ç§»åˆ°åˆ†ç»„ç‰ˆæœ¬');
    }
}

/**
 * è¿ç§»è§’è‰²çš„è¡¨æƒ…åŒ…æƒé™è®¾ç½®
 * - å°†æ—§çš„ shareStickers å¸ƒå°”å€¼è½¬æ¢ä¸º stickerGroups å­—ç¬¦ä¸²
 */
async function migrateCharacterStickerBindings() {
    let needSave = false;
    
    db.characters.forEach(char => {
        // å¦‚æœæœ‰æ—§çš„ shareStickers å­—æ®µ
        if (char.shareStickers === true && !char.stickerGroups) {
            // å°†æ‰€æœ‰åˆ†ç»„ç»‘å®šç»™è¯¥è§’è‰²ï¼ˆä¿æŒæ—§è¡Œä¸ºï¼‰
            const allGroups = [...new Set(
                db.myStickers
                    .map(s => s.group || 'æœªåˆ†ç±»')
                    .filter(Boolean)
            )];
            char.stickerGroups = allGroups.join(',');
            needSave = true;
        } else if (char.stickerGroups === undefined) {
            char.stickerGroups = '';  // åˆå§‹åŒ–ä¸ºç©ºï¼ˆä¸ç»‘å®šä»»ä½•è¡¨æƒ…ï¼‰
            needSave = true;
        }
    });
    
    if (needSave) {
        await saveData();
        console.log('âœ… è§’è‰²è¡¨æƒ…åŒ…ç»‘å®šå·²è¿ç§»');
    }
}
// ===== è¿ç§»å‡½æ•°ç»“æŸ =====

        const switchScreen = (targetId) => {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetId)?.classList.add('active');
            // Close all overlays and sidebars
            const overlays = document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar');
            overlays.forEach(o => o.classList.remove('visible', 'open'));
        };
        // START: æ–°å¢HTMLè½¬ä¹‰å‡½æ•°
function escapeHTML(str) {
    if (!str) return '';
    return str.replace(/[&<>"']/g, function(match) {
        return {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        }[match];
    });
}
// END: æ–°å¢HTMLè½¬ä¹‰å‡½æ•°
// --- NEW: File size formatting utility ---
function formatFileSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
        function createContextMenu(items, x, y) {
            removeContextMenu();
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                if (item.danger) menuItem.classList.add('danger');
                menuItem.textContent = item.label;
                menuItem.onclick = () => {
                    item.action();
                    removeContextMenu();
                };
                menu.appendChild(menuItem);
            });
            document.body.appendChild(menu);
            document.addEventListener('click', removeContextMenu, {once: true});
        }

        function removeContextMenu() {
            const menu = document.querySelector('.context-menu');
            if (menu) menu.remove();
        }
        function applyGlobalCss(css) {
            const styleId = 'global-custom-css-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            styleElement.textContent = css || '';
        }
        function updateCustomBubbleStyle(chatId, css, enabled) {
            const styleId = `custom-bubble-style-for-${chatId}`;
            let styleElement = document.getElementById(styleId);

            if (enabled && css) {
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#chat-room-screen.chat-active-${chatId} $1`);
                styleElement.innerHTML = scopedCss;
            } else {
                if (styleElement) styleElement.remove();
            }
        }

        function updateBubbleCssPreview(previewContainer, css, useDefault, theme) {
            previewContainer.innerHTML = '';

            const sentBubble = document.createElement('div');
            sentBubble.className = 'message-bubble sent';
            sentBubble.textContent = 'è¿™æ˜¯æˆ‘æ–¹æ°”æ³¡ã€‚';
            sentBubble.style.alignSelf = 'flex-end';
            sentBubble.style.borderBottomRightRadius = '5px';

            const receivedBubble = document.createElement('div');
            receivedBubble.className = 'message-bubble received';
            receivedBubble.textContent = 'è¿™æ˜¯å¯¹æ–¹æ°”æ³¡ã€‚';
            receivedBubble.style.alignSelf = 'flex-start';
            receivedBubble.style.borderBottomLeftRadius = '5px';

            [sentBubble, receivedBubble].forEach(bubble => {
                bubble.style.maxWidth = '70%';
                bubble.style.padding = '8px 12px';
                bubble.style.wordWrap = 'break-word';
                bubble.style.lineHeight = '1.4';
            });

            if (useDefault || !css) {
                sentBubble.style.backgroundColor = theme.sent.bg;
                sentBubble.style.color = theme.sent.text;
                sentBubble.style.borderRadius = '18px';
                sentBubble.style.borderBottomRightRadius = '5px';
                receivedBubble.style.backgroundColor = theme.received.bg;
                receivedBubble.style.color = theme.received.text;
                receivedBubble.style.borderRadius = '18px';
                receivedBubble.style.borderBottomLeftRadius = '5px';
            } else {
                const styleTag = document.createElement('style');
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#${previewContainer.id} $1`);
                styleTag.textContent = scopedCss;
                previewContainer.appendChild(styleTag);
            }
            previewContainer.appendChild(receivedBubble);
            previewContainer.appendChild(sentBubble);
        }
        // ===============================================================
// START: é’±åŒ…åŠŸèƒ½æ ¸å¿ƒä»£ç 
// ===============================================================

// --- äº¤æ˜“è®°å½• ---
function addTransaction(type, amount, description) {
    if (!db.wallet) return;
    
    // 1. æ›´æ–°ä½™é¢
    const numericAmount = parseFloat(amount);
    if (type === 'income') {
        db.wallet.balance += numericAmount;
    } else if (type === 'expense') {
        db.wallet.balance -= numericAmount;
    }
    db.wallet.balance = parseFloat(db.wallet.balance.toFixed(2)); // é¿å…ç²¾åº¦é—®é¢˜

    // 2. æ·»åŠ äº¤æ˜“è®°å½•
    const transaction = {
        id: `tx_${Date.now()}`,
        type, // 'income' or 'expense'
        amount: numericAmount,
        description,
        timestamp: Date.now()
    };
    db.wallet.transactions.unshift(transaction); // unshiftä½¿æœ€æ–°è®°å½•åœ¨æœ€å‰

    // 3. é™åˆ¶äº¤æ˜“è®°å½•æ•°é‡ï¼Œé˜²æ­¢æ— é™å¢é•¿
    if (db.wallet.transactions.length > 200) {
        db.wallet.transactions.pop();
    }
    
    // 4. æ›´æ–°UIæ˜¾ç¤º
    const balanceDisplay = document.getElementById('wallet-balance-display');
    if (balanceDisplay) {
        balanceDisplay.textContent = db.wallet.balance.toFixed(2);
    }
}

// --- æ”¯ä»˜æµç¨‹å¤„ç† (äº‹ä»¶ç›‘å¬å™¨ä¿®å¤ç‰ˆ) ---
function handlePayment(amount, description) {
    return new Promise((resolve, reject) => {
        if (db.wallet.passwordEnabled === false) {
            if (db.wallet.balance < amount) {
                reject(new Error('é›¶èŠ±é’±ä½™é¢ä¸è¶³'));
                return;
            }
            addTransaction('expense', amount, description);
            resolve(); 
            return;
        }

        if (!db.wallet.password) {
            reject(new Error('è¯·å…ˆå‰å¾€â€œæˆ‘â€-â€œæ”¯ä»˜è®¾ç½®â€è®¾ç½®æ”¯ä»˜å¯†ç ï¼'));
            return;
        }
        if (db.wallet.balance < amount) {
            reject(new Error('é›¶èŠ±é’±ä½™é¢ä¸è¶³'));
            return;
        }

        const modal = document.getElementById('payment-password-modal');
        const title = document.getElementById('payment-prompt-title');
        const desc = document.getElementById('payment-prompt-description');
        const passwordInput = document.getElementById('payment-password-input');
        const confirmBtn = document.getElementById('confirm-payment-btn');
        const cancelBtn = document.getElementById('cancel-payment-btn');

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šå…‹éš†å¹¶æ›¿æ¢æŒ‰é’®ä»¥æ¸…é™¤æ‰€æœ‰æ—§çš„äº‹ä»¶ç›‘å¬å™¨ ---
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        
        const newCancelBtn = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        // --- ä¿®æ”¹ç»“æŸ ---

        title.textContent = description;
        desc.innerHTML = `<p style="font-size: 24px; font-weight: bold; margin: 10px 0;">Â¥ ${amount.toFixed(2)}</p>`;
        passwordInput.value = '';
        
        const cleanupAndResolve = () => {
            modal.classList.remove('visible');
            passwordInput.removeEventListener('keypress', keypressHandler);
            resolve();
        };

        const cleanupAndReject = (err) => {
            modal.classList.remove('visible');
            passwordInput.removeEventListener('keypress', keypressHandler);
            reject(err);
        };

        const confirmHandler = () => {
            if (passwordInput.value === db.wallet.password) {
                addTransaction('expense', amount, description);
                cleanupAndResolve();
            } else {
                showToast('æ”¯ä»˜å¯†ç é”™è¯¯');
                passwordInput.value = '';
            }
        };
        
        const keypressHandler = (e) => {
            if(e.key === 'Enter') {
                confirmHandler();
            }
        };

        newConfirmBtn.addEventListener('click', confirmHandler);
        newCancelBtn.addEventListener('click', () => cleanupAndReject(new Error('æ”¯ä»˜å·²å–æ¶ˆ')));
        passwordInput.addEventListener('keypress', keypressHandler);

        modal.classList.add('visible');
        setTimeout(() => passwordInput.focus(), 100);
    });
}
// --- æ¸²æŸ“äº¤æ˜“æ˜ç»† ---
function renderTransactionDetails() {
    const container = document.getElementById('transaction-list-container');
    container.innerHTML = '';

    if (!db.wallet.transactions || db.wallet.transactions.length === 0) {
        container.innerHTML = '<li class="placeholder-text" style="padding: 20px 0;">æš‚æ— æ˜ç»†</li>';
        return;
    }

    db.wallet.transactions.forEach(tx => {
        const li = document.createElement('li');
        li.className = 'transaction-item';

        const date = new Date(tx.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        const amountSign = tx.type === 'income' ? '+' : '-';
        
        li.innerHTML = `
            <div class="transaction-details">
                <span class="transaction-description">${tx.description}</span>
                <span class="transaction-timestamp">${dateString}</span>
            </div>
            <span class="transaction-amount ${tx.type}">
                ${amountSign}${tx.amount.toFixed(2)}
            </span>
        `;
        container.appendChild(li);
    });
}

// --- è®¾ç½®é’±åŒ…æ‰€æœ‰åŠŸèƒ½çš„äº‹ä»¶ç›‘å¬ ---
function setupWalletApp() {
    // ç¼“å­˜DOMå…ƒç´ 
    const walletScreen = document.getElementById('wallet-screen');
    const balanceDisplay = document.getElementById('wallet-balance-display');
    const settingsBtn = document.getElementById('wallet-settings-btn');
    const settingsScreen = document.getElementById('wallet-settings-screen');
    const settingsForm = document.getElementById('wallet-settings-form');
    const balanceInput = document.getElementById('wallet-balance-input');
    const passwordInput = document.getElementById('wallet-password-input');
    const transactionsBtn = document.getElementById('show-transactions-btn');
    const transactionsModal = document.getElementById('transaction-details-modal');
    const closeTransactionsBtn = document.getElementById('close-transactions-btn');

    // ç›‘å¬å¯¼èˆªåˆ°åº•éƒ¨â€œæˆ‘â€æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
    document.querySelector('.nav-btn[data-target="wallet-screen"]').addEventListener('click', () => {
        balanceDisplay.textContent = db.wallet.balance.toFixed(2);
    });
    
// ä»é’±åŒ…ä¸»é¡µè·³è½¬åˆ°è®¾ç½®é¡µ
settingsBtn.addEventListener('click', () => {
    const passwordEnabledToggle = document.getElementById('wallet-password-enabled-toggle');
    
    balanceInput.value = db.wallet.balance;
    passwordInput.value = db.wallet.password || '';
    passwordEnabledToggle.checked = db.wallet.passwordEnabled;
    passwordInput.disabled = !db.wallet.passwordEnabled; // æ ¹æ®å¼€å…³çŠ¶æ€ç¦ç”¨/å¯ç”¨è¾“å…¥æ¡†
    
    // ç›‘å¬å¼€å…³çš„å®æ—¶å˜åŒ–
    passwordEnabledToggle.onchange = (event) => {
        passwordInput.disabled = !event.target.checked;
        if (!event.target.checked) {
            passwordInput.value = ''; // å¦‚æœç¦ç”¨ï¼Œæ¸…ç©ºå¯†ç æ¡†
        }
    };
    
    switchScreen('wallet-settings-screen');
});

// ä¿å­˜è®¾ç½®
settingsForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const newBalance = parseFloat(balanceInput.value);
    const newPassword = passwordInput.value;
    const passwordEnabled = document.getElementById('wallet-password-enabled-toggle').checked;

    if (passwordEnabled && newPassword && (newPassword.length !== 6 || !/^\d+$/.test(newPassword))) {
        showToast('æ”¯ä»˜å¯†ç å¿…é¡»ä¸º6ä½æ•°å­—ï¼');
        return;
    }

    db.wallet.balance = isNaN(newBalance) ? 0 : parseFloat(newBalance.toFixed(2));
    db.wallet.passwordEnabled = passwordEnabled;

    if (passwordEnabled) {
        db.wallet.password = newPassword || null;
    } else {
        db.wallet.password = null; // ç¦ç”¨å¯†ç æ—¶ï¼Œè‡ªåŠ¨æ¸…é™¤å·²ä¿å­˜çš„å¯†ç 
    }

    await saveData();
    showToast('æ”¯ä»˜è®¾ç½®å·²ä¿å­˜ï¼');
    switchScreen('wallet-screen');
    balanceDisplay.textContent = db.wallet.balance.toFixed(2);
});
    
    // æ‰“å¼€äº¤æ˜“æ˜ç»†
    transactionsBtn.addEventListener('click', () => {
        renderTransactionDetails();
        transactionsModal.classList.add('visible');
    });

    // å…³é—­äº¤æ˜“æ˜ç»†
    closeTransactionsBtn.addEventListener('click', () => {
        transactionsModal.classList.remove('visible');
    });
}
// START: æ‰¹é‡æ·»åŠ è¡¨æƒ…åŒ…åŠŸèƒ½
function setupBatchStickerUpload() {
    const modal = document.getElementById('batch-add-sticker-modal');
    const uploadView = document.getElementById('batch-upload-view');
    const namingView = document.getElementById('batch-naming-view');

    const fileInput = document.getElementById('batch-sticker-files-upload');
    const urlInput = document.getElementById('batch-sticker-urls-input');
    const groupInput = document.getElementById('batch-sticker-group-input'); // ğŸ†• åˆ†ç»„è¾“å…¥æ¡†
    const processBtn = document.getElementById('process-batch-stickers-btn');
    
    const previewGrid = document.getElementById('batch-sticker-preview-grid');
    const namesInput = document.getElementById('batch-sticker-names-input');
    const saveBtn = document.getElementById('save-batch-stickers-btn');
    const backBtn = document.getElementById('back-to-batch-upload-btn');
    
    // ğŸ›¡ï¸ å®‰å…¨æ£€æŸ¥
    if (!modal || !uploadView || !namingView || !processBtn || !saveBtn || !backBtn) {
        console.warn('âš ï¸ setupBatchStickerUpload: æ‰¹é‡å¯¼å…¥ç›¸å…³å…ƒç´ æœªå®Œå…¨åŠ è½½');
        return;
    }
    
    let tempStickerData = []; // ç”¨äºå­˜å‚¨å¾…ä¿å­˜çš„ base64 æ•°æ®

    const resetModal = () => {
        if (uploadView) uploadView.style.display = 'block';
        if (namingView) namingView.style.display = 'none';
        if (fileInput) fileInput.value = '';
        if (urlInput) urlInput.value = '';
        if (namesInput) namesInput.value = '';
        if (groupInput) groupInput.value = ''; // ğŸ†• é‡ç½®åˆ†ç»„è¾“å…¥
        if (previewGrid) previewGrid.innerHTML = '';
        tempStickerData = [];
    };

    // ç‚¹å‡»é®ç½©å…³é—­å¼¹çª—
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.classList.remove('visible');
            resetModal();
        }
    });

    // è¿”å›ä¸Šä¸€æ­¥
    backBtn.addEventListener('click', () => {
        resetModal();
    });

    // ğŸ”¥ æ ¸å¿ƒï¼šå¤„ç†"ä¸‹ä¸€æ­¥"æŒ‰é’®ç‚¹å‡»
    processBtn.addEventListener('click', async () => {
        console.log('ğŸ”µ [æ‰¹é‡å¯¼å…¥] ç‚¹å‡»äº†"ä¸‹ä¸€æ­¥"æŒ‰é’®');
        
        if (!fileInput || !urlInput) {
            console.error('âŒ [æ‰¹é‡å¯¼å…¥] è¾“å…¥å…ƒç´ æœªæ‰¾åˆ°');
            showToast('ç³»ç»Ÿé”™è¯¯ï¼šè¾“å…¥å…ƒç´ æœªåŠ è½½');
            return;
        }
        
        const files = fileInput.files ? Array.from(fileInput.files) : [];
        const urls = urlInput.value ? urlInput.value.split(',').map(u => u.trim()).filter(Boolean) : [];

        console.log(`ğŸ”µ [æ‰¹é‡å¯¼å…¥] æ–‡ä»¶æ•°é‡: ${files.length}, URLæ•°é‡: ${urls.length}`);

        if (files.length === 0 && urls.length === 0) {
            showToast('è¯·é€‰æ‹©æ–‡ä»¶æˆ–è¾“å…¥URL');
            return;
        }

        showToast('æ­£åœ¨å¤„ç†å›¾ç‰‡ï¼Œè¯·ç¨å€™...');
        if (previewGrid) previewGrid.innerHTML = '<div class="placeholder-text">å¤„ç†ä¸­...</div>';
        if (uploadView) uploadView.style.display = 'none';
        if (namingView) namingView.style.display = 'block';

        const promises = [];
        tempStickerData = [];

        // å¤„ç†æœ¬åœ°æ–‡ä»¶
        files.forEach(file => {
            promises.push(
                compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 })
                    .then(dataUrl => {
                        tempStickerData.push({ data: dataUrl });
                        console.log(`âœ… [æ‰¹é‡å¯¼å…¥] æ–‡ä»¶å¤„ç†æˆåŠŸ: ${file.name}`);
                    })
                    .catch(err => {
                        console.error(`âŒ [æ‰¹é‡å¯¼å…¥] æ–‡ä»¶å¤„ç†å¤±è´¥: ${file.name}`, err);
                    })
            );
        });
        
        // å¤„ç†URL
        urls.forEach(url => {
            // å¯¹äºURLï¼Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨ï¼Œä¸è¿›è¡Œå‹ç¼©
            tempStickerData.push({ data: url });
            console.log(`âœ… [æ‰¹é‡å¯¼å…¥] URLæ·»åŠ æˆåŠŸ: ${url}`);
        });
        
        try {
            await Promise.all(promises);
            console.log(`ğŸ”µ [æ‰¹é‡å¯¼å…¥] æ‰€æœ‰å›¾ç‰‡å¤„ç†å®Œæˆï¼Œå…± ${tempStickerData.length} å¼ `);

            // æ¸²æŸ“é¢„è§ˆ
            if (previewGrid) {
                previewGrid.innerHTML = '';
                tempStickerData.forEach((sticker, index) => {
                    const item = document.createElement('div');
                    item.className = 'sticker-item';
                    item.innerHTML = `<img src="${sticker.data}" alt="é¢„è§ˆ${index+1}">`;
                    previewGrid.appendChild(item);
                });
            }
            
            showToast(`å·²æˆåŠŸåŠ è½½ ${tempStickerData.length} å¼ å›¾ç‰‡ï¼Œè¯·ä¸ºå®ƒä»¬å‘½åã€‚`);
        } catch (error) {
            console.error('âŒ [æ‰¹é‡å¯¼å…¥] å¤„ç†å›¾ç‰‡æ—¶å‡ºé”™:', error);
            showToast('å¤„ç†å›¾ç‰‡æ—¶å‡ºé”™ï¼Œè¯·é‡è¯•');
            resetModal();
        }
    });
    
    // ä¿å­˜æŒ‰é’®
    saveBtn.addEventListener('click', async () => {
        console.log('ğŸ”µ [æ‰¹é‡å¯¼å…¥] ç‚¹å‡»äº†"ä¿å­˜"æŒ‰é’®');
        
        if (tempStickerData.length === 0) {
            showToast('æ²¡æœ‰å¯ä¿å­˜çš„è¡¨æƒ…åŒ…');
            return;
        }

        const names = namesInput ? namesInput.value.split(',').map(n => n.trim()) : [];
        const groupName = groupInput ? groupInput.value.trim() : null; // ğŸ†• è·å–åˆ†ç»„åç§°
        
        console.log(`ğŸ”µ [æ‰¹é‡å¯¼å…¥] åˆ†ç»„åç§°: "${groupName || 'æœªåˆ†ç±»'}"`);
        
        tempStickerData.forEach((sticker, index) => {
            const newSticker = {
                id: `sticker_${Date.now()}_${index}`,
                name: names[index] || `è¡¨æƒ…åŒ…${db.myStickers.length + index + 1}`,
                data: sticker.data,
                group: groupName || null, // ğŸ†• ä¿å­˜åˆ†ç»„
                lastUsedTime: Date.now() // ğŸ†• è®°å½•æ—¶é—´
            };
            db.myStickers.push(newSticker);
        });

        await saveData();
        modal.classList.remove('visible');
        resetModal();
        
        // ğŸ†• å¦‚æœè¡¨æƒ…åŒ…å¼¹çª—æ˜¯æ‰“å¼€çš„ï¼Œé‡æ–°æ¸²æŸ“
        const stickerModalElement = document.getElementById('sticker-modal');
        if (stickerModalElement && stickerModalElement.classList.contains('visible')) {
            renderStickerTabs();
            renderStickerGrid();
        }
        
        console.log(`âœ… [æ‰¹é‡å¯¼å…¥] æˆåŠŸæ·»åŠ  ${tempStickerData.length} ä¸ªè¡¨æƒ…åŒ…åˆ°åˆ†ç»„ "${groupName || 'æœªåˆ†ç±»'}"`);
        showToast(`æˆåŠŸæ·»åŠ äº† ${tempStickerData.length} ä¸ªè¡¨æƒ…åŒ…ï¼`);
    });
}
// 
// ===============================================================
// START: å¿ƒçµç¾ç»Š - ç•ªèŒ„é’Ÿ V2.1 åŠŸèƒ½ (æ›¿æ¢æ—§ç‰ˆ)
// ===============================================================
function setupPomodoroFeature() {
    // --- DOM å…ƒç´ ç¼“å­˜ ---
    const pomodoroScreen = document.getElementById('pomodoro-screen');
    const timeDisplayEl = document.getElementById('pomodoro-main-time');
    const taskNameEl = document.getElementById('pomodoro-task-name');
    const aiAvatarEl = document.getElementById('pomodoro-ai-avatar');
    const aiStatusEl = document.getElementById('pomodoro-ai-status');
    const aiCompanionTextEl = document.getElementById('pomodoro-ai-companion-text');
    const startBtn = document.getElementById('pomodoro-start-btn');
    const alertSound = document.getElementById('pomodoro-alert-sound');
    const timerCardEl = document.querySelector('.pomodoro-timer-card');

    const settingsBtn = document.getElementById('pomodoro-open-settings-btn');
    const historyBtn = document.getElementById('pomodoro-history-btn');
    const settingsScreen = document.getElementById('pomodoro-settings-screen');
    const settingsForm = document.getElementById('pomodoro-settings-form-v2');

    // --- çŠ¶æ€å˜é‡ ---
    let timerInterval = null;
    let timeValue = 0;
    let remainingTime = 25 * 60;
    let state = 'idle'; // 'idle', 'running', 'paused'
    let currentMode = 'countdown';
    let currentAiForApp = null;

    // --- è¾…åŠ©å‡½æ•° ---
    const getSettings = () => {
        if (currentAiForApp && currentAiForApp.soulBondData && currentAiForApp.soulBondData.pomodoroSettings) {
            return currentAiForApp.soulBondData.pomodoroSettings;
        }
        return { wallpaper: '', avatar: '', soundUrl: '', cardWallpaper: '', mode: 'countdown', focus: 25, shortBreak: 5 };
    };

    const updateDisplay = () => {
        const time = (currentMode === 'countdown') ? remainingTime : timeValue;
        const minutes = String(Math.floor(time / 60)).padStart(2, '0');
        const seconds = String(time % 60).padStart(2, '0');
        timeDisplayEl.textContent = `${minutes}:${seconds}`;
        document.title = `${minutes}:${seconds} - ä¸“æ³¨æ¨¡å¼`;
    };

    const applySettings = () => {
        const settings = getSettings();
        const contentArea = pomodoroScreen.querySelector('.pomodoro-main-content');
        
        contentArea.style.backgroundImage = settings.wallpaper ? `url('${settings.wallpaper}')` : '';
        timerCardEl.style.backgroundImage = settings.cardWallpaper ? `url('${settings.cardWallpaper}')` : '';
        aiAvatarEl.src = settings.avatar || (currentAiForApp ? currentAiForApp.avatar : 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg');
        
        currentMode = settings.mode;
        resetTimer();
    };

    const tick = () => {
        if (currentMode === 'countdown') {
            remainingTime--;
            if (remainingTime < 0) {
                clearInterval(timerInterval);
                state = 'idle';
                startBtn.textContent = 'ä¼‘æ¯ä¸€ä¸‹';
                alertSound.play();
                saveTaskToHistory();
                triggerAiInteraction('end_focus');
                
                // Switch to break
                currentMode = 'break';
                remainingTime = getSettings().shortBreak * 60;
                aiStatusEl.textContent = `${currentAiForApp.remarkName} é™ªä½ ä¼‘æ¯ä¸­...`;
                aiCompanionTextEl.textContent = "è¾›è‹¦å•¦ï¼ä¼‘æ¯ä¸€ä¸‹å§ï¼Œä½ åšå¾—éå¸¸æ£’ï¼";
                startTimer();
                return;
            }
        } else {
            timeValue++;
        }
        updateDisplay();
    };
    
    // --- æ ¸å¿ƒäº¤äº’å‡½æ•° ---
    const startTimer = () => {
        if (state === 'idle' && currentMode === 'countdown') {
            triggerAiInteraction('start_focus');
        }
        state = 'running';
        startBtn.textContent = 'æš‚åœ';
        timerInterval = setInterval(tick, 1000);
    };

    const pauseTimer = () => {
        clearInterval(timerInterval);
        state = 'paused';
        startBtn.textContent = 'ç»§ç»­';
    };

    const resetTimer = () => {
        clearInterval(timerInterval);
        state = 'idle';
        startBtn.textContent = 'å¼€å§‹';
        if (currentMode === 'countdown') {
            remainingTime = getSettings().focus * 60;
        } else {
            timeValue = 0;
        }
        updateDisplay();
    };

    const triggerAiInteraction = async (moment) => {
        const character = currentAiForApp;
        if (!character) return;
        
        let systemContent = '';
        switch (moment) {
            case 'start_focus':
                systemContent = `[system: æˆ‘åˆšåˆšå¼€å§‹äº†${getSettings().focus}åˆ†é’Ÿçš„ä¸“æ³¨æ—¶é—´ï¼Œä»»åŠ¡æ˜¯â€œ${taskNameEl.textContent}â€ã€‚è¯·ä½ ç”¨ä¸€å¥ç®€çŸ­çš„è¯ä¸ºæˆ‘åŠ æ²¹æ‰“æ°”ï¼Œç„¶åä¿æŒå®‰é™ã€‚]`;
                break;
            case 'end_focus':
                systemContent = `[system: æˆ‘åˆšåˆšå®Œæˆäº†ä¸€ä¸ªä¸“æ³¨ç•ªèŒ„é’Ÿï¼è¯·ä½ è¡¨æ‰¬æˆ‘ï¼Œå¹¶æé†’æˆ‘å¯ä»¥ä¼‘æ¯ä¸€ä¸‹äº†ã€‚]`;
                break;
        }

        if (!systemContent) return;

        const contextMessage = { id: `msg_pomodoro_${moment}_${Date.now()}`, role: 'user', content: systemContent, parts: [{ type: 'text', text: systemContent }], timestamp: Date.now() };
        character.history.push(contextMessage);
        await saveData();

        if (currentChatId === character.id) {
            getAiReply();
        } else {
            addNotificationToQueue({ avatar: character.avatar, text: `<strong>${character.remarkName}</strong><br>ç»™ä½ å‘æ¥äº†ä¸“æ³¨æé†’`, chatId: character.id, type: 'private' });
        }
    };
    
    async function requestAiCompanionMessage() {
        const character = currentAiForApp;
        if (!character) return;
        
        aiCompanionTextEl.textContent = '...';
        aiStatusEl.textContent = `${character.remarkName} æ­£åœ¨è¾“å…¥...`;
        
        try {
            const prompt = `[system: æˆ‘åœ¨ä¸“æ³¨æœŸé—´æœ‰ç‚¹åˆ†å¿ƒï¼Œç‚¹å‡»äº†ä½ çš„å¤´åƒã€‚è¯·æ ¹æ®ä½ çš„äººè®¾â€œ${character.persona}â€ï¼Œè¯´ä¸€å¥ç®€çŸ­ã€æ¸©æŸ”æˆ–ä¿çš®çš„è¯æ¥é¼“åŠ±æˆ‘ç»§ç»­åšæŒä¸‹å»ã€‚ç›´æ¥è¾“å‡ºé¼“åŠ±çš„è¯ï¼Œä¸è¦æœ‰å…¶ä»–å‰ç¼€ã€‚]`;
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            aiCompanionTextEl.textContent = aiResponseText;
            aiStatusEl.textContent = `${character.remarkName} é™ªä¼´ä¸­...`;
        } catch(e) {
             aiCompanionTextEl.textContent = "åŠ æ²¹ï¼";
             aiStatusEl.textContent = `${character.remarkName} é™ªä¼´ä¸­...`;
        }
    }
    
    const saveTaskToHistory = async () => {
        const character = currentAiForApp;
        if (!character) return;
        character.soulBondData = character.soulBondData || {};
        character.soulBondData.pomodoroHistory = character.soulBondData.pomodoroHistory || [];
        character.soulBondData.pomodoroHistory.unshift({
            task: taskNameEl.textContent,
            duration: currentMode === 'countdown' ? getSettings().focus : Math.floor(timeValue / 60),
            timestamp: Date.now()
        });
        await saveData();
    };

    // --- äº‹ä»¶ç»‘å®š ---
    document.querySelector('.bond-nav-btn[data-feature="pomodoro"]').addEventListener('click', () => {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        pomodoroScreen.dataset.characterId = characterId;
        currentAiForApp = db.characters.find(c => c.id === characterId);
        
        applySettings();
        switchScreen('pomodoro-screen');
    });

    startBtn.addEventListener('click', () => {
        if (state === 'running') {
            pauseTimer();
        } else if (state === 'paused') {
            startTimer();
        } else { // idle
            if (currentMode === 'break') { // If break is over, start new focus
                switchMode('countdown');
            }
            startTimer();
        }
    });
    
    aiAvatarEl.addEventListener('click', () => {
        const settings = getSettings();
        if (settings.soundUrl) {
            try {
                const customSound = new Audio(settings.soundUrl);
                customSound.play();
            } catch(e) {
                console.error("æ— æ³•æ’­æ”¾è‡ªå®šä¹‰å£°éŸ³:", e);
                showToast("æç¤ºéŸ³é“¾æ¥æ— æ•ˆ");
            }
        }
        requestAiCompanionMessage();
    });
    
    settingsBtn.addEventListener('click', () => {
        const settings = getSettings();
        document.getElementById('pomodoro-wallpaper-input').value = settings.wallpaper || '';
        document.getElementById('pomodoro-avatar-input').value = settings.avatar || '';
        document.getElementById('pomodoro-sound-url-input').value = settings.soundUrl || '';
        document.getElementById('pomodoro-card-wallpaper-input').value = settings.cardWallpaper || '';
        const modeRadio = document.querySelector(`input[name="timer-mode"][value="${settings.mode}"]`);
        if (modeRadio) modeRadio.checked = true;
        document.getElementById('focus-duration-input').value = settings.focus;
        document.getElementById('short-break-duration-input').value = settings.shortBreak;
        switchScreen('pomodoro-settings-screen');
    });

    historyBtn.addEventListener('click', () => {
        const history = currentAiForApp.soulBondData.pomodoroHistory || [];
        const listEl = document.getElementById('pomodoro-history-list');
        const placeholder = document.getElementById('no-pomodoro-history');
        if(history.length === 0){
            listEl.innerHTML = '';
            placeholder.style.display = 'block';
        } else {
            placeholder.style.display = 'none';
            listEl.innerHTML = history.map(item => `
                <li class="list-item">
                    <div class="item-details">
                        <div class="item-name">${item.task}</div>
                        <div class="item-preview">${new Date(item.timestamp).toLocaleDateString()}</div>
                    </div>
                    <span class="item-preview">${item.duration} åˆ†é’Ÿ</span>
                </li>
            `).join('');
        }
        switchScreen('pomodoro-history-screen');
    });

    settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const character = currentAiForApp;
        if (!character) return;

        character.soulBondData = character.soulBondData || {};
        character.soulBondData.pomodoroSettings = {
            wallpaper: document.getElementById('pomodoro-wallpaper-input').value,
            avatar: document.getElementById('pomodoro-avatar-input').value,
            soundUrl: document.getElementById('pomodoro-sound-url-input').value,
            cardWallpaper: document.getElementById('pomodoro-card-wallpaper-input').value,
            mode: document.querySelector('input[name="timer-mode"]:checked').value,
            focus: parseInt(document.getElementById('focus-duration-input').value),
            shortBreak: parseInt(document.getElementById('short-break-duration-input').value)
        };
        
        await saveData();
        switchScreen('pomodoro-screen');
        applySettings(); // ä¿å­˜åç«‹å³åº”ç”¨æ–°è®¾ç½®
        showToast('ä¸“æ³¨è®¾ç½®å·²ä¿å­˜');
    });
}
// ===============================================================
// END: å¿ƒçµç¾ç»Š - ç•ªèŒ„é’Ÿ V2.1 åŠŸèƒ½
// ===============================================================
    
    
// ===============================================================
// END: å¿ƒçµç¾ç»Š - ç•ªèŒ„é’Ÿ V2.0 åŠŸèƒ½
// ===============================================================
// END: æ‰¹é‡æ·»åŠ è¡¨æƒ…åŒ…åŠŸèƒ½
// ===============================================================
// END: é’±åŒ…åŠŸèƒ½æ ¸å¿ƒä»£ç 
// ===============================================================
/**
 * è¾…åŠ©å‡½æ•°ï¼šåœ¨æ‰€æœ‰è§’è‰²ä¸­æŸ¥æ‰¾å·²ç»‘å®šçš„å¿ƒåŠ¨å¯¹è±¡
 * @returns {object|null} - è¿”å›ç»‘å®šçš„è§’è‰²å¯¹è±¡ï¼Œå¦‚æœæ²¡æ‰¾åˆ°åˆ™è¿”å› null
 */
function findBoundCharacter() {
    if (!db || !db.characters) return null;
    return db.characters.find(c => c.isSoulBound === true);
}

/**
 * ç®¡ç†ä¼´ä¾£åå†Œï¼ˆæœ€å¤š2ä¸ªè§’è‰²IDï¼‰
 * @param {string} charId - è§’è‰²ID
 * @param {string} action - æ“ä½œç±»å‹ï¼š'add' | 'remove' | 'get'
 * @returns {Array<string>} - è¿”å›å½“å‰çš„IDæ•°ç»„ï¼ˆactionä¸º'get'æ—¶ï¼‰
 */
function updateBondRoster(charId, action) {
    const ROSTER_KEY = 'soul_bond_roster';
    
    try {
        let roster = JSON.parse(localStorage.getItem(ROSTER_KEY) || '[]');
        
        if (action === 'add') {
            // å¦‚æœè§’è‰²IDä¸åœ¨åˆ—è¡¨ä¸­
            if (!roster.includes(charId)) {
                if (roster.length < 2) {
                    // åå†Œæœªæ»¡ï¼Œç›´æ¥æ·»åŠ 
                    roster.push(charId);
                } else {
                    // åå†Œå·²æ»¡ï¼ˆ2ä¸ªè§’è‰²ï¼‰ï¼Œä¿æŒåå†Œä¸å˜ï¼ˆæœ€å¤š2ä¸ªï¼‰
                    // æ³¨æ„ï¼šè°ƒç”¨æ–¹éœ€è¦è‡ªå·±å¤„ç†æ¿€æ´»/ä¼‘çœ é€»è¾‘
                    console.log('ä¼´ä¾£åå†Œå·²æ»¡ï¼ˆæœ€å¤š2ä¸ªè§’è‰²ï¼‰ï¼Œä¿æŒåå†Œä¸å˜');
                }
            }
            // å¦‚æœè§’è‰²IDå·²åœ¨åˆ—è¡¨ä¸­ï¼Œä¸åšä»»ä½•æ“ä½œ
            localStorage.setItem(ROSTER_KEY, JSON.stringify(roster));
            return roster;
        } else if (action === 'remove') {
            // ä»åˆ—è¡¨ä¸­ç§»é™¤è§’è‰²ID
            roster = roster.filter(id => id !== charId);
            localStorage.setItem(ROSTER_KEY, JSON.stringify(roster));
            return roster;
        } else if (action === 'get') {
            // è¿”å›å½“å‰çš„IDæ•°ç»„
            return roster;
        }
        
        return roster;
    } catch (error) {
        console.error('æ›´æ–°ä¼´ä¾£åå†Œæ—¶å‡ºé”™:', error);
        return [];
    }
}
// â–¼â–¼â–¼ åœ¨ init() å‡½æ•°çš„æ­£ä¸Šæ–¹ï¼Œç²˜è´´ä¸‹é¢è¿™ä¸ªå®Œæ•´çš„æ–°å‡½æ•° â–¼â–¼â–¼
/**
 * å¤„ç†ç»­å†™æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ï¼Œå‘AIè¯·æ±‚ç»§ç»­ç”Ÿæˆå†…å®¹ã€‚
 */
async function handleContinueWriting() {
    if (isGenerating) return; // å¦‚æœAIæ­£åœ¨ç”Ÿæˆï¼Œåˆ™å¿½ç•¥ç‚¹å‡»

    const chat = (currentChatType === 'private')
        ? db.characters.find(c => c.id === currentChatId)
        : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;

    // ä»åå¾€å‰æŸ¥æ‰¾AIçš„æœ€åä¸€æ¡æ¶ˆæ¯
    const lastAiMessage = [...chat.history].reverse().find(m => m.role === 'assistant');

    if (!lastAiMessage) {
        showToast('æ²¡æœ‰å¯ç»­å†™çš„AIå›å¤ã€‚');
        return;
    }

    // æ„å»ºä¸€æ¡ä¸´æ—¶çš„ã€ç”¨äºæŒ‡å¯¼AIç»­å†™çš„ç³»ç»ŸæŒ‡ä»¤
    const continuationPrompt = `[system: è¯·ç›´æ¥ç»­å†™ä½ ä¸Šä¸€æ¡çš„å›å¤å†…å®¹ï¼Œä¸è¦é‡å¤å·²ç»è¯´è¿‡çš„è¯ï¼Œä¹Ÿä¸è¦è¯´ä»»ä½•â€œå¥½çš„ï¼Œè¿™æ˜¯ç»­å†™ï¼šâ€ä¹‹ç±»çš„å¼€åœºç™½ã€‚ä½ çš„ä¸Šä¸€æ¡å›å¤æ˜¯ï¼šâ€œ${lastAiMessage.content}â€]`;
    
    const promptMessage = {
        role: 'user', // ä¼ªè£…æˆç”¨æˆ·æŒ‡ä»¤
        content: continuationPrompt,
        parts: [{ type: 'text', text: continuationPrompt }],
        id: `temp_prompt_${Date.now()}`, // ä¸´æ—¶IDï¼Œç”¨äºåç»­åˆ é™¤
        timestamp: Date.now()
    };
     if (currentChatType === 'group') {
        promptMessage.senderId = 'user_me';
    }

    // å°†è¿™æ¡ä¸´æ—¶æŒ‡ä»¤åŠ å…¥å†å²è®°å½•çš„æœ«å°¾
    chat.history.push(promptMessage);

    try {
        // ç›´æ¥è°ƒç”¨ç°æœ‰çš„ getAiReply å‡½æ•°ï¼Œå®ƒä¼šè‡ªåŠ¨è¯»å–åŒ…å«æˆ‘ä»¬ä¸´æ—¶æŒ‡ä»¤çš„æœ€æ–°å†å²è®°å½•
        await getAiReply();
    } finally {
        // è¯·æ±‚å®Œæˆåï¼Œæ— è®ºæˆåŠŸä¸å¦ï¼Œéƒ½ä»å†å²è®°å½•ä¸­ç§»é™¤æˆ‘ä»¬æ·»åŠ çš„ä¸´æ—¶æŒ‡ä»¤
        const index = chat.history.findIndex(m => m.id === promptMessage.id);
        if (index > -1) {
            chat.history.splice(index, 1);
        }
        // ä¿å­˜è¢«æ¸…ç†è¿‡çš„ã€æœ€ç»ˆçš„å†å²è®°å½•
        await saveData();
    }
}

/**
 * ä¸ºç»­å†™åŠŸèƒ½æŒ‰é’®ç»‘å®šäº‹ä»¶ç›‘å¬å™¨ã€‚
 */
function setupContinueWritingFeature() {
    const continueBtn = document.getElementById('continue-writing-btn');
    if (continueBtn) {
        continueBtn.addEventListener('click', handleContinueWriting);
    }
}
function setupRollbackFeature() {
    const rollbackBtn = document.getElementById('rollback-btn');
    if (!rollbackBtn) return; // å®‰å…¨æ£€æŸ¥ï¼Œç¡®ä¿æŒ‰é’®å­˜åœ¨

    // ä¸ºâ€œæ’¤å›å¹¶é‡å†™â€æŒ‰é’®ç»‘å®šæ ¸å¿ƒçš„ç‚¹å‡»äº‹ä»¶
    rollbackBtn.addEventListener('click', async () => {
        // å¦‚æœAIæ­£åœ¨ç”Ÿæˆä¸­ï¼Œåˆ™é˜»æ­¢æ“ä½œ
        if (isGenerating) {
           // showToast('AIæ­£åœ¨æ€è€ƒä¸­ï¼Œè¯·ç¨åå†è¯•...');
            return;
        }

        // è·å–å½“å‰çš„èŠå¤©å¯¹è±¡
        const chat = (currentChatType === 'private') 
            ? db.characters.find(c => c.id === currentChatId) 
            : db.groups.find(g => g.id === currentChatId);
            
        if (!chat || chat.history.length === 0) return;

        // 1. ä»åå¾€å‰æŸ¥æ‰¾ï¼Œå®šä½åˆ°æœ€åä¸€ä¸ªã€ç”¨æˆ·ã€‘æ¶ˆæ¯çš„ä½ç½®
        let lastUserMessageIndex = -1;
        for (let i = chat.history.length - 1; i >= 0; i--) {
            if (chat.history[i].role === 'user') {
                lastUserMessageIndex = i;
                break;
            }
        }

        // å¦‚æœæ‰¾ä¸åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼Œæˆ–è€…æœ€åä¸€æ¡æ¶ˆæ¯å·²ç»æ˜¯ç”¨æˆ·æ¶ˆæ¯ï¼Œåˆ™è¯´æ˜æ²¡æœ‰å¯æ’¤å›çš„AIå›å¤
        if (lastUserMessageIndex === -1 || lastUserMessageIndex === chat.history.length - 1) {
            showToast('æ‰¾ä¸åˆ°å¯ä»¥é‡æ–°ç”Ÿæˆçš„AIå›å¤ã€‚');
            return;
        }

        // 2. åˆ é™¤ä»æœ€åä¸€ä¸ªç”¨æˆ·æ¶ˆæ¯ä¹‹åçš„æ‰€æœ‰AIæ¶ˆæ¯
        chat.history.splice(lastUserMessageIndex + 1);
        
        // 3. æ›´æ–°ç•Œé¢æ˜¾ç¤ºï¼Œå¹¶ä¿å­˜æ•°æ®
        renderMessages(false, true); // é‡æ–°æ¸²æŸ“èŠå¤©æ°”æ³¡ï¼Œå¹¶æ»šåŠ¨åˆ°åº•éƒ¨
        await saveData();
        renderChatList(); // æ›´æ–°å·¦ä¾§åˆ—è¡¨çš„æœ€åæ¶ˆæ¯é¢„è§ˆ
        
        // 4. å†æ¬¡è°ƒç”¨AIï¼Œç”Ÿæˆæ–°çš„å›å¤
        getAiReply();
    });
}

// ===============================================================
// START: æ–°å¢å¤´åƒæ¡†åŠŸèƒ½æ ¸å¿ƒä»£ç 
// ===============================================================

let currentFrameTarget = null; // ç”¨äºè®°å½•å½“å‰æ­£åœ¨ä¸ºå“ªä¸ªå¤´åƒè®¾ç½®æ¡†
let currentEditingMemberId = null; // ç”¨äºè®°å½•æ­£åœ¨ç¼–è¾‘çš„ç¾¤æˆå‘˜ID

/**
 * æ¸²æŸ“å¹¶æ›´æ–°è®¾ç½®é¢æ¿ä¸­çš„å¤´åƒï¼ˆåŒ…æ‹¬å¤´åƒæ¡†ï¼‰
 * @param {string} containerId - å¤´åƒå®¹å™¨çš„ID
 * @param {string} avatarUrl - å¤´åƒå›¾ç‰‡URL
 * @param {string} frameUrl - å¤´åƒæ¡†å›¾ç‰‡URL
 */
function renderAvatarInSettings(containerId, avatarUrl, frameUrl) {
    const container = document.getElementById(containerId);
    if (container) {
        container.innerHTML = `
            <img src="${avatarUrl}" class="avatar-preview">
            ${frameUrl ? `<img src="${frameUrl}" class="avatar-frame">` : ''}
        `;
    }
}

/**
 * æ‰“å¼€å¤´åƒæ¡†é€‰æ‹©é¢æ¿
 * @param {string} target - åŒºåˆ†æ˜¯ä¸ºå“ªä¸ªè§’è‰²è®¾ç½® ('private-ai', 'private-user', etc.)
 */
function openAvatarFramePanel(target) {
    currentFrameTarget = target;
    renderAvatarFrameGrid();
    document.getElementById('avatar-frame-modal').classList.add('visible');
}

/**
 * æ¸²æŸ“å¤´åƒæ¡†é€‰æ‹©ç½‘æ ¼
 */
function renderAvatarFrameGrid() {
    const grid = document.getElementById('avatar-frame-grid');
    grid.innerHTML = '';
    if (db.avatarFrames.length === 0) {
        grid.innerHTML = '<p class="placeholder-text">è¿˜æ²¡æœ‰å¤´åƒæ¡†ï¼Œç‚¹å‡»å³ä¸Šè§’â€œ+â€æ·»åŠ ä¸€ä¸ªå§ï¼</p>';
        return;
    }
    db.avatarFrames.forEach(frame => {
        const item = document.createElement('div');
        item.className = 'frame-item';
        item.dataset.frameUrl = frame.url;
        item.innerHTML = `
            <img src="${frame.url}" alt="å¤´åƒæ¡†">
            <button class="delete-frame-btn" data-frame-id="${frame.id}">&times;</button>
        `;
        grid.appendChild(item);
    });
}

/**
 * åº”ç”¨é€‰æ‹©çš„å¤´åƒæ¡†
 */
async function applyAvatarFrame() {
    const selectedItem = document.querySelector('#avatar-frame-grid .frame-item.selected');
    const frameUrl = selectedItem ? selectedItem.dataset.frameUrl : null;

    let targetObject = null;
    let avatarContainerId = '';
    let avatarUrl = '';

    if (currentChatType === 'private') {
        const character = db.characters.find(c => c.id === currentChatId);
        if (currentFrameTarget === 'private-ai') {
            character.avatarFrameUrl = frameUrl;
            avatarContainerId = 'char-avatar-container-setting';
            avatarUrl = character.avatar;
        } else if (currentFrameTarget === 'private-user') {
            character.myAvatarFrameUrl = frameUrl;
            avatarContainerId = 'my-avatar-container-setting';
            avatarUrl = character.myAvatar;
        }
    } else if (currentChatType === 'group') {
        const group = db.groups.find(g => g.id === currentChatId);
        if (currentFrameTarget === 'group-user') {
            group.me.avatarFrameUrl = frameUrl;
            avatarContainerId = 'group-my-avatar-container-setting';
            avatarUrl = group.me.avatar;
        } else if (currentFrameTarget === 'group-member' && currentEditingMemberId) {
            const member = group.members.find(m => m.id === currentEditingMemberId);
            if (member) {
                member.avatarFrameUrl = frameUrl;
                avatarContainerId = 'group-member-avatar-container-setting';
                avatarUrl = member.avatar;
            }
        }
    }

    if (avatarContainerId) {
        renderAvatarInSettings(avatarContainerId, avatarUrl, frameUrl);
    }
    
    await saveData();
    renderMessages(false, true); // åˆ·æ–°èŠå¤©ç•Œé¢ä»¥æ˜¾ç¤ºæ–°å¤´åƒæ¡†
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    showToast('å¤´åƒæ¡†å·²åº”ç”¨ï¼');
}

/**
 * è®¾ç½®æ‰€æœ‰ä¸å¤´åƒæ¡†ç›¸å…³çš„äº‹ä»¶ç›‘å¬
 */
function setupAvatarFrameSystem() {
    const modal = document.getElementById('avatar-frame-modal');
    
    // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œç›‘å¬æ‰€æœ‰â€œæ˜Ÿæ˜Ÿâ€æŒ‰é’®çš„ç‚¹å‡»
    document.body.addEventListener('click', e => {
        const btn = e.target.closest('.avatar-frame-btn');
        if (btn) {
            // å¦‚æœæ˜¯ç¾¤æˆå‘˜ç¼–è¾‘ï¼Œéœ€è¦å…ˆè®°å½•å½“å‰æ­£åœ¨ç¼–è¾‘çš„æˆå‘˜ID
            if(btn.dataset.target === 'group-member') {
                currentEditingMemberId = document.getElementById('editing-member-id').value;
            }
            openAvatarFramePanel(btn.dataset.target);
        }
    });

    // æ·»åŠ æ–°å¤´åƒæ¡†
    document.getElementById('add-avatar-frame-btn').addEventListener('click', async () => {
        const url = prompt('è¯·è¾“å…¥å¤´åƒæ¡†å›¾ç‰‡çš„URLï¼š');
        if (url && url.trim()) {
            db.avatarFrames.push({
                id: `frame_${Date.now()}`,
                url: url.trim()
            });
            await saveData();
            renderAvatarFrameGrid();
        }
    });

    // ç½‘æ ¼å†…çš„ç‚¹å‡»äº‹ä»¶ï¼ˆé€‰æ‹©/åˆ é™¤ï¼‰
    document.getElementById('avatar-frame-grid').addEventListener('click', e => {
        const target = e.target;
        if (target.closest('.delete-frame-btn')) {
            e.stopPropagation();
            const frameId = target.dataset.frameId;
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¤´åƒæ¡†å—ï¼Ÿ')) {
                db.avatarFrames = db.avatarFrames.filter(f => f.id !== frameId);
                saveData();
                renderAvatarFrameGrid();
            }
        } else if (target.closest('.frame-item')) {
            document.querySelectorAll('#avatar-frame-grid .frame-item').forEach(el => el.classList.remove('selected'));
            target.closest('.frame-item').classList.add('selected');
        }
    });

    // é¢æ¿åº•éƒ¨æŒ‰é’®
    document.getElementById('apply-avatar-frame-btn').addEventListener('click', applyAvatarFrame);
    document.getElementById('cancel-avatar-frame-btn').addEventListener('click', () => modal.classList.remove('visible'));
    document.getElementById('remove-avatar-frame-btn').addEventListener('click', () => {
        // æ¸…é™¤é€‰ä¸­çŠ¶æ€å¹¶åº”ç”¨ï¼ˆç›¸å½“äºç§»é™¤äº†å¤´åƒæ¡†ï¼‰
        document.querySelectorAll('#avatar-frame-grid .frame-item').forEach(el => el.classList.remove('selected'));
        applyAvatarFrame();
    });
}

// ===============================================================
// END: æ–°å¢å¤´åƒæ¡†åŠŸèƒ½æ ¸å¿ƒä»£ç 
// ===============================================================
// --- æ–°å¢ï¼šç”¨äºæ§åˆ¶â€œæ­£åœ¨è¾“å…¥â€æç¤ºçš„è¾…åŠ©å‡½æ•° ---

/**
 * åœ¨èŠå¤©é¡¶éƒ¨æ˜¾ç¤ºâ€œå¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...â€çš„çŠ¶æ€
 */
function showTypingIndicator() {
    const subtitle = document.getElementById('chat-room-subtitle');
    const statusTextElement = document.getElementById('chat-room-status-text');

    if (subtitle && statusTextElement && currentChatType === 'private') {
        // éšè—ç»¿è‰²çš„åœ¨çº¿åœ†ç‚¹
        subtitle.querySelector('.online-indicator').style.display = 'none';
        // ä¿®æ”¹çŠ¶æ€æ–‡å­—
        statusTextElement.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...';
        // æ·»åŠ åŠ¨ç”»æ•ˆæœClass
        statusTextElement.classList.add('typing-status');
    }
    // æ—§çš„åº•éƒ¨æç¤ºå·²ä¸å†ä½¿ç”¨ï¼Œä½†ä¸ºç¡®ä¿å®‰å…¨ï¼Œå†æ¬¡å°†å…¶éšè—
    document.getElementById('typing-indicator').style.display = 'none';
}

/**
 * éšè—â€œæ­£åœ¨è¾“å…¥â€çš„çŠ¶æ€ï¼Œå¹¶æ¢å¤è§’è‰²çš„åœ¨çº¿çŠ¶æ€
 */
function hideTypingIndicator() {
    // ä»…åœ¨ç§èŠä¸­æ‰§è¡Œ
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : null;
    if (chat) {
        const subtitle = document.getElementById('chat-room-subtitle');
        const statusTextElement = document.getElementById('chat-room-status-text');

        if (subtitle && statusTextElement) { 
            // æ¢å¤æ˜¾ç¤ºç»¿ç‚¹
            subtitle.querySelector('.online-indicator').style.display = 'block';
            // æ¢å¤è§’è‰²çš„åœ¨çº¿çŠ¶æ€
            statusTextElement.textContent = chat.status || 'åœ¨çº¿';
            // ç§»é™¤åŠ¨ç”»Class
            statusTextElement.classList.remove('typing-status');
        }
    }
}
// â–²â–²â–² æ–°å‡½æ•°åˆ°æ­¤ç»“æŸ â–²â–²â–²
        const init = async () => {
        	// åœ¨ init å‡½æ•°çš„æœ€é¡¶éƒ¨æ·»åŠ 
if (!db.userDiaries) {
    db.userDiaries = [];
}
  await loadData();
  
  // ğŸ†• æ‰§è¡Œæ•°æ®è¿ç§»ï¼ˆè¡¨æƒ…åŒ…åˆ†ç»„åŠŸèƒ½ï¼‰
  await migrateStickersToGroupVersion();
  await migrateCharacterStickerBindings();
            
            applyLayoutPreference();
           applyGlobalCss(db.globalCustomCss);
            window.db = db;
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.context-menu')) {
                    e.stopPropagation();
                    return;
                }
                removeContextMenu();

                const backBtn = e.target.closest('.back-btn');
                if (backBtn) {
                    e.preventDefault();
                    switchScreen(backBtn.getAttribute('data-target'));
                }

                // Consolidated overlay closing logic
                const openOverlay = document.querySelector('.modal-overlay.visible, .action-sheet-overlay.visible');
                if (openOverlay && e.target === openOverlay) {
                    openOverlay.classList.remove('visible');
                }
            });

            // Specific nav links that switch screens
            document.body.addEventListener('click', e => {
                const navLink = e.target.closest('.app-icon[data-target]');
                if (navLink) {
                    e.preventDefault();
                    switchScreen(navLink.getAttribute('data-target'));
                }
            });
// --- ä¸€æ¬¡æ€§å°†ç”¨æˆ·æ—¥è®°æ•°æ®è¿ç§»åˆ°å…¨å±€ ---
if (db.characters.some(c => c.userDiaries && c.userDiaries.length > 0)) {
    if (!db.userDiaries) db.userDiaries = [];
    const allUserDiaries = [];
    db.characters.forEach(char => {
        if (char.userDiaries && char.userDiaries.length > 0) {
            allUserDiaries.push(...char.userDiaries);
            delete char.userDiaries; // ä»è§’è‰²å¯¹è±¡ä¸­åˆ é™¤
        }
    });
    // å»é‡å¹¶åˆå¹¶åˆ°å…¨å±€
    const uniqueDiaries = [...new Map(allUserDiaries.map(item => [item.id, item])).values()];
    db.userDiaries.push(...uniqueDiaries);
    console.log('ç”¨æˆ·æ—¥è®°æ•°æ®å·²æˆåŠŸè¿ç§»åˆ°å…¨å±€ã€‚');
    saveData(); // ä¿å­˜è¿ç§»åçš„ç»“æœ
}
            
            applyGlobalFont(db.fontUrl);
            setupCustomWidgetSystem();
            setupHomeScreen();
            updateClock();
            setInterval(updateClock, 30000);
            setupChatListScreen();
            setupAddCharModal();
            setupChatRoom();
// ===============================================================
// START: æ—¥å†å…¨å±€é©±åŠ¨å™¨ (ä¿®å¤ innerHTML ä¸æ‰§è¡Œè„šæœ¬çš„é—®é¢˜)
// ===============================================================
(function startCalendarDriver() {
    console.log("æ—¥å†å…¨å±€é©±åŠ¨å™¨å·²å¯åŠ¨...");

    // å®šä¹‰æ¸²æŸ“å‡½æ•°
    function renderCalendar(root) {
        var rawEl = root.querySelector('.cal-raw-data');
        var viewEl = root.querySelector('.cal-ui-view');
        if (!rawEl || !viewEl) return;

        try {
            var raw = rawEl.value || '';
            // æ•°æ®æ¸…æ´—
            raw = raw.replace(/```json/g, '').replace(/```/g, '').trim();
            raw = raw.replace(/ï¼š/g, ':');
            if (raw.endsWith(']')) raw = raw.slice(0, -1);

            var parts = raw.split('::');
            if (parts.length < 6) return; // æ•°æ®è¿˜æ²¡å‡†å¤‡å¥½

            // è§£ææ•°æ®
            var year = parts[0].trim();
            var month = parts[1].trim();
            var today = parseInt(parts[2]);
            var startDay = parseInt(parts[3]);
            var totalDays = parseInt(parts[4]);
            var dayList = parts[5].replace(/[\r\n]+/g, '').split('|');

            // ç”Ÿæˆ HTML
            var uId = 'c' + Math.random().toString(36).substr(2, 6);
            var weeks = ['S','M','T','W','T','F','S'];
            
            var html = '<div style="padding:15px;text-align:center;font-weight:800;color:#1e293b;background:#f8fafc;border-bottom:1px solid #f1f5f9">' + year + 'å¹´ ' + month + 'æœˆ</div>';
            html += '<div style="display:grid;grid-template-columns:repeat(7,1fr);text-align:center;padding:10px 0;font-size:10px;color:#94a3b8;font-weight:bold">' + 
                    weeks.map(w => '<span>'+w+'</span>').join('') + '</div>';
            html += '<div style="display:grid;grid-template-columns:repeat(7,1fr);gap:4px;padding:0 12px 15px 12px">';

            for (var i = 0; i < startDay; i++) html += '<div></div>';

            for (var d = 1; d <= totalDays; d++) {
                var dayData = (dayList[d-1] || '^^^^').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
                var isToday = (d === today);
                var isFuture = (d > today);
                var bg = isToday ? '#3b82f6' : (isFuture ? '#fff' : '#f1f5f9');
                var col = isToday ? '#fff' : (isFuture ? '#cbd5e1' : '#475569');
                var border = isFuture ? '1px dashed #e2e8f0' : '1px solid transparent';
                var shadow = isToday ? '0 4px 10px rgba(59,130,246,0.3)' : 'none';

                html += '<div class="'+uId+'-btn" data-day="'+d+'" data-info="'+dayData+'" ' +
                    'style="aspect-ratio:1;display:flex;align-items:center;justify-content:center;border-radius:8px;font-size:13px;font-weight:600;cursor:pointer;background:'+bg+';color:'+col+';border:'+border+';box-shadow:'+shadow+';transition:0.2s;">' + d + '</div>';
            }
            html += '</div>';
            html += '<div id="'+uId+'-panel" style="display:none;position:absolute;bottom:0;left:0;right:0;background:rgba(255,255,255,0.98);backdrop-filter:blur(5px);padding:15px;border-top:1px solid #e2e8f0;border-radius:0 0 16px 16px;box-shadow:0 -4px 20px rgba(0,0,0,0.05);animation:slideUp 0.2s;"></div>';

            viewEl.innerHTML = html;

            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            setTimeout(function() {
                var btns = root.querySelectorAll('.' + uId + '-btn');
                var panel = root.querySelector('#' + uId + '-panel');
                
                btns.forEach(function(btn) {
                    btn.onclick = function() {
                        btns.forEach(function(b) { b.style.transform = 'scale(1)'; });
                        this.style.transform = 'scale(1.1)';

                        var day = this.getAttribute('data-day');
                        var info = this.getAttribute('data-info').split('^');
                        var isFut = (parseInt(day) > today);
                        
                        var formatList = function(str, icon) {
                            if(!str || str.trim() === '') return '<div style="color:#cbd5e1;font-size:11px;font-style:italic">ç©ºç©ºå¦‚ä¹Ÿ</div>';
                            return str.split('&').map(function(s) { return '<div style="margin-bottom:2px"><span style="margin-right:4px">'+icon+'</span>'+s+'</div>' }).join('');
                        };

                        panel.innerHTML = 
                            '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;font-weight:bold;color:#334155">' +
                                '<span>'+month+'æœˆ'+day+'æ—¥ <span style="font-size:11px;font-weight:normal;color:#64748b;margin-left:5px">'+(info[4]||'')+' '+(info[2]||'')+'</span></span>' +
                                '<span style="cursor:pointer;padding:0 5px;color:#94a3b8" class="close-btn">âœ•</span>' +
                            '</div>' +
                            '<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:10px;font-size:11px;color:#475569">' +
                                '<div style="background:#f8fafc;padding:8px;border-radius:6px"><div style="color:#1e293b;font-weight:bold;margin-bottom:4px">'+(isFut?'ğŸ“… è®¡åˆ’':'âœ… å®Œæˆ')+'</div>'+formatList(info[0], 'â–«ï¸')+'</div>' +
                                '<div style="background:#f8fafc;padding:8px;border-radius:6px"><div style="color:#1e293b;font-weight:bold;margin-bottom:4px">âœ¨ ç¢ç‰‡</div>'+formatList(info[1], 'â–«ï¸')+'</div>' +
                            '</div>' +
                            '<div style="font-size:11px;color:#334155;background:#f0f9ff;padding:8px;border-radius:6px;border-left:3px solid #3b82f6;line-height:1.4">' + (info[3] || 'æ— æ—¥è®°è®°å½•') + '</div>';
                        
                        panel.querySelector('.close-btn').onclick = function() { panel.style.display = 'none'; };
                        panel.style.display = 'block';
                    };
                });
            }, 0);

            // æˆåŠŸåç§»é™¤æ ‡è®°ï¼Œé¿å…é‡å¤å¤„ç†
            root.classList.remove('pending-init');
            root.classList.add('init-done');

        } catch (e) {
            console.error("æ—¥å†æ¸²æŸ“å‡ºé”™", e);
            viewEl.innerHTML = '<div style="color:red">æ¸²æŸ“é”™è¯¯: ' + e.message + '</div>';
        }
    }

    // è®¾ç½®å·¡é€»é˜Ÿï¼šæ¯ 500 æ¯«ç§’æ£€æŸ¥ä¸€æ¬¡é¡µé¢ä¸Šæœ‰æ²¡æœ‰æ–°çš„å¾…åŠæ—¥å†
    setInterval(function() {
        var pendingWidgets = document.querySelectorAll('.cal-v5-wrapper.pending-init');
        pendingWidgets.forEach(function(widget) {
            renderCalendar(widget);
        });
    }, 500);

})();
// ===============================================================
// END: æ—¥å†å…¨å±€é©±åŠ¨å™¨
// ===============================================================

            setupChatSettings();
            setupApiSettingsApp();
            setupWallpaperApp();
            setupStickerSystem();
            setupVoiceMessageSystem();
            setupPhotoVideoSystem();
            setupImageRecognition();
            setupWalletSystem();
            setupGiftSystem();
            setupTimeSkipSystem();
            setupWorldBookApp();
            setupFontSettingsApp();
            bindFontPresetUI();
            setupGroupChatSystem();
            setupCustomizeApp();
            setupTutorialApp();
            setupFileSystem(); // --- NEW ---
            setupLocationSystem(); // --- NEW ---
            setupFileDisplaySystem(); 
            // (åœ¨ init å‡½æ•°å†…éƒ¨ï¼Œé è¿‘å…¶ä»– setup...() å‡½æ•°çš„åœ°æ–¹æ·»åŠ )
setupAvatarFrameSystem(); // æ–°å¢ï¼šåˆå§‹åŒ–å¤´åƒæ¡†åŠŸèƒ½
            setupVoiceCallSystem();
            setupDiarySystem(); // --- åœ¨è¿™é‡Œæ·»åŠ è¿™ä¸€è¡Œ ---
            setupMusicPlayer();
            setupNotificationSystem();
            setupMomentsEventListeners();
setupTrajectoryAndHeartSoundSystem();
          setupRollbackFeature(); 
          setupContinueWritingFeature(); 
  setupAiPovApp();
  setupWalletApp(); // <-- æ·»åŠ è¿™ä¸€è¡Œ
  // (åœ¨ init() å‡½æ•°çš„æœ«å°¾æ·»åŠ )
setupBlockFeature(); 
setInterval(checkTimedUnblocks, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡åˆ°æœŸçš„AIæ‹‰é»‘
setupProactiveAiSystem();
setupHomeScreenPaging(); // æ–°å¢ï¼šä¸»é¡µç¿»é¡µ
        setupRendererApp();      // æ–°å¢ï¼šæ¸²æŸ“å™¨åº”ç”¨
 setupViewRecalledModal(); 
 // åœ¨ init() å‡½æ•°çš„æœ«å°¾æ·»åŠ 
setupBatchStickerUpload();
setupMallApp();
setupPaymentHistoryActions();
setupAiSpaceApps(); // åˆå§‹åŒ–AIç©ºé—´æ‰€æœ‰App
          applyAiSpaceWallpaper(db.aiSpaceWallpaper); // æ–°å¢ï¼šåº”ç”¨å·²ä¿å­˜çš„AIæ‰‹æœºå£ç´™
setupSoulBondApp();
setupDiaryExchangeApp();
setupBondMissYouHeartFeature();
setupBondInvitationSystem();
setupDailyQuestionFeature(); // <-- æ–°å¢è¿™ä¸€è¡Œ
    setupMoodWeatherFeature();   // <-- æ–°å¢è¿™ä¸€è¡Œ
setupPomodoroFeature();
setupSearchInChat();

};




// ===============================================================
// START: å®Œæ•´çš„å•†åŸåŠŸèƒ½JavaScriptä»£ç  (V5 - æœ€ç»ˆç‰ˆ)
// ===============================================================

// --- å•†åŸåŠè´­ç‰©æµç¨‹çš„å…¨å±€å˜é‡ (ç¡®ä¿åªå£°æ˜ä¸€æ¬¡) ---
let isGeneratingProducts = false;
let selectedCartItemIds = new Set(); // å­˜å‚¨è¢«é€‰ä¸­çš„è´­ç‰©è½¦é¡¹ID
let purchaseState = { productId: null, recipientId: null, quantity: 1, style: 'é»˜è®¤æ¬¾å¼', multiItems: [] };
let globalCountdownInterval = null;
let isLikesSelectionMode = false;
let selectedLikedProductIds = [];
// === æ–°å¢/ä¿®æ”¹çš„ä»£ç ï¼šä¿®å¤ä»£ä»˜åŠŸèƒ½ã€é‡æ„è´­ä¹°æµç¨‹å¹¶æ·»åŠ ä»˜æ¬¾è®°å½• ===

/**
 * æ–°å¢ï¼šå¤„ç†â€œæ‰¾äººä»£ä»˜â€è¯·æ±‚çš„å‡½æ•°
 * @param {string} productId - è¯·æ±‚ä»£ä»˜çš„å•†å“ID
 */
async function handlePayForMeRequest(productId) {
    const product = findProductById(productId);
    if (!product) return;

    // å¼¹å‡ºé€‰æ‹©ä»£ä»˜äººçš„æ¨¡æ€æ¡†
    const modal = document.getElementById('purchase-modal');
    purchaseState = { productId, isPayForMe: true }; // æ ‡è®°å½“å‰æ˜¯ä»£ä»˜æµç¨‹

    // æ›´æ–°å¼¹çª—æ ‡é¢˜å’ŒæŒ‰é’®æ–‡å­—ï¼Œä½¿å…¶æ›´ç¬¦åˆâ€œä»£ä»˜â€åœºæ™¯
    modal.querySelector('h5').textContent = 'é€‰æ‹©è°æ¥å¸®ä½ ä»˜æ¬¾ï¼Ÿ';
    document.getElementById('confirm-recipient-btn').textContent = 'å‘é€ä»£ä»˜è¯·æ±‚';
    
    document.getElementById('purchase-product-image').src = product.imageUrl;
    document.getElementById('purchase-product-price').textContent = `Â¥${product.price.toFixed(2)}`;
    document.getElementById('purchase-product-name').textContent = product.name;
    
    renderRecipientList();
    modal.classList.add('visible');
}


// æ›¿æ¢æ—§çš„ handleFinalPurchaseConfirmation å‡½æ•°
async function handleFinalPurchaseConfirmation() {
    // 1. è·å–ç”¨æˆ·é€‰æ‹©çš„æ•°é‡å’Œæ ·å¼ï¼Œå¹¶ä¿å­˜åˆ°å…¨å±€çŠ¶æ€ä¸­
    purchaseState.quantity = parseInt(document.getElementById('purchase-quantity-input').value, 10);
    const activeStyleBtn = document.querySelector('.style-option-btn.active');
    purchaseState.style = activeStyleBtn ? activeStyleBtn.textContent : 'é»˜è®¤æ¬¾å¼';

    // 2. å…³é—­å½“å‰ï¼ˆæ ·å¼/æ•°é‡é€‰æ‹©ï¼‰çš„å¼¹çª—
    document.getElementById('product-options-modal').classList.remove('visible');
    
    // 3. æ‰“å¼€â€œè®¾ç½®é€è¾¾æ—¶é—´â€çš„å¼¹çª—
    document.getElementById('delivery-countdown-modal').classList.add('visible');
}
// â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªå®Œæ•´çš„ã€ä¿®æ­£åçš„æ–°å‡½æ•°ï¼Œæ›¿æ¢æ‰æ–‡ä»¶ä¸­æ—§çš„ renderPaymentHistory å‡½æ•° â–¼â–¼â–¼
/**
 * æ–°å¢ï¼šæ¸²æŸ“ä»˜æ¬¾è®°å½•åˆ—è¡¨çš„å‡½æ•°
 */
function renderPaymentHistory() {
    const container = document.getElementById('payment-history-list');
    if (!container) return;

    container.innerHTML = '';
    const history = db.mallData.paymentHistory || [];

    if (history.length === 0) {
        container.innerHTML = '<p class="placeholder-text" style="padding: 15px 0;">æš‚æ— ä»˜æ¬¾è®°å½•</p>';
        return;
    }

    // æŒ‰æ—¶é—´å€’åºæ˜¾ç¤º
    history.sort((a, b) => b.timestamp - a.timestamp);

    history.forEach(item => {
        const date = new Date(item.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
        const itemEl = document.createElement('div');
        itemEl.className = 'transaction-item'; // å¤ç”¨é’±åŒ…æ˜ç»†çš„æ ·å¼
        
        // ã€æ ¸å¿ƒä¿®æ”¹ã€‘ä¸ºæ¯æ¡è®°å½•æ·»åŠ ä¸€ä¸ª data-id å±æ€§
        itemEl.dataset.id = item.id;

        itemEl.innerHTML = `
            <div class="transaction-details">
                <span class="transaction-description">${item.description}</span>
                <span class="transaction-timestamp">${dateString}</span>
            </div>
            <span class="transaction-amount expense">- ${item.total.toFixed(2)}</span>
        `;
        container.appendChild(itemEl);
    });
}

/**
 * åˆ‡æ¢è´­ç‰©è½¦å•†å“çš„é€‰ä¸­çŠ¶æ€
 */
function toggleCartItemSelection(cartId) {
    if (selectedCartItemIds.has(cartId)) {
        selectedCartItemIds.delete(cartId);
    } else {
        selectedCartItemIds.add(cartId);
    }
    document.querySelector(`.cart-item[data-cart-id="${cartId}"]`)?.classList.toggle('selected');
    updateCartCheckoutBar();
}

/**
 * æ›´æ–°åº•éƒ¨ç»“ç®—æ çš„æ˜¾ç¤ºå’Œæ•°æ®
 */
function updateCartCheckoutBar() {
    const bar = document.getElementById('cart-checkout-bar');
    const totalPriceEl = document.getElementById('cart-total-price');
    const checkoutBtn = document.getElementById('cart-checkout-btn');
    const selectAllContainer = document.querySelector('.select-all-container');
    
    const totalItems = db.mallData.cart.length;
    const selectedCount = selectedCartItemIds.size;

    if (totalItems > 0) {
        bar.style.display = 'flex';
    } else {
        bar.style.display = 'none';
    }

    let totalPrice = 0;
    selectedCartItemIds.forEach(cartId => {
        const cartItem = db.mallData.cart.find(item => item.cartId === cartId);
        const product = cartItem ? db.mallData.products.find(p => p.id === cartItem.productId) : null;
        if (product) totalPrice += product.price;
    });

    totalPriceEl.textContent = `åˆè®¡: Â¥${totalPrice.toFixed(2)}`;
    checkoutBtn.textContent = `å»ç»“ç®— (${selectedCount})`;
    checkoutBtn.disabled = selectedCount === 0;

    selectAllContainer.classList.toggle('selected', selectedCount > 0 && selectedCount === totalItems);
}

/**
 * å¤„ç†è´­ç‰©è½¦ç»“ç®—
 */
// â–¼â–¼â–¼ 1. ä½¿ç”¨è¿™ä¸ªæ–°å‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ—§çš„ handleCartCheckout å‡½æ•° â–¼â–¼â–¼
async function handleCartCheckout() {
    if (selectedCartItemIds.size === 0) {
        showToast("è¯·è‡³å°‘é€‰æ‹©ä¸€ä»¶å•†å“");
        return;
    }
    // --- æ ¸å¿ƒä¿®æ”¹ï¼šä»æ‰€æœ‰å•†å“ä¸­æŸ¥æ‰¾ ---
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];
    const itemsToPurchase = Array.from(selectedCartItemIds).map(cartId => {
        const cartItem = db.mallData.cart.find(item => item.cartId === cartId);
        return cartItem ? allProducts.find(p => p.id === cartItem.productId) : null;
    }).filter(Boolean);
    // --- ä¿®æ”¹ç»“æŸ ---

    if (itemsToPurchase.length === 0) return;
    renderPaymentConfirmationScreen(itemsToPurchase);
}

// â–¼â–¼â–¼ åœ¨æ‚¨çš„JSä»£ç ä¸­æ·»åŠ è¿™ä¸ªã€å®Œæ•´ã€‘çš„ç¼ºå¤±å‡½æ•° â–¼â–¼â–¼
function renderPaymentConfirmationScreen(items) {
    const recipientSelect = document.getElementById('payment-recipient-select');
    const itemListEl = document.getElementById('payment-items-list');
    const totalPriceEl = document.getElementById('payment-total-price');
    
    // æ·»åŠ â€œæˆ‘è‡ªå·±â€ä½œä¸ºæ”¶è´§äººé€‰é¡¹
    recipientSelect.innerHTML = '<option value="user_me">æˆ‘è‡ªå·±</option>';
    db.characters.forEach(char => {
        const option = document.createElement('option');
        option.value = char.id;
        option.textContent = char.remarkName;
        recipientSelect.appendChild(option);
    });

    itemListEl.innerHTML = '';
    let totalPrice = 0;
    items.forEach(item => {
        totalPrice += item.price;
        const itemCard = document.createElement('div');
        itemCard.className = 'payment-item-card';
        itemCard.innerHTML = `
            <img src="${item.imageUrl}" alt="${item.name}">
            <div class="item-info">
                <p class="item-name">${item.name}</p>
                <p class="item-price">Â¥${item.price.toFixed(2)}</p>
            </div>
        `;
        itemListEl.appendChild(itemCard);
    });
    totalPriceEl.textContent = `Â¥${totalPrice.toFixed(2)}`;
    
    window.currentPurchaseItems = items;
    window.currentPurchaseTotal = totalPrice;

    switchScreen('payment-confirmation-screen');
}
// â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
// â–¼â–¼â–¼ 1. ä½¿ç”¨è¿™ä¸ªæ–°å‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ—§çš„ 
/**
 * æ–°å¢ï¼šä¸ºä»˜æ¬¾è®°å½•åˆ—è¡¨è®¾ç½®é•¿æŒ‰åˆ é™¤ç­‰äº¤äº’äº‹ä»¶
 */
function setupPaymentHistoryActions() {
    const historyList = document.getElementById('payment-history-list');
    if (!historyList) return;

    const handleLongPress = (event) => {
        const item = event.target.closest('.transaction-item');
        if (!item) return;

        event.preventDefault(); // é˜»æ­¢é»˜è®¤çš„å³é”®èœå•
        const transactionId = item.dataset.id;
        
        // ä½¿ç”¨ createContextMenu å‡½æ•°åˆ›å»ºèœå•
        createContextMenu(
            [{
                label: 'åˆ é™¤æ­¤æ¡è®°å½•',
                danger: true,
                action: async () => {
                    if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡ä»˜æ¬¾è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                        // ä»æ•°æ®åº“ä¸­è¿‡æ»¤æ‰è¢«åˆ é™¤çš„è®°å½•
                        db.mallData.paymentHistory = db.mallData.paymentHistory.filter(
                            tx => tx.id !== transactionId
                        );
                        await saveData(); // ä¿å­˜æ›´æ”¹
                        renderPaymentHistory(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨
                        showToast('è®°å½•å·²åˆ é™¤');
                    }
                }
            }],
            event.clientX, // é¼ æ ‡Xåæ ‡
            event.clientY  // é¼ æ ‡Yåæ ‡
        );
    };

    // ç›‘å¬ç”µè„‘ä¸Šçš„å³é”®ç‚¹å‡»
    historyList.addEventListener('contextmenu', handleLongPress);

    // ç›‘å¬æ‰‹æœºä¸Šçš„é•¿æŒ‰
    let longPressTimer;
    historyList.addEventListener('touchstart', (e) => {
        longPressTimer = setTimeout(() => {
            const touch = e.touches[0];
            const mockEvent = { clientX: touch.clientX, clientY: touch.clientY, target: e.target, preventDefault: () => e.preventDefault() };
            handleLongPress(mockEvent);
        }, 500); // é•¿æŒ‰è¶…è¿‡500æ¯«ç§’è§¦å‘
    });
    historyList.addEventListener('touchend', () => clearTimeout(longPressTimer));
    historyList.addEventListener('touchmove', () => clearTimeout(longPressTimer));
}
async function sendPaymentRequestCard(charId, items, total) {
    const character = db.characters.find(c => c.id === charId);
    if (!character) return;

    const message = {
        id: `msg_pay_req_${Date.now()}`,
        role: 'user',
        content: `[æˆ‘å‘ ${character.remarkName} å‘èµ·ä»£ä»˜è¯·æ±‚]`,
        parts: [],
        timestamp: Date.now(),
        paymentRequestData: {
            status: 'pending', // 'pending', 'paid', 'declined'
            amount: total,
            items: items.map(item => ({ id: item.id, name: item.name, imageUrl: item.imageUrl })),
            requesterName: character.myName // æˆ‘çš„åå­—
        }
    };

    character.history.push(message);
    await saveData();
    renderChatList();
}

/**
 * å¤„ç†å•†åŸçš„æœç´¢é€»è¾‘
 * @param {string} query - ç”¨æˆ·è¾“å…¥çš„æœç´¢å…³é”®è¯
 */
async function handleMallSearch(query) {
    if (!query) {
        renderMallProducts(); // å¦‚æœæœç´¢ä¸ºç©ºï¼Œåˆ™æ˜¾ç¤ºæ‰€æœ‰å•†å“
        return;
    }

    showToast(`æ­£åœ¨æœç´¢â€œ${query}â€...`);
    const lowerCaseQuery = query.toLowerCase();
    
    // 1. åœ¨ç°æœ‰å•†å“ä¸­è¿›è¡Œæœ¬åœ°æ¨¡ç³Šæœç´¢
    const localResults = db.mallData.products.filter(p => 
        p.name.toLowerCase().includes(lowerCaseQuery) || 
        p.description.toLowerCase().includes(lowerCaseQuery)
    );

    if (localResults.length > 0) {
        // 2. å¦‚æœæ‰¾åˆ°ç»“æœï¼Œåˆ™ç›´æ¥æ¸²æŸ“
        renderMallProducts(localResults);
        showToast(`æ‰¾åˆ°äº† ${localResults.length} ä»¶ç›¸å…³å•†å“`);
    } else {
        // 3. å¦‚æœæœ¬åœ°æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™è¯·æ±‚AIåˆ›é€ å¤šä¸ªæ–°å•†å“
        try {
            // è°ƒç”¨æ–°çš„å¤æ•°ç‰ˆæœ¬å‡½æ•°
            const fictionalProducts = await generateFictionalProducts(query);
            
            // å°†æ‰€æœ‰æ–°åˆ›é€ çš„å•†å“æ·»åŠ åˆ°æ€»å•†å“åˆ—è¡¨çš„é¡¶éƒ¨
            db.mallData.products.unshift(...fictionalProducts);
            await saveData();

            // åªæ˜¾ç¤ºè¿™äº›æ–°åˆ›é€ çš„å•†å“ä½œä¸ºæœ¬æ¬¡çš„æœç´¢ç»“æœ
            renderMallProducts(fictionalProducts);
            showToast(`ä¸ºæ‚¨åˆ›é€ äº† ${fictionalProducts.length} ä»¶æ–°å•†å“ï¼`);
        } catch (error) {
            console.error("åˆ›é€ è™šæ„å•†å“å¤±è´¥:", error);
            showToast(`åˆ›é€ å¤±è´¥: ${error.message}`);
            document.getElementById('product-grid').innerHTML = `<p class="placeholder-text" style="color:red;">å“å‘€ï¼Œåˆ›é€ åŠ›æ¯ç«­äº†...</p>`;
        }
    }
}
// === [V3] æ›¿æ¢æ—§çš„ generateFictionalProducts å‡½æ•° ===
async function generateFictionalProducts(query) {
    
    let prompt;
    const isSpecialMode = db.mallData.api.specialItemsEnabled;

    if (isSpecialMode) {
        // --- æ ¸å¿ƒä¿®æ”¹åœ¨æ­¤ ---
        prompt = `ä½ æ˜¯ä¸€ä¸ªå”®å–å¥‡å¹»ç‰¹æ®Šç‰©å“çš„åˆ›æ„åº—ä¸»ã€‚ä¸€ä¸ªé¡¾å®¢æœç´¢äº†å…³é”®è¯â€œ${query}â€ã€‚
é‡è¦å‰æï¼šè¿™äº›å•†å“éƒ½å°†ç”±ç”¨æˆ·(â€œæˆ‘â€)è´­ä¹°ï¼Œå¹¶å¯¹èŠå¤©ä¸­çš„AIè§’è‰²(â€œæ”¶ä»¶äººâ€)ä½¿ç”¨ã€‚å› æ­¤ï¼Œæ‰€æœ‰å•†å“çš„'åŠŸèƒ½'éƒ½å¿…é¡»æ˜¯èƒ½å¤Ÿåœ¨**æ–‡å­—å¯¹è¯ä¸­è¢«æ˜ç¡®è§‚å¯Ÿå’Œæ‰®æ¼”å‡ºæ¥**çš„æ•ˆæœã€‚

è¯·ä½ ç«‹å³åˆ›é€ å¹¶ä¸Šæ¶ 3åˆ°5ä»¶ ä¸â€œ${query}â€ç›¸å…³çš„å•†å“ã€‚
è§„åˆ™:
1.  **æè¿°å¿…é¡»æ¸…æ™°**: å•†å“çš„ "description" å¿…é¡»æ˜ç¡®åŒ…å« "åŠŸèƒ½ï¼š" (æè¿°ä¸€ä¸ªèƒ½**ç›´æ¥æ”¹å˜æ”¶ä»¶äººèŠå¤©è¡Œä¸º**çš„æ•ˆæœ)ã€"æ•ˆæœæŒç»­ï¼š" (å•ä½ä¸ºâ€œè½®å¯¹è¯â€)ã€"å‰¯ä½œç”¨ï¼š" å’Œ "å‰¯ä½œç”¨æŒç»­ï¼š" (å•ä½ä¸ºâ€œè½®å¯¹è¯â€) è¿™å››ä¸ªéƒ¨åˆ†ã€‚
2.  **ä»·æ ¼ä¸å‰¯ä½œç”¨**: ä»·æ ¼è¶Šé«˜çš„ç‰©å“ï¼Œå‰¯ä½œç”¨åº”è¯¥è¶Šå°æˆ–æŒç»­æ—¶é—´è¶ŠçŸ­ã€‚ä»·æ ¼èŒƒå›´åœ¨10åˆ°5000ä¹‹é—´ã€‚
3.  **åˆ›æ„ç¤ºä¾‹ (å¿…é¡»å‚è€ƒ)**:
    - **æ”¹å˜è¡Œä¸º**: 'å®³ç¾å–·é›¾ (åŠŸèƒ½ï¼šè®©æ”¶ä»¶äººå˜å¾—éå¸¸å®³ç¾å’Œå†…å‘ï¼Œè¯´è¯å°å¿ƒç¿¼ç¿¼ã€‚æ•ˆæœæŒç»­ï¼š10è½®å¯¹è¯ã€‚å‰¯ä½œç”¨ï¼šæ— ã€‚)'
    - **æ”¹å˜è¯´è¯æ–¹å¼**: 'è¯šå®è±†æ²™åŒ… (åŠŸèƒ½ï¼šè®©æ”¶ä»¶äººåœ¨æ¥ä¸‹æ¥çš„å¯¹è¯ä¸­åªèƒ½è¯´çœŸè¯ã€‚æ•ˆæœæŒç»­ï¼š3è½®å¯¹è¯ã€‚å‰¯ä½œç”¨ï¼šæ•ˆæœç»“æŸåä¼šå¤´ç—›ï¼Œå¹¶åœ¨å¯¹è¯ä¸­æŠ±æ€¨ã€‚å‰¯ä½œç”¨æŒç»­ï¼š5è½®å¯¹è¯ã€‚)'
    - **æ”¹å˜è®¤çŸ¥**: 'å¤±å¿†æ©¡çš®æ“¦ (åŠŸèƒ½ï¼šè®©æ”¶ä»¶äººæš‚æ—¶å¿˜è®°â€œæˆ‘â€æ˜¯è°ã€‚æ•ˆæœæŒç»­ï¼š5è½®å¯¹è¯ã€‚å‰¯ä½œç”¨ï¼šæ¢å¤è®°å¿†åä¼šå¯¹ä¹‹å‰çš„å¯¹è¯æ„Ÿåˆ°å›°æƒ‘ã€‚å‰¯ä½œç”¨æŒç»­ï¼š2è½®å¯¹è¯ã€‚)'
4.  **ä¸¥æ ¼æ ¼å¼**: ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ•°ç»„æ ¼å¼ [ {å•†å“1}, {å•†å“2}, ... ]ï¼Œä¸è¦æœ‰ä»»ä½•é¢å¤–æ–‡å­—ã€‚

æ¯ä¸ªå•†å“å¯¹è±¡çš„JSONæ ¼å¼å¦‚ä¸‹:
{
  "name": "ä¸€ä¸ªæå…·åˆ›æ„çš„ã€èƒ½å½±å“èŠå¤©å¯¹è±¡çš„ç‰©å“åç§°",
  "description": "ä¸€æ®µåŒ…å«'åŠŸèƒ½'ã€'æ•ˆæœæŒç»­'ã€'å‰¯ä½œç”¨'å’Œ'å‰¯ä½œç”¨æŒç»­'çš„æè¿°",
  "price": [ä¸€ä¸ª10åˆ°5000ä¹‹é—´çš„éšæœºæ•°å­—],
  "storeName": "ä¸‡èƒ½æ‚è´§é“ºãƒ»å¥‡ç‰©éƒ¨",
  "imagePrompt": "ä¸€ä¸ªç”¨äºAIç»˜ç”»çš„ã€æè¿°è¯¥å¥‡ç‰©çš„è‹±æ–‡å…³é”®è¯çŸ­è¯­"
}`;
        // --- ä¿®æ”¹ç»“æŸ ---
    } else {
         // è¿™æ˜¯ç”¨äºç”Ÿæˆæ™®é€šç‰©å“çš„åŸå§‹æŒ‡ä»¤ (ä¿æŒä¸å˜)
        prompt = `ä½ æ˜¯ä¸€ä¸ªä¸‡èƒ½æ‚è´§é“ºçš„åˆ›æ„åº—ä¸»ï¼Œä½ çš„åº—é‡Œä»€ä¹ˆéƒ½å–ï¼Œæ— è®ºæ˜¯ç°å®å­˜åœ¨çš„è¿˜æ˜¯å¤©é©¬è¡Œç©ºçš„ã€‚
ä¸€ä¸ªé¡¾å®¢æœç´¢äº†å…³é”®è¯â€œ${query}â€ï¼Œä½†æˆ‘ä»¬çš„åº“å­˜é‡Œæ²¡æœ‰è¿™ä¸ªä¸œè¥¿ã€‚
è¯·ä½ æ ¹æ®è¿™ä¸ªå…³é”®è¯ï¼Œç«‹å³åˆ›é€ å¹¶ä¸Šæ¶ 3åˆ°5ä»¶ ç‹¬ä¸€æ— äºŒä½†ä¸»é¢˜ç›¸ä¼¼çš„å•†å“ã€‚
ä½ çš„ä»»åŠ¡æ˜¯ä¸ºæ¯ä¸€ä»¶å•†å“ç”Ÿæˆè¯¦ç»†ä¿¡æ¯ã€‚
ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„ JSONæ•°ç»„ æ ¼å¼ï¼Œåƒè¿™æ · [ {å•†å“1}, {å•†å“2}, ... ]ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–æ–‡å­—ã€‚

æ¯ä¸ªå•†å“å¯¹è±¡çš„JSONæ ¼å¼å¦‚ä¸‹:
{
  "name": "ä¸€ä¸ªæå…·åˆ›æ„çš„å•†å“åç§°",
  "description": "ä¸€æ®µ50å­—å·¦å³ï¼Œå¼•äººå…¥èƒœçš„å•†å“æè¿°",
  "price": [ä¸€ä¸ª10åˆ°1000ä¹‹é—´çš„éšæœºæ•°å­—],
  "storeName": "ä¸‡èƒ½æ‚è´§é“ºãƒ»åˆ›æ„éƒ¨",
  "imagePrompt": "ä¸€ä¸ªç”¨äºAIç»˜ç”»çš„ã€æè¿°è¯¥å•†å“çš„è‹±æ–‡å…³é”®è¯çŸ­è¯­"
}`;
    }
    
    const aiResponseText = await callMallApi([{ role: 'user', content: prompt }]);
    const productsData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);

    const newProducts = productsData.map(productData => ({
        ...productData,
        id: `prod_${Date.now()}_${Math.random().toString(36).slice(2)}`,
        imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(productData.imagePrompt)}`,
        likes: 0, saves: 0, comments: []
    }));

    return newProducts;
}

/**
 * æ–°å¢ï¼šåœ¨æ‰€æœ‰å•†å“ï¼ˆAIç”Ÿæˆ+è‡ªå®šä¹‰ï¼‰ä¸­æŸ¥æ‰¾å•†å“
 */
function findProductById(productId) {
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];
    return allProducts.find(p => p.id === productId);
}
// â–¼â–¼â–¼ ä½¿ç”¨è¿™ä¸ªæ–°ç‰ˆæœ¬ï¼Œå®Œæ•´æ›¿æ¢æ–‡ä»¶ä¸­æ—§çš„ setupMallApp å‡½æ•° â–¼â–¼â–¼
function setupMallApp() {
    // åˆå§‹åŒ–æ•°æ®ç»“æ„ (ä¿æŒä¸å˜)
    if (!db.mallData) {
        db.mallData = { api: {}, products: [], cart: [], likedProducts: [], logistics: [], 
specialItemsEnabled: false // <-- æ·»åŠ è¿™ä¸€è¡Œ };
}
    } else {
        if (!db.mallData.cart) db.mallData.cart = [];
        if (!db.mallData.likedProducts) db.mallData.likedProducts = [];
        if (!db.mallData.logistics) db.mallData.logistics = [];
    }
    startGlobalCountdownTimer();
    
    // --- æ–°å¢ï¼šè‡ªå®šä¹‰å•†å“åˆ›å»ºé€»è¾‘ ---
    const addCustomProductBtn = document.getElementById('add-custom-product-btn');
    const createProductModal = document.getElementById('create-product-modal');
    const createProductForm = document.getElementById('create-product-form');
    const isSpecialToggle = document.getElementById('is-special-product-toggle');
    const specialFields = document.getElementById('special-product-fields');

    addCustomProductBtn.addEventListener('click', () => {
        createProductForm.reset();
        specialFields.classList.remove('visible');
        createProductModal.classList.add('visible');
    });

    isSpecialToggle.addEventListener('change', (e) => {
        specialFields.classList.toggle('visible', e.target.checked);
        // å¦‚æœæ˜¯ç‰¹æ®Šå•†å“ï¼Œæ™®é€šæè¿°å˜ä¸ºå¯é€‰
        document.getElementById('custom-product-description').required = !e.target.checked;
    });

    createProductForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const isSpecial = isSpecialToggle.checked;
        let description = document.getElementById('custom-product-description').value.trim();

        // å¦‚æœæ˜¯ç‰¹æ®Šå•†å“ï¼Œåˆ™æ ¹æ®ä¸“ç”¨å­—æ®µæ„å»ºæè¿°å­—ç¬¦ä¸²
        if (isSpecial) {
            const func = document.getElementById('special-product-function').value.trim();
            const duration = document.getElementById('special-product-duration').value;
            const sideEffect = document.getElementById('special-product-side-effect').value.trim();
            const sideEffectDuration = document.getElementById('special-product-side-effect-duration').value;

            if (!func || !duration) {
                showToast('ç‰¹æ®Šå•†å“çš„åŠŸèƒ½å’Œæ•ˆæœæŒç»­æ—¶é—´ä¸ºå¿…å¡«é¡¹ï¼');
                return;
            }
            description = `åŠŸèƒ½ï¼š${func} æ•ˆæœæŒç»­ï¼š${duration}è½®å¯¹è¯`;
            if (sideEffect && sideEffectDuration) {
                description += ` å‰¯ä½œç”¨ï¼š${sideEffect} å‰¯ä½œç”¨æŒç»­ï¼š${sideEffectDuration}è½®å¯¹è¯`;
            } else if (sideEffect) {
                description += ` å‰¯ä½œç”¨ï¼š${sideEffect}`;
            }
        }
        
        const newProduct = {
            id: `prod_custom_${Date.now()}`,
            name: document.getElementById('custom-product-name').value.trim(),
            price: parseFloat(document.getElementById('custom-product-price').value),
            storeName: document.getElementById('custom-product-store').value.trim(),
            description: description,
            imageUrl: document.getElementById('custom-product-image-url').value.trim() || 'https://i.postimg.cc/PqYkx23B/shop-icon.png',
            likes: 0,
            saves: 0,
            comments: []
        };

        if (!newProduct.name || isNaN(newProduct.price)) {
            showToast('å•†å“åç§°å’Œä»·æ ¼ä¸ºå¿…å¡«é¡¹ï¼');
            return;
        }
if (!db.mallData.customProducts) {
        db.mallData.customProducts = [];
    }
        db.mallData.customProducts.unshift(newProduct);
        await saveData();

        createProductModal.classList.remove('visible');
        showToast(`å•†å“â€œ${newProduct.name}â€å·²æˆåŠŸåˆ›å»ºï¼`);
        renderMallProducts(); // åˆ·æ–°å•†åŸä¸»é¡µ
    });
    // --- è‡ªå®šä¹‰å•†å“é€»è¾‘ç»“æŸ ---

// --- æ–°å¢ï¼šå•†åŸæœç´¢åŠŸèƒ½äº‹ä»¶ç»‘å®š ---
    const searchInput = document.getElementById('mall-search-input');
    const searchBtn = document.getElementById('mall-search-btn');
    
    const performSearch = () => {
        const query = searchInput.value.trim();
        handleMallSearch(query);
    };

    if (searchBtn) {
        searchBtn.addEventListener('click', performSearch);
    }
    if (searchInput) {
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
    }
    // --- æ–°å¢ç»“æŸ ---
    // --- ä¸ªäººä¸­å¿ƒé¡µé¢çš„äº‹ä»¶å§”æ‰˜ ---
    const profileScreen = document.getElementById('mall-profile-screen');
    if (profileScreen) {
        const likedGrid = document.getElementById('liked-products-grid');
        // ä¸ºç‚¹èµå•†å“ç½‘æ ¼æ·»åŠ ç‚¹å‡»äº‹ä»¶
        likedGrid.addEventListener('click', (e) => {
            const card = e.target.closest('.product-card');
            if (card && card.dataset.productId) {
                openProductDetail(card.dataset.productId);
            }
        });
        // ä¸ºç‰©æµå…¥å£ç»‘å®šäº‹ä»¶
        document.querySelector('.wallet-action-item[data-target="logistics-screen"]').addEventListener('click', () => {
            renderLogistics();
            switchScreen('logistics-screen');
        });
    }
    // --- æ–°å¢äº‹ä»¶ç»‘å®š ---
    const refreshBtn = document.getElementById('refresh-mall-btn');
    if(refreshBtn) {
        refreshBtn.addEventListener('click', () => generateAndRenderProducts(false));
    }
    const loadMoreIndicator = document.getElementById('load-more-indicator');
    if(loadMoreIndicator) {
        loadMoreIndicator.addEventListener('click', () => generateAndRenderProducts(true));
    }
    // --- æ–°å¢ç»“æŸ ---
    // --- è´­ç‰©è½¦ç›¸å…³äº‹ä»¶ç»‘å®š ---
    const cartContainer = document.getElementById('cart-item-list-container');
    const cartCheckoutBtn = document.getElementById('cart-checkout-btn');
    const cartSelectAllBtn = document.getElementById('cart-select-all-btn');
    const cartManageBtn = document.getElementById('cart-manage-btn');
    const cartDeleteSelectedBtn = document.getElementById('cart-delete-selected-btn');
    const cartScreen = document.getElementById('mall-cart-screen');

    if (cartContainer) {
        cartContainer.addEventListener('click', (e) => {
            const item = e.target.closest('.cart-item');
            if (item) {
                toggleCartItemSelection(item.dataset.cartId);
            }
        });
    }
    if (cartCheckoutBtn) cartCheckoutBtn.addEventListener('click', handleCartCheckout);
    if (cartSelectAllBtn) {
        cartSelectAllBtn.addEventListener('click', () => {
            const allCartItems = db.mallData.cart || [];
            const shouldSelectAll = selectedCartItemIds.size < allCartItems.length;
            if (shouldSelectAll) {
                allCartItems.forEach(item => selectedCartItemIds.add(item.cartId));
            } else {
                selectedCartItemIds.clear();
            }
            renderCart();
        });
    }
    if (cartManageBtn) {
        cartManageBtn.addEventListener('click', () => {
            cartScreen.classList.toggle('manage-mode');
            const isInManageMode = cartScreen.classList.contains('manage-mode');
            cartManageBtn.textContent = isInManageMode ? 'å®Œæˆ' : 'ç®¡ç†';
            if (!isInManageMode) {
                selectedCartItemIds.clear();
                renderCart();
            }
        });
    }
    // ã€é‡è¦ä¿®æ­£ã€‘ç§»é™¤åˆ é™¤æŒ‰é’®ä¸Šçš„è¡Œå†… style="display: none;" åï¼Œæ­¤é€»è¾‘æ‰èƒ½ç”Ÿæ•ˆ
    if (cartDeleteSelectedBtn) {
        cartDeleteSelectedBtn.addEventListener('click', async () => {
            if (selectedCartItemIds.size === 0) return showToast('è¯·é€‰æ‹©è¦åˆ é™¤çš„å•†å“');
            if (confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedCartItemIds.size} ä»¶å•†å“å—ï¼Ÿ`)) {
                db.mallData.cart = db.mallData.cart.filter(item => !selectedCartItemIds.has(item.cartId));
                selectedCartItemIds.clear();
                await saveData();
                renderCart();
                showToast('å•†å“å·²åˆ é™¤');
            }
        });
    }
    
    // --- æ–°çš„æ”¯ä»˜ç¡®è®¤é¡µé¢äº‹ä»¶ç»‘å®š ---
    document.getElementById('confirm-final-payment-btn').addEventListener('click', async () => {
        const isPayForMe = document.querySelector('.method-item#pay-for-me-btn').classList.contains('selected');

        if (isPayForMe) {
            // æ‰“å¼€ä»£ä»˜å¥½å‹é€‰æ‹©åˆ—è¡¨
            const listEl = document.getElementById('pay-for-me-selection-list');
            listEl.innerHTML = '';
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'list-item';
                li.style.cursor = 'pointer';
                li.dataset.charId = char.id;
                li.innerHTML = `<img src="${char.avatar}" class="chat-avatar"><span>${char.remarkName}</span>`;
                listEl.appendChild(li);
            });
            document.getElementById('pay-for-me-select-modal').classList.add('visible');
        } else {
            // æ‰§è¡Œè‡ªå·±æ”¯ä»˜çš„é€»è¾‘
            try {
                await handlePayment(window.currentPurchaseTotal, `è´­ç‰©æ¶ˆè´¹`);
                // --- æ ¸å¿ƒæ–°å¢ï¼šæ”¯ä»˜æˆåŠŸåï¼Œä¸ºæ¯ä¸ªå•†å“åˆ›å»ºé€è´§æ¶ˆæ¯ ---
const recipientId = document.getElementById('payment-recipient-select').value;
const deliveryMinutes = parseInt(document.getElementById('payment-delivery-duration').value, 10);
const recipient = db.characters.find(c => c.id === recipientId);

if (recipient) {
    window.currentPurchaseItems.forEach(item => {
        const deliveryMessage = {
            id: `msg_delivery_${Date.now()}_${item.id}`,
            role: 'user',
            content: `[æˆ‘ä¸º${recipient.remarkName}è´­ä¹°äº†${item.name}]`,
            parts: [],
            timestamp: Date.now(),
            senderId: 'user_me',
            deliveryData: {
                productId: item.id,
                productName: item.name,
                productImage: item.imageUrl,
                price: item.price,
                quantity: 1, // è´­ç‰©è½¦å•†å“é»˜è®¤ä¸º1
                style: 'é»˜è®¤æ¬¾å¼',
                eta: Date.now() + deliveryMinutes * 60 * 1000,
                delivered: false
            }
        };
        recipient.history.push(deliveryMessage);
    });
}
// --- æ–°å¢ç»“æŸ ---
                // æ”¯ä»˜æˆåŠŸï¼Œå°†å•†å“æ·»åŠ åˆ°ç‰©æµ
                addItemsToLogistics(window.currentPurchaseItems, null); // null è¡¨ç¤ºæ˜¯ç”¨æˆ·è‡ªå·±ä¹°çš„
                
                // æ·»åŠ åˆ°å•†åŸä»˜æ¬¾è®°å½•
                if (!db.mallData.paymentHistory) db.mallData.paymentHistory = [];
                db.mallData.paymentHistory.unshift({
                    id: `pay_${Date.now()}`,
                    timestamp: Date.now(),
                    description: `è´­ç‰©è½¦ç»“ç®— (${window.currentPurchaseItems.length}ä»¶)`,
                    total: window.currentPurchaseTotal
                });

                // ä»è´­ç‰©è½¦ç§»é™¤å·²è´­å•†å“
                const purchasedIds = new Set(window.currentPurchaseItems.map(item => item.id));
                db.mallData.cart = db.mallData.cart.filter(item => !purchasedIds.has(item.productId));
                selectedCartItemIds.clear();

                await saveData();
                showToast('æ”¯ä»˜æˆåŠŸï¼å¯åœ¨â€œæˆ‘çš„ç‰©æµâ€ä¸­æŸ¥çœ‹');
                switchScreen('mall-cart-screen');
                renderCart();

            } catch (error) {
                showToast(error.message);
            }
        }
    });
    
    // æ”¯ä»˜æ–¹å¼é€‰æ‹©
    document.querySelector('.payment-methods').addEventListener('click', (e) => {
        const methodItem = e.target.closest('.method-item');
        if (methodItem) {
            document.querySelectorAll('.payment-methods .method-item').forEach(el => el.classList.remove('selected'));
            methodItem.classList.add('selected');
            document.getElementById('confirm-final-payment-btn').textContent = methodItem.id === 'pay-for-me-btn' ? 'é€‰æ‹©å¥½å‹' : 'ç¡®è®¤æ”¯ä»˜';
        }
    });

    // ä»£ä»˜å¥½å‹é€‰æ‹©åˆ—è¡¨ç‚¹å‡»äº‹ä»¶
    document.getElementById('pay-for-me-selection-list').addEventListener('click', async (e) => {
        const item = e.target.closest('.list-item');
        if (item && item.dataset.charId) {
            const charId = item.dataset.charId;
            await sendPaymentRequestCard(charId, window.currentPurchaseItems, window.currentPurchaseTotal);
            document.getElementById('pay-for-me-select-modal').classList.remove('visible');
            showToast(`å·²å‘ ${db.characters.find(c=>c.id === charId).remarkName} å‘é€ä»£ä»˜è¯·æ±‚`);
            switchScreen('chat-list-screen'); // ç›´æ¥è·³è½¬åˆ°èŠå¤©åˆ—è¡¨ï¼Œè®©ç”¨æˆ·çœ‹åˆ°å¡ç‰‡
        }
    });

    document.getElementById('cancel-pay-for-me-btn').addEventListener('click', () => {
        document.getElementById('pay-for-me-select-modal').classList.remove('visible');
    });

        // --- å•†å“è¯¦æƒ…é¡µåº•éƒ¨æŒ‰é’®çš„äº‹ä»¶å§”æ‰˜ ---
    const detailFooterNav = document.getElementById('detail-footer-nav');
    if (detailFooterNav) {
        detailFooterNav.addEventListener('click', (e) => {
            const btn = e.target.closest('.action-btn');
            if (!btn) return;
            
            const detailScreen = document.getElementById('product-detail-screen');
            const currentProductId = detailScreen.dataset.productId;
            if (!currentProductId) return;

            const btnText = btn.textContent;
            if (btnText.includes('è´­ä¹°')) {
                openPurchaseModal(currentProductId);
            } else if (btnText.includes('è´­ç‰©è½¦')) {
                addToCart(currentProductId);
            } else if (btnText.includes('æ”¶è—')) {
                toggleProductLike(currentProductId);
            } else if (btnText.includes('ä»£ä»˜')) {
                handlePayForMeRequest(currentProductId);
            }
        });
    }
        // --- è´­ä¹°æµç¨‹ä¸­å„ä¸ªå¼¹çª—æŒ‰é’®çš„äº‹ä»¶ç»‘å®š ---
    const confirmRecipientBtn = document.getElementById('confirm-recipient-btn');
    if (confirmRecipientBtn) confirmRecipientBtn.addEventListener('click', handleRecipientConfirmation);

    const increaseQuantityBtn = document.getElementById('increase-quantity-btn');
    if (increaseQuantityBtn) increaseQuantityBtn.addEventListener('click', () => updateQuantity(1));
    
    const decreaseQuantityBtn = document.getElementById('decrease-quantity-btn');
    if (decreaseQuantityBtn) decreaseQuantityBtn.addEventListener('click', () => updateQuantity(-1));

    const styleOptionsContainer = document.getElementById('style-options-container');
    if (styleOptionsContainer) {
        styleOptionsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('style-option-btn')) {
                document.querySelectorAll('.style-option-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
            }
        });
    }
    
    const confirmPurchaseBtn = document.getElementById('confirm-purchase-btn');
    if (confirmPurchaseBtn) confirmPurchaseBtn.addEventListener('click', handleFinalPurchaseConfirmation);
    
    const confirmDeliveryTimeBtn = document.getElementById('confirm-delivery-time-btn');
    if (confirmDeliveryTimeBtn) confirmDeliveryTimeBtn.addEventListener('click', completePurchase);

    document.querySelectorAll('.close-purchase-modal-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const modal = e.target.closest('.modal-overlay');
            if (modal.id === 'purchase-modal') {
                const productId = modal.dataset.productId;
                if (productId && confirm('è¦å°†è¿™ä¸ªå®è´åŠ å…¥è´­ç‰©è½¦å—ï¼Ÿ')) {
                    addToCart(productId, true);
                }
            }
            modal.classList.remove('visible');
        });
    });

    const cartItemList = document.getElementById('cart-item-list');
    if(cartItemList) {
        cartItemList.addEventListener('click', e => {
            if(e.target.classList.contains('to-pay-btn')) {
                openPurchaseModal(e.target.dataset.productId);
            }
        });
    }
    document.querySelectorAll('.mall-bottom-nav').forEach(nav => {
    nav.addEventListener('click', (e) => {
        const navItem = e.target.closest('.nav-item[data-target]');
        if (navItem) {
            const targetScreenId = navItem.dataset.target;
            // å¦‚æœæ˜¯ç‚¹å‡»è´­ç‰©è½¦æˆ–ä¸ªäººä¸­å¿ƒï¼Œå…ˆæ¸²æŸ“å¯¹åº”å†…å®¹
            if (targetScreenId === "mall-cart-screen") renderCart();
            if (targetScreenId === "mall-profile-screen") renderLikedProducts();
            renderPaymentHistory();
            // ...
        }
    });
});
    // --- å…¶ä»–é€šç”¨äº‹ä»¶ç»‘å®š (ä¿æŒä¸å˜) ---
    document.querySelectorAll('.mall-bottom-nav').forEach(nav => {
        nav.addEventListener('click', (e) => {
            const navItem = e.target.closest('.nav-item[data-target]');
            if (navItem) {
                const targetScreenId = navItem.dataset.target;
                // å¦‚æœæ˜¯ç‚¹å‡»è´­ç‰©è½¦æˆ–ä¸ªäººä¸­å¿ƒï¼Œå…ˆæ¸²æŸ“å¯¹åº”å†…å®¹
                if (targetScreenId === "mall-cart-screen") renderCart();
                if (targetScreenId === "mall-profile-screen") renderLikedProducts();
                renderPaymentHistory(); 
                switchScreen(targetScreenId);
                nav.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
                navItem.classList.add('active');
            }
        });
    });

    const mallAppIcon = document.querySelector('.app-icon[data-target="mall-screen"]');
    if (mallAppIcon) {
        mallAppIcon.addEventListener('click', () => {
            if (db.mallData.products.length === 0) {
                generateAndRenderProducts(false);
            } else {
                renderMallProducts();
            }
        });
    }

    const productGrid = document.getElementById('product-grid');
    if (productGrid) {
        productGrid.addEventListener('click', (e) => {
            const card = e.target.closest('.product-card');
            if (card && card.dataset.productId) {
                document.getElementById('product-detail-screen').dataset.productId = card.dataset.productId;
                openProductDetail(card.dataset.productId);
            }
        });
    }
    
    
    // --- å•†åŸAPIè®¾ç½®é€»è¾‘ ---
    const mallApiForm = document.getElementById('mall-api-form');
    if(mallApiForm) {
        const mallFetchBtn = document.getElementById('mall-fetch-models-btn');
        const mallApiUrl = document.getElementById('mall-api-url');
        const mallApiKey = document.getElementById('mall-api-key');
        const mallApiModel = document.getElementById('mall-api-model');
const specialItemsToggle = document.getElementById('special-items-toggle');
        mallApiUrl.value = db.mallData.api.url || '';
        specialItemsToggle.checked = db.mallData.api.specialItemsEnabled || false;
        mallApiKey.value = db.mallData.api.key || '';
        if (db.mallData.api.model) {
            mallApiModel.innerHTML = `<option value="${db.mallData.api.model}">${db.mallData.api.model}</option>`;
        }
        
        mallFetchBtn.addEventListener('click', async () => {
            const url = mallApiUrl.value.trim();
            const key = mallApiKey.value.trim();
            if (!url || !key) return showToast('è¯·å¡«å†™APIåœ°å€å’Œå¯†é’¥');
            const endpoint = `${url.replace(/\/$/, '')}/v1/models`;
            mallFetchBtn.classList.add('loading');
            try {
                const response = await fetch(endpoint, { headers: { 'Authorization': `Bearer ${key}` } });
                if (!response.ok) throw new Error(`ç½‘ç»œé”™è¯¯: ${response.status}`);
                const data = await response.json();
                mallApiModel.innerHTML = data.data.map(m => `<option value="${m.id}">${m.id}</option>`).join('');
                showToast('æ¨¡å‹åˆ—è¡¨æ‹‰å–æˆåŠŸ');
            } catch (error) {
                showToast(`æ‹‰å–å¤±è´¥: ${error.message}`);
            } finally {
                mallFetchBtn.classList.remove('loading');
            }
        });

        mallApiForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    // *** FIX: Save all settings into the api object correctly ***
    db.mallData.api = {
        url: mallApiUrl.value,
        key: mallApiKey.value,
        model: mallApiModel.value,
        specialItemsEnabled: specialItemsToggle.checked
    };
    await saveData();
    showToast('å•†åŸAPIè®¾ç½®å·²ä¿å­˜ï¼');
});
}
}

// åœ¨ setupMallApp å‡½æ•°çš„æœ«å°¾æ·»åŠ 
// ç‰©æµé¡µé¢æ¸²æŸ“
function renderLogistics() {
    const container = document.getElementById('logistics-list-container');
    const placeholder = document.getElementById('no-logistics-placeholder');
    const logistics = db.mallData.logistics || [];

    if (logistics.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }
    placeholder.style.display = 'none';
    container.innerHTML = '';

    logistics.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'logistics-item';
        itemEl.innerHTML = `
            <div class="logistics-header">
                <span>è®¢å•å·: ${item.orderId.slice(-8)}</span>
                <span class="logistics-status">${item.status}</span>
            </div>
            <div class="logistics-body">
                <img src="${item.productImage}" alt="${item.productName}">
                <div class="logistics-info">
                    <p class="item-name">${item.productName}</p>
                    <p class="eta" data-countdown-type="delivery" data-eta="${item.eta}">æ­£åœ¨è®¡ç®—é€è¾¾æ—¶é—´...</p>
                    <p class="recipient-info" style="font-size: 12px; color: #888;">æ”¶ä»¶äºº: ${item.recipientName}</p>
                </div>
            </div>
        `;
        container.appendChild(itemEl);
    });
}

// ç‰©æµé¡µé¢å¯¼èˆª
document.querySelector('.wallet-action-item[data-target="logistics-screen"]').addEventListener('click', () => {
    renderLogistics();
    switchScreen('logistics-screen');
});
// â–¼â–¼â–¼ å°†è¿™ä¸ªæ–°å‡½æ•°æ·»åŠ åˆ° setupMallApp å‡½æ•°å†…éƒ¨ â–¼â–¼â–¼
// â–¼â–¼â–¼ å°†ä»¥ä¸‹æ‰€æœ‰æ–°å‡½æ•°ï¼Œæ·»åŠ åˆ° setupMallApp å‡½æ•°çš„å†…éƒ¨ â–¼â–¼â–¼

/**
 * [å·²ä¿®å¤] å°†å•†å“æ·»åŠ åˆ°ç‰©æµåˆ—è¡¨çš„å‡½æ•°ï¼Œå¢åŠ äº†é€è¾¾æ—¶é—´å‚æ•°
 * @param {Array} items - å•†å“å¯¹è±¡æ•°ç»„
 * @param {string|null} purchasedByAiId - å¦‚æœæ˜¯AIä»£ä»˜ï¼Œåˆ™ä¼ å…¥AIçš„ID
 * @param {number} deliveryMinutes - è‡ªå®šä¹‰çš„é€è¾¾åˆ†é’Ÿæ•°
 */
function addItemsToLogistics(items, purchasedByAiId = null, deliveryMinutes = 5) {
    if (!db.mallData.logistics) db.mallData.logistics = [];

    // ç¡®å®šæ”¶ä»¶äººä¿¡æ¯
    let recipientId, recipientName;
    if (purchasedByAiId) {
        // å¦‚æœæ˜¯AIä»£ä»˜ï¼Œæ”¶ä»¶äººæ˜¯â€œæˆ‘â€
        const anyCharacter = db.characters[0];
        recipientName = anyCharacter ? anyCharacter.myName : 'æˆ‘';
    } else {
        // å¦‚æœæ˜¯ç”¨æˆ·è‡ªå·±è´­ä¹°ï¼Œæ ¹æ®é€‰æ‹©ç¡®å®šæ”¶ä»¶äºº
        recipientId = purchaseState.recipientId;
        const recipientChar = db.characters.find(c => c.id === recipientId);
        recipientName = recipientChar ? recipientChar.remarkName : 'æœªçŸ¥æ”¶ä»¶äºº';
    }

    items.forEach(item => {
        db.mallData.logistics.unshift({
            orderId: `order_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,
            productId: item.id,
            productName: item.name,
            productImage: item.imageUrl,
            purchasedByAiId: purchasedByAiId, // è®°å½•æ˜¯è°ä»˜çš„æ¬¾
            recipientName: recipientName,
            // --- æ ¸å¿ƒä¿®å¤ 3ï¼šä½¿ç”¨ä¼ å…¥çš„ deliveryMinutes å‚æ•°è®¡ç®—é€è¾¾æ—¶é—´ ---
            eta: Date.now() + deliveryMinutes * 60 * 1000,
            status: 'å¾…å‘è´§'
        });
    });
}
/**
 * å‘AIå‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡
 */
async function sendPaymentRequestCard(charId, items, total) {
    const character = db.characters.find(c => c.id === charId);
    if (!character) return;

    const message = {
        id: `msg_pay_req_${Date.now()}`,
        role: 'user',
        content: `[æˆ‘å‘ ${character.remarkName} å‘èµ·ä»£ä»˜è¯·æ±‚]`,
        parts: [],
        timestamp: Date.now(),
        paymentRequestData: {
            status: 'pending',
            amount: total,
            items: items.map(item => ({ id: item.id, name: item.name, imageUrl: item.imageUrl })),
            requesterName: character.myName
        }
    };
    character.history.push(message);
    await saveData();
}

/**
 * å¤„ç†AIçš„ä»£ä»˜å†³å®šï¼ˆåŒæ„æˆ–æ‹’ç»ï¼‰
 */
/**
/**
 * [V3.0 | æœ€ç»ˆä¿®æ­£ç‰ˆ] å¤„ç†AIçš„ä»£ä»˜å†³å®šï¼Œå¹¶è®©AIæ ¹æ®äººè®¾ç”Ÿæˆç¬¦åˆæƒ…å¢ƒçš„å›å¤ã€‚
 */
async function handleAiPaymentDecision(messageId, decision) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    const message = character.history.find(m => m.id === messageId);
    if (!message || !message.paymentRequestData) return;

    // 1. åœ¨æ•°æ®ä¸­æ›´æ–°å¡ç‰‡çŠ¶æ€
    message.paymentRequestData.status = decision;

    // --- æ ¸å¿ƒä¿®å¤ï¼šç«‹å³ä¿å­˜æ•°æ®å¹¶åˆ·æ–°æ•´ä¸ªèŠå¤©ç•Œé¢ ---
    // è¿™ä¸€æ­¥ä¼šç«‹åˆ»å°†å¡ç‰‡çŠ¶æ€ä»â€œç­‰å¾…ä»˜æ¬¾â€æ›´æ–°ä¸ºâ€œå·²æ”¯ä»˜â€æˆ–â€œå·²æ‹’ç»â€
    await saveData();
    renderMessages(false, true); 
    // --- ä¿®å¤ç»“æŸ ---

    let contextMessageContent = ''; // è¿™æ˜¯æˆ‘ä»¬å°†è¦å‘ç»™AIçš„â€œç³»ç»ŸæŒ‡ä»¤â€

    if (decision === 'paid') {
        // (è¿™éƒ¨åˆ†é€»è¾‘ä¿æŒä¸å˜ï¼šå¤„ç†ç‰©æµå’Œé¡¶éƒ¨é€šçŸ¥)
        addItemsToLogistics(message.paymentRequestData.items, character.id);
        const notifText = `<strong>${character.remarkName}</strong> å·²ä¸ºä½ æ”¯ä»˜äº† ${message.paymentRequestData.items.length} ä»¶å•†å“ã€‚`;
        addNotificationToQueue({
            avatar: character.avatar,
            text: notifText,
            chatId: character.id,
            type: 'private'
        });
        
        // åˆ›å»ºä¸€æ¡å¼•å¯¼AIå›å¤çš„æŒ‡ä»¤
        contextMessageContent = `[system: ä½ åˆšåˆšåŒæ„å¹¶æ”¯ä»˜äº† ${character.myName} çš„ä»£ä»˜è¯·æ±‚ã€‚è¯·åœ¨èŠå¤©ä¸­å‘ŠçŸ¥å¯¹æ–¹ä½ å·²ç»ä»˜æ¬¾äº†ï¼Œå¹¶æ ¹æ®ä½ çš„äººè®¾è¯´äº›ä»€ä¹ˆï¼ˆä¾‹å¦‚ï¼Œå¯ä»¥è¡¨ç°å¾—å¾ˆå¤§æ–¹ã€æˆ–è€…è°ƒä¾ƒä¸€ä¸‹è¿™æ¬¡æ¶ˆè´¹ã€æˆ–è€…æŠ±æ€¨è‡ªå·±åˆç ´è´¹äº†ç­‰ç­‰ï¼‰ã€‚]`;

    } else { // å¦‚æœAIæ‹’ç» (è¿™éƒ¨åˆ†é€»è¾‘ä¿æŒä¸å˜)
        contextMessageContent = `[system: ä½ åˆšåˆšæ‹’ç»äº† ${character.myName} çš„ä»£ä»˜è¯·æ±‚ã€‚è¯·åœ¨èŠå¤©ä¸­å‘ŠçŸ¥å¯¹æ–¹ä½ æ‹’ç»çš„åŸå› ã€‚]`;
    }

    // 2. å°†è¿™æ¡â€œç³»ç»ŸæŒ‡ä»¤â€ä½œä¸ºä¸€æ¡ç”¨æˆ·æ¶ˆæ¯å‘é€ç»™AI
    const contextMessage = {
        id: `msg_pay_resp_${Date.now()}`,
        role: 'user',
        content: contextMessageContent,
        parts: [{ type: 'text', text: contextMessageContent }],
        timestamp: Date.now()
    };
    character.history.push(contextMessage);
    
    // 3. å†æ¬¡ä¿å­˜ï¼Œç¡®ä¿æŒ‡ä»¤è¢«è®°å½•
    await saveData();

    // 4. è§¦å‘AIï¼Œè®©å®ƒæ ¹æ®ä¸Šé¢çš„æŒ‡ä»¤ç”Ÿæˆå›å¤ (æ— éœ€ç­‰å¾…ï¼Œè®©å®ƒåœ¨åå°è¿è¡Œ)
    getAiReply();
}
/**
 * æ¸²æŸ“ç‰©æµåˆ—è¡¨é¡µé¢
 */
function renderLogistics() {
    const container = document.getElementById('logistics-list-container');
    const placeholder = document.getElementById('no-logistics-placeholder');
    const logistics = db.mallData.logistics || [];

    if (logistics.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }
    placeholder.style.display = 'none';
    container.innerHTML = '';

    logistics.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'logistics-item';
        itemEl.innerHTML = `
            <div class="logistics-header">
                <span>è®¢å•å·: ${item.orderId.slice(-8)}</span>
                <span class="logistics-status">${item.status}</span>
            </div>
            <div class="logistics-body">
                <img src="${item.productImage}" alt="${item.productName}">
                <div class="logistics-info">
                    <p class="item-name">${item.productName}</p>
                    <p class="eta" data-countdown-type="delivery" data-eta="${item.eta}">æ­£åœ¨è®¡ç®—é€è¾¾æ—¶é—´...</p>
                    <p class="recipient-info">æ”¶ä»¶äºº: ${item.recipientName}</p>
                </div>
            </div>
        `;
        container.appendChild(itemEl);
    });
}
async function callMallApi(messages) {
    const mallApi = db.mallData.api;
    const mainApi = db.apiSettings;
    let apiToUse = (mallApi && mallApi.url && mallApi.key && mallApi.model) ? mallApi : mainApi;
    if (!apiToUse || !apiToUse.url || !apiToUse.key || !apiToUse.model) {
        throw new Error('å•†åŸåŠŸèƒ½æœªæ‰¾åˆ°æœ‰æ•ˆçš„APIé…ç½®ã€‚');
    }
    return callAiApi(messages, apiToUse);
}

// === [V2] æ›¿æ¢æ—§çš„ generateAndRenderProducts å‡½æ•° ===
async function generateAndRenderProducts(append = false) {
    if (isGeneratingProducts) return;
    isGeneratingProducts = true;
    const grid = document.getElementById('product-grid');
    const loadIndicator = document.getElementById('load-more-indicator');
    const refreshBtnIcon = document.querySelector('#refresh-mall-btn svg');
    
    if (append) {
        if(loadIndicator) loadIndicator.classList.add('loading');
    } else {
        if(grid) grid.innerHTML = `<p class="placeholder-text">æ­£åœ¨ä¸ºæ‚¨å‘ç°å¥½ç‰©...</p>`;
        if (refreshBtnIcon) refreshBtnIcon.classList.add('rotating');
    }

    try {
        let prompt;
        const isSpecialMode = db.mallData.api.specialItemsEnabled;

        if (isSpecialMode) {
            // --- æ ¸å¿ƒä¿®æ”¹åœ¨æ­¤ ---
            prompt = `ä½ æ˜¯ä¸€ä¸ªå”®å–å¥‡å¹»ç‰¹æ®Šç‰©å“çš„åˆ›æ„åº—ä¸»ã€‚
é‡è¦å‰æï¼šè¿™äº›å•†å“éƒ½å°†ç”±ç”¨æˆ·(â€œæˆ‘â€)è´­ä¹°ï¼Œå¹¶å¯¹èŠå¤©ä¸­çš„AIè§’è‰²(â€œæ”¶ä»¶äººâ€)ä½¿ç”¨ã€‚å› æ­¤ï¼Œæ‰€æœ‰å•†å“çš„'åŠŸèƒ½'éƒ½å¿…é¡»æ˜¯èƒ½å¤Ÿåœ¨**æ–‡å­—å¯¹è¯ä¸­è¢«æ˜ç¡®è§‚å¯Ÿå’Œæ‰®æ¼”å‡ºæ¥**çš„æ•ˆæœã€‚

è¯·ä½ ç«‹å³åˆ›é€ å¹¶ä¸Šæ¶ 10ä»¶ ç‹¬ä¸€æ— äºŒçš„ç‰¹æ®Šå•†å“ã€‚
è§„åˆ™:
1.  **æè¿°å¿…é¡»æ¸…æ™°**: å•†å“çš„ "description" å¿…é¡»æ˜ç¡®åŒ…å« "åŠŸèƒ½ï¼š" (æè¿°ä¸€ä¸ªèƒ½**ç›´æ¥æ”¹å˜æ”¶ä»¶äººèŠå¤©è¡Œä¸º**çš„æ•ˆæœ)ã€"æ•ˆæœæŒç»­ï¼š" (å•ä½ä¸ºâ€œè½®å¯¹è¯â€)ã€"å‰¯ä½œç”¨ï¼š" å’Œ "å‰¯ä½œç”¨æŒç»­ï¼š" (å•ä½ä¸ºâ€œè½®å¯¹è¯â€) è¿™å››ä¸ªéƒ¨åˆ†ã€‚
2.  **ä»·æ ¼ä¸å‰¯ä½œç”¨**: ä»·æ ¼è¶Šé«˜çš„ç‰©å“ï¼Œå‰¯ä½œç”¨åº”è¯¥è¶Šå°æˆ–æŒç»­æ—¶é—´è¶ŠçŸ­ã€‚ä»·æ ¼èŒƒå›´åœ¨10åˆ°5000ä¹‹é—´ã€‚
3.  **åˆ›æ„ç¤ºä¾‹ (å¿…é¡»å‚è€ƒ)**:
    - **æ”¹å˜è¡Œä¸º**: 'å®³ç¾å–·é›¾ (åŠŸèƒ½ï¼šè®©æ”¶ä»¶äººå˜å¾—éå¸¸å®³ç¾å’Œå†…å‘ï¼Œè¯´è¯å°å¿ƒç¿¼ç¿¼ã€‚æ•ˆæœæŒç»­ï¼š10è½®å¯¹è¯ã€‚å‰¯ä½œç”¨ï¼šæ— ã€‚)'
    - **æ”¹å˜è¯´è¯æ–¹å¼**: 'è¯šå®è±†æ²™åŒ… (åŠŸèƒ½ï¼šè®©æ”¶ä»¶äººåœ¨æ¥ä¸‹æ¥çš„å¯¹è¯ä¸­åªèƒ½è¯´çœŸè¯ã€‚æ•ˆæœæŒç»­ï¼š3è½®å¯¹è¯ã€‚å‰¯ä½œç”¨ï¼šæ•ˆæœç»“æŸåä¼šå¤´ç—›ï¼Œå¹¶åœ¨å¯¹è¯ä¸­æŠ±æ€¨ã€‚å‰¯ä½œç”¨æŒç»­ï¼š5è½®å¯¹è¯ã€‚)'
    - **æ”¹å˜è®¤çŸ¥**: 'å¤±å¿†æ©¡çš®æ“¦ (åŠŸèƒ½ï¼šè®©æ”¶ä»¶äººæš‚æ—¶å¿˜è®°â€œæˆ‘â€æ˜¯è°ã€‚æ•ˆæœæŒç»­ï¼š5è½®å¯¹è¯ã€‚å‰¯ä½œç”¨ï¼šæ¢å¤è®°å¿†åä¼šå¯¹ä¹‹å‰çš„å¯¹è¯æ„Ÿåˆ°å›°æƒ‘ã€‚å‰¯ä½œç”¨æŒç»­ï¼š2è½®å¯¹è¯ã€‚)'
4.  **ä¸¥æ ¼æ ¼å¼**: ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ•°ç»„æ ¼å¼ [ {å•†å“1}, {å•†å“2}, ... ]ï¼Œä¸è¦æœ‰ä»»ä½•é¢å¤–æ–‡å­—ã€‚

æ¯ä¸ªå•†å“å¯¹è±¡çš„JSONæ ¼å¼å¦‚ä¸‹:
{
  "name": "ä¸€ä¸ªæå…·åˆ›æ„çš„ã€èƒ½å½±å“èŠå¤©å¯¹è±¡çš„ç‰©å“åç§°",
  "description": "ä¸€æ®µåŒ…å«'åŠŸèƒ½'ã€'æ•ˆæœæŒç»­'ã€'å‰¯ä½œç”¨'å’Œ'å‰¯ä½œç”¨æŒç»­'çš„æè¿°",
  "price": [ä¸€ä¸ª10åˆ°5000ä¹‹é—´çš„éšæœºæ•°å­—],
  "storeName": "ä¸‡èƒ½æ‚è´§é“ºãƒ»å¥‡ç‰©éƒ¨",
  "imagePrompt": "ä¸€ä¸ªç”¨äºAIç»˜ç”»çš„ã€æè¿°è¯¥å¥‡ç‰©çš„è‹±æ–‡å…³é”®è¯çŸ­è¯­"
}`;
            // --- ä¿®æ”¹ç»“æŸ ---
        } else {
            // è¿™æ˜¯åŸæ¥çš„æ™®é€šå•†å“æŒ‡ä»¤ (ä¿æŒä¸å˜)
            prompt = `ä½ æ˜¯ä¸€ä¸ªåˆ›æ„ç”µå•†ç­–åˆ’ã€‚è¯·æ¨¡ä»¿æ‹¼å¤šå¤šæˆ–æ·˜å®çš„é£æ ¼ï¼Œç”Ÿæˆ10ä¸ªè™šæ„çš„ã€æ–°æ½®æœ‰è¶£çš„å•†å“åˆ—è¡¨ã€‚å•†å“ç±»å‹è¦å¤šæ ·åŒ–ï¼Œå¿…é¡»åŒ…å«ç°ä»£æ—¶å°šç‰©å“ï¼ˆå¦‚è¡£æœã€åŒ…åŒ…ã€é¦–é¥°ï¼‰å’Œæ¥è‡ªä¸åŒå¹»æƒ³ä¸–ç•Œè§‚çš„ç‰¹æ®Šç‰©å“ã€‚ä¾‹å¦‚ï¼šABOä¸–ç•Œè§‚çš„é¡¶çº§æŠ‘åˆ¶å‰‚ã€æ— é™æµå‰¯æœ¬çš„ä¿å‘½é“å…·ã€ä¿®ä»™ä¸–ç•Œçš„ä¸¹è¯æ³•å®ã€èµ›åšæœ‹å…‹ä¹‰ä½“ç­‰ã€‚æ¯ä¸ªå•†å“éœ€åŒ…å«ï¼šä¸€ä¸ªå¸å¼•äººçš„'name'ï¼Œä¸€æ®µ50å­—å·¦å³çš„'description'ï¼Œä¸€ä¸ªéšæœºçš„'price' (10-1000ä¹‹é—´)ï¼Œä¸€ä¸ª'storeName'ï¼Œä»¥åŠä¸€ä¸ªç”¨äºAIç”Ÿå›¾çš„è‹±æ–‡'imagePrompt'ã€‚è¯·ä¸¥æ ¼ä»¥JSONæ•°ç»„æ ¼å¼è¿”å›ã€‚`;
        }

        const aiResponseText = await callMallApi([{ role: 'user', content: prompt }]);
        const productsData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
        const newProducts = productsData.map(p => ({ ...p, id: `prod_${Date.now()}_${Math.random()}`, imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(p.imagePrompt)}`, likes: Math.floor(Math.random() * 5000), saves: Math.floor(Math.random() * 8000), comments: [] }));
        
        if (append) {
            db.mallData.products.push(...newProducts);
            renderNewProducts(newProducts);
        } else {
            db.mallData.products = newProducts;
            renderMallProducts();
        }
        await saveData();
    } catch (error) {
        console.error("ç”Ÿæˆå•†å“å¤±è´¥:", error);
        if (!append && grid) {
            grid.innerHTML = `<p class="placeholder-text" style="color:red;">å•†å“åŠ è½½å¤±è´¥: ${error.message}</p>`;
        }
        showToast('å•†å“åŠ è½½å¤±è´¥');
    } finally {
        isGeneratingProducts = false;
        if (loadIndicator) loadIndicator.classList.remove('loading');
        if (refreshBtnIcon) refreshBtnIcon.classList.remove('rotating');
    }
}

function renderMallProducts(productsToRender) {
    const grid = document.getElementById('product-grid');
    if (!grid) return;

    grid.innerHTML = '';
    
    // 1. ä¼˜å…ˆæ¸²æŸ“ç”¨æˆ·è‡ªå®šä¹‰çš„å•†å“
    const customProducts = db.mallData.customProducts || [];
    if (customProducts.length > 0 && !productsToRender) { // ä»…åœ¨éæœç´¢æ¨¡å¼ä¸‹æ˜¾ç¤ºåˆ†ç±»
        const title = document.createElement('h3');
        title.textContent = 'ä¸ªæ€§å•†å“';
        title.style.cssText = "grid-column: 1 / -1; margin: 10px 0; color: #555;";
        grid.appendChild(title);
        customProducts.forEach(product => grid.appendChild(createProductCardElement(product)));
    }

    // 2. æ¸²æŸ“AIç”Ÿæˆçš„å•†å“
    const aiProducts = productsToRender || db.mallData.products;
    if (aiProducts.length > 0 && !productsToRender) {
        const title = document.createElement('h3');
        title.textContent = 'ä¸‡èƒ½æ‚è´§é“º';
        title.style.cssText = "grid-column: 1 / -1; margin: 20px 0 10px; color: #555;";
        grid.appendChild(title);
    }
    
    if (aiProducts.length > 0) {
        aiProducts.forEach(product => grid.appendChild(createProductCardElement(product)));
    }

    if (grid.innerHTML === '') {
        grid.innerHTML = `<p class="placeholder-text">ç©ºç©ºå¦‚ä¹Ÿ...</p>`;
    }
}

function renderNewProducts(newProducts) {
    const grid = document.getElementById('product-grid');
    if(grid) {
        newProducts.forEach(product => grid.appendChild(createProductCardElement(product)));
    }
}

function createProductCardElement(product) {
    const card = document.createElement('div');
    card.className = 'product-card';
    card.dataset.productId = product.id;
    card.innerHTML = `
        <img src="${product.imageUrl}" alt="${product.name}" class="product-image">
        <div class="product-info">
            <p class="product-title">${product.name}</p>
            <div class="product-price-row">
                <span class="product-price">${product.price.toFixed(2)}</span>
                <span class="product-sales">å·²å”®${product.sales || Math.floor(Math.random()*1000)+'+'}</span>
            </div>
        </div>`;
    return card;
}

function openProductDetail(productId) {
    const product = findProductById(productId);
    if (!product) return;
    document.getElementById('detail-product-image').src = product.imageUrl;
    document.getElementById('detail-product-price').textContent = `Â¥${product.price.toFixed(2)}`;
    document.getElementById('detail-product-likes').textContent = `â¤ï¸ ${product.likes}`;
    document.getElementById('detail-product-saves').textContent = `â­ ${product.saves}`;
    document.getElementById('detail-product-title').textContent = product.name;
    document.getElementById('detail-product-description').textContent = product.description;
    document.getElementById('detail-store-name').textContent = product.storeName;
    updateLikeButtonState(productId);
    renderComments(productId);
    const loadMoreBtn = document.getElementById('load-more-comments-btn');
    if (loadMoreBtn) loadMoreBtn.onclick = () => generateAndRenderComments(productId);
    switchScreen('product-detail-screen');
}

function renderComments(productId) {
    const product = findProductById(productId);
    const list = document.getElementById('comment-list');
    if(!list) return;
    list.innerHTML = '';
    if (!product || !product.comments || product.comments.length === 0) {
        list.innerHTML = `<li class="placeholder-text" style="padding: 20px 0;">æš‚æ— è¯„ä»·ï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ç”Ÿæˆå§ï¼</li>`;
        return;
    }
    product.comments.forEach(comment => {
        const item = document.createElement('li');
        item.className = 'comment-item';
        item.innerHTML = `<div class="comment-header"><img src="${comment.avatar}" class="comment-avatar"><span class="comment-author">${comment.author}</span></div><p class="comment-text">${comment.text}</p>${comment.sellerReply ? `<div class="seller-reply">${comment.sellerReply}</div>` : ''}`;
        list.appendChild(item);
    });
}

async function generateAndRenderComments(productId) {
    const product = findProductById(productId);
    if (!product) return;
    const loadMoreBtn = document.getElementById('load-more-comments-btn');
    loadMoreBtn.textContent = 'ç”Ÿæˆä¸­...';
    loadMoreBtn.disabled = true;
    try {
        const prompt = `ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºä¸“å®¶ã€‚è¯·ä¸ºä»¥ä¸‹å•†å“ç”Ÿæˆ5æ¡æ–°æ½®ã€çœŸå®çš„ä¹°å®¶è¯„è®ºã€‚è¯„è®ºè¦ä½¿ç”¨ç½‘ç»œçƒ­æ¢—ã€æ½®æµç”¨è¯­å’Œemojiï¼Œé£æ ¼è¦å¤šæ ·åŒ–ã€‚åŒæ—¶ï¼Œä¸ºæ¯æ¡è¯„è®ºç”Ÿæˆä¸€å¥å•†å®¶çš„å›å¤ã€‚å•†å“ä¿¡æ¯ï¼š\nåç§°: ${product.name}\næè¿°: ${product.description}\nè¯·ä¸¥æ ¼ä»¥JSONæ•°ç»„æ ¼å¼è¿”å›ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å« 'author', 'avatar'(ä½¿ç”¨ https://i.postimg.cc/ VL1g9G5V/store-avatar.png), 'text', 'sellerReply' å››ä¸ªå­—æ®µã€‚`;
        const aiResponseText = await callMallApi([{ role: 'user', content: prompt }]);
        const newComments = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
        product.comments.push(...newComments);
        await saveData();
        renderComments(productId);
        showToast('å·²åŠ è½½æ–°çš„è¯„è®ºï¼');
    } catch (error) {
        showToast(`ç”Ÿæˆè¯„è®ºå¤±è´¥: ${error.message}`);
    } finally {
        loadMoreBtn.textContent = 'åŠ è½½æ›´å¤šè¯„ä»·';
        loadMoreBtn.disabled = false;
    }
}

async function toggleProductLike(productId) {
    const likedIndex = db.mallData.likedProducts.indexOf(productId);
    if (likedIndex > -1) {
        db.mallData.likedProducts.splice(likedIndex, 1);
        showToast('å·²å–æ¶ˆç‚¹èµ');
    } else {
        db.mallData.likedProducts.push(productId);
        showToast('ç‚¹èµæˆåŠŸï¼');
    }
    await saveData();
    updateLikeButtonState(productId);
}

function updateLikeButtonState(productId) {
    const likeBtn = document.getElementById('like-product-btn');
    if (likeBtn) {
        likeBtn.classList.toggle('liked', db.mallData.likedProducts.includes(productId));
    }
}

function renderLikedProducts() {
    const grid = document.getElementById('liked-products-grid');
    const placeholder = document.getElementById('no-liked-products');
    if(!grid || !placeholder) return;
    grid.innerHTML = '';
    if (db.mallData.likedProducts.length === 0) {
        placeholder.style.display = 'block';
        return;
    }
    placeholder.style.display = 'none';
    [...db.mallData.likedProducts].reverse().forEach(productId => {
        const product = findProductById(productId);
        if (product) grid.appendChild(createProductCardElement(product));
    });
}

function enterLikesSelectionMode() {
    isLikesSelectionMode = true;
    document.getElementById('mall-profile-screen').classList.add('selection-mode-active');
    updateCheckoutBar();
}

function exitLikesSelectionMode() {
    isLikesSelectionMode = false;
    document.getElementById('mall-profile-screen').classList.remove('selection-mode-active');
    selectedLikedProductIds = [];
    document.querySelectorAll('#liked-products-grid .product-card.selected').forEach(el => el.classList.remove('selected'));
}

function toggleLikedProductSelection(productId) {
    const index = selectedLikedProductIds.indexOf(productId);
    if (index > -1) {
        selectedLikedProductIds.splice(index, 1);
    } else {
        selectedLikedProductIds.push(productId);
    }
    document.querySelector(`#liked-products-grid .product-card[data-product-id="${productId}"]`).classList.toggle('selected');
    updateCheckoutBar();
}

function updateCheckoutBar() {
    let totalPrice = 0;
    selectedLikedProductIds.forEach(id => {
        const product = db.mallData.products.find(p => p.id === id);
        if (product) totalPrice += product.price;
    });
    document.getElementById('likes-total-price').textContent = `æ€»è®¡: Â¥${totalPrice.toFixed(2)}`;
    document.getElementById('checkout-likes-btn').disabled = selectedLikedProductIds.length === 0;
}

function handleLikesCheckout() {
    purchaseState.multiItems = selectedLikedProductIds.map(id => db.mallData.products.find(p => p.id === id)).filter(Boolean);
    if (purchaseState.multiItems.length === 0) return showToast("è¯·è‡³å°‘é€‰æ‹©ä¸€ä»¶å•†å“");
    
    const modal = document.getElementById('purchase-modal');
    document.getElementById('purchase-product-image').src = 'https://i.postimg.cc/PqYkx23B/shop-icon.png';
    const totalPrice = purchaseState.multiItems.reduce((sum, item) => sum + item.price, 0);
    document.getElementById('purchase-product-price').textContent = `Â¥${totalPrice.toFixed(2)}`;
    document.getElementById('purchase-product-name').textContent = `${purchaseState.multiItems.length}ä»¶å•†å“`;
    renderRecipientList();
    modal.classList.add('visible');
}

async function addToCart(productId, silent = false) {
    if (!productId) return;

    // --- æ ¸å¿ƒä¿®æ”¹ï¼šåŒæ—¶æ£€æŸ¥AIå•†å“å’Œè‡ªå®šä¹‰å•†å“ ---
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];
    const productExists = allProducts.some(p => p.id === productId);
    
    if (!productExists) {
        if (!silent) showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¯¥å•†å“');
        return;
    }
    // --- ä¿®æ”¹ç»“æŸ ---

    const existingItem = db.mallData.cart.find(item => item.productId === productId);
    if (existingItem) {
        if (!silent) showToast('å®è´å·²åœ¨è´­ç‰©è½¦ä¸­');
        return;
    }
    db.mallData.cart.push({
        cartId: `cart_${Date.now()}`,
        productId: productId,
        paymentDeadline: Date.now() + 30 * 60 * 1000
    });
    await saveData();
    if (!silent) {
        showToast('å®è´å·²åŠ å…¥è´­ç‰©è½¦ï¼Œè¯·åœ¨30åˆ†é’Ÿå†…æ”¯ä»˜å“¦');
        renderCart();
        switchScreen('mall-cart-screen');
    }
}
function openPurchaseModal(productId) {
    const product = findProductById(productId); // ä½¿ç”¨è¿™ä¸ªè¾…åŠ©å‡½æ•°
    if (!product) {
        // å¦‚æœæ‰¾ä¸åˆ°å•†å“ï¼Œç»™å‡ºæ˜ç¡®æç¤ºå¹¶ä¸­æ­¢
        showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¯¥å•†å“ä¿¡æ¯ã€‚');
        return;
    }
    purchaseState = { productId, recipientId: null, quantity: 1, style: 'é»˜è®¤æ¬¾å¼', multiItems: [] };
    const modal = document.getElementById('purchase-modal');
    modal.dataset.productId = productId;
    modal.querySelector('h5').textContent = 'é€‰æ‹©æ”¶è´§äºº';
    document.getElementById('confirm-recipient-btn').textContent = 'ç¡®å®š';
    document.getElementById('purchase-product-image').src = product.imageUrl;
    document.getElementById('purchase-product-price').textContent = `Â¥${product.price.toFixed(2)}`;
    document.getElementById('purchase-product-name').textContent = product.name;
    renderRecipientList();
    modal.classList.add('visible');
}

function renderRecipientList() {
    const container = document.getElementById('recipient-selection-list');
    if(!container) return;
    container.innerHTML = '';
    db.characters.forEach(char => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.innerHTML = `<input type="radio" name="recipient" value="${char.id}" id="recipient-${char.id}"><label for="recipient-${char.id}" style="display:flex; align-items:center; width:100%; gap:10px;"><img src="${char.avatar}" class="chat-avatar"><div class="item-details"><div class="item-name">${char.remarkName}</div></div></label>`;
        container.appendChild(li);
    });
}

/**
 * [å·²ä¿®å¤] å¤„ç†æ”¶è´§äººç¡®è®¤ï¼Œå¹¶æ ¹æ®æµç¨‹åˆ†å‘åˆ°â€œæ‰¾äººä»£ä»˜â€æˆ–â€œè‡ªå·±è´­ä¹°â€
 */
async function handleRecipientConfirmation() {
    const selectedRecipient = document.querySelector('input[name="recipient"]:checked');
    if (!selectedRecipient) {
        showToast('è¯·é€‰æ‹©ä¸€ä¸ªæ”¶è´§äºº');
        return;
    }
    purchaseState.recipientId = selectedRecipient.value;
    const recipientChar = db.characters.find(c => c.id === purchaseState.recipientId);

    // å…³é—­é€‰æ‹©å¼¹çª—
    document.getElementById('purchase-modal').classList.remove('visible');

    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘ ---
    // åˆ¤æ–­æ˜¯å¦ä¸ºâ€œæ‰¾äººä»£ä»˜â€æµç¨‹
    if (purchaseState.isPayForMe) {
        // *** æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ findProductById æŸ¥æ‰¾å•†å“ ***
        const product = findProductById(purchaseState.productId);
        if (!product || !recipientChar) {
            showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°å•†å“æˆ–ä»£ä»˜äºº');
            return;
        }

        // è°ƒç”¨å‡½æ•°ï¼Œå‘AIå‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡
        await sendPaymentRequestCard(recipientChar.id, [product], product.price);

        showToast(`å·²å‘ ${recipientChar.remarkName} å‘é€ä»£ä»˜è¯·æ±‚`);
        
        // (å¯é€‰, ä½†å»ºè®®ä¿ç•™) è‡ªåŠ¨è·³è½¬åˆ°ä¸è¯¥AIçš„èŠå¤©ç•Œé¢
        currentChatId = recipientChar.id;
        currentChatType = 'private';
        openChatRoom(currentChatId, currentChatType);

    } else if (purchaseState.multiItems.length > 0) {
        // è¿™æ˜¯åŸæœ‰çš„é€»è¾‘ï¼šå¤„ç†ä»æ”¶è—å¤¹æˆ–è´­ç‰©è½¦å‘èµ·çš„â€œå¤šå•†å“ç»“ç®—â€
        document.getElementById('delivery-countdown-modal').classList.add('visible');
    } else {
        // è¿™æ˜¯åŸæœ‰çš„é€»è¾‘ï¼šå¤„ç†æ­£å¸¸çš„â€œå•å“è‡ªå·±è´­ä¹°â€æµç¨‹
        openOptionsModal();
    }
}
function openOptionsModal() {
	   const product = findProductById(purchaseState.productId);
    if (!product) { // å¢åŠ å®‰å…¨æ£€æŸ¥
        showToast("æ‰“å¼€å•†å“é€‰é¡¹å¤±è´¥ï¼šæ‰¾ä¸åˆ°å•†å“ã€‚");
        return;
    }
    const modal = document.getElementById('product-options-modal');
    modal.dataset.productId = purchaseState.productId;
    document.getElementById('options-product-image').src = product.imageUrl;
    document.getElementById('options-product-price').textContent = `Â¥${product.price.toFixed(2)}`;
    document.getElementById('options-product-name').textContent = product.name;
    document.getElementById('purchase-quantity-input').value = 1;
    modal.classList.add('visible');
}

function updateQuantity(amount) {
    const input = document.getElementById('purchase-quantity-input');
    let currentValue = parseInt(input.value, 10);
    currentValue += amount;
    if (currentValue < 1) currentValue = 1;
    input.value = currentValue;
}



// â–¼â–¼â–¼ ç”¨è¿™ä¸ªæ–°ç‰ˆæœ¬ï¼Œå®Œæ•´æ›¿æ¢æ–‡ä»¶ä¸­æ—§çš„ renderCart å‡½æ•° â–¼â–¼â–¼
function renderCart() {
    const container = document.getElementById('cart-item-list-container');
    if (!container) return;
    container.innerHTML = '';

    if (!db.mallData.cart || db.mallData.cart.length === 0) {
        container.innerHTML = '<p class="placeholder-text">è´­ç‰©è½¦æ˜¯ç©ºçš„å“¦ï¼Œå¿«å»é€›é€›å§~</p>';
        updateCartCheckoutBar();
        return;
    }

    // å°†AIå•†å“å’Œè‡ªå®šä¹‰å•†å“åˆå¹¶ï¼Œä»¥ä¾¿æŸ¥æ‰¾
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];

    // æŒ‰åº—é“ºå¯¹å•†å“è¿›è¡Œåˆ†ç»„
    const groupedByStore = db.mallData.cart.reduce((acc, cartItem) => {
        const product = allProducts.find(p => p.id === cartItem.productId);
        if (product) {
            const storeName = product.storeName || 'å®˜æ–¹æ——èˆ°åº—';
            if (!acc[storeName]) {
                acc[storeName] = [];
            }
            acc[storeName].push({ ...cartItem, product });
        }
        return acc;
    }, {});

    // æ¸²æŸ“æ¯ä¸ªåº—é“ºçš„å•†å“
    for (const storeName in groupedByStore) {
        const storeGroupEl = document.createElement('div');
        storeGroupEl.className = 'cart-store-group';

        const storeHeaderEl = document.createElement('div');
        storeHeaderEl.className = 'cart-store-header';
        storeHeaderEl.innerHTML = `<span>${storeName}</span>`;
        storeGroupEl.appendChild(storeHeaderEl);

        groupedByStore[storeName].forEach(item => {
            const isSelected = selectedCartItemIds.has(item.cartId);
            const itemEl = document.createElement('div');
            itemEl.className = `cart-item ${isSelected ? 'selected' : ''}`;
            itemEl.dataset.cartId = item.cartId;
            itemEl.innerHTML = `
                <div class="cart-item-selector"></div>
                <img src="${item.product.imageUrl}" class="cart-item-image">
                <div class="cart-item-details">
                    <p class="cart-item-title">${item.product.name}</p>
                    <p class="cart-item-price">Â¥${item.product.price.toFixed(2)}</p>
                </div>
            `;
            storeGroupEl.appendChild(itemEl);
        });
        container.appendChild(storeGroupEl);
    }
    
    updateCartCheckoutBar();
}
/**
 * [å·²ä¿®å¤] å¯åŠ¨ä¸€ä¸ªå…¨å±€å®šæ—¶å™¨æ¥ç®¡ç†æ‰€æœ‰å€’è®¡æ—¶æ˜¾ç¤º
 */
function startGlobalCountdownTimer() {
    if (globalCountdownInterval) clearInterval(globalCountdownInterval);

    globalCountdownInterval = setInterval(() => {
        document.querySelectorAll('[data-countdown-type]').forEach(async (el) => {
            const eta = parseInt(el.dataset.eta, 10);
            const remaining = eta - Date.now();
            
            if (remaining > 0) {
                const minutes = Math.floor((remaining / 1000 / 60) % 60).toString().padStart(2, '0');
                const seconds = Math.floor((remaining / 1000) % 60).toString().padStart(2, '0');
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                
                if (el.dataset.countdownType === 'cart') {
                    el.textContent = `æ”¯ä»˜å‰©ä½™ ${minutes}:${seconds}`;
                } else if (el.dataset.countdownType === 'delivery') {
                    el.textContent = `é¢„è®¡é€è¾¾: ${hours > 0 ? hours + 'å°æ—¶' : ''}${minutes}åˆ†${seconds}ç§’`;
                }
            } else {
                if (el.dataset.countdownType === 'cart') {
                    el.textContent = 'å·²å¤±æ•ˆ';
                } else if (el.dataset.countdownType === 'delivery') {
                    el.textContent = 'å·²é€è¾¾';
                    
                    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘å¼€å§‹ ---
                    // æŸ¥æ‰¾å½“å‰å€’è®¡æ—¶å…ƒç´ æ‰€åœ¨çš„æ•´ä¸ªç‰©æµé¡¹ç›®å¡ç‰‡
                    const logisticsItem = el.closest('.logistics-item');
                    if (logisticsItem) {
                        // åœ¨å¡ç‰‡å†…æ‰¾åˆ°é¡¶éƒ¨çš„çŠ¶æ€æ ‡ç­¾
                        const statusHeader = logisticsItem.querySelector('.logistics-status');
                        if (statusHeader) {
                            // å°†â€œå¾…å‘è´§â€æ›´æ–°ä¸ºâ€œå·²é€è¾¾â€
                            statusHeader.textContent = 'å·²é€è¾¾';
                        }
                    }
                    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘ç»“æŸ ---
                    
                    const messageWrapper = el.closest('.message-wrapper');
                    if (messageWrapper) {
                        await notifyAiOfDelivery(messageWrapper.dataset.id);
                        el.removeAttribute('data-countdown-type');
                    }
                }
            }
        });
    }, 1000);
}
/**
 * [V3.1 | å·²ä¿®å¤è‡ªå®šä¹‰å•†å“] å½“å€’è®¡æ—¶ç»“æŸåï¼Œé€šçŸ¥AIæ”¶è´§ï¼Œå¹¶æ¿€æ´»ç‰¹æ®Šç‰©å“æ•ˆæœ
 */
async function notifyAiOfDelivery(messageId) {
    for (const char of db.characters) {
        const message = char.history.find(m => m.id === messageId);
        if (message && message.deliveryData && !message.deliveryData.delivered) {
            
            message.deliveryData.delivered = true;

            // --- æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ findProductById æŸ¥æ‰¾æ‰€æœ‰å•†å“ ---
            const product = findProductById(message.deliveryData.productId);
            // --- ä¿®æ”¹ç»“æŸ ---

            let effectDescriptionForAI = `ä½ æ”¶åˆ°äº† ${char.myName} è´­ä¹°çš„ â€œ${message.deliveryData.productName}â€ã€‚`;

            if (product && product.description) {
                if (!char.activeEffects) char.activeEffects = [];

                if (product.description.includes('è§£é™¤') || product.description.includes('æ¢å¤')) {
                    if (product.description.includes('å£åƒ')) {
                        char.activeEffects = char.activeEffects.filter(eff => eff.type !== 'stutter');
                        showToast(`${char.remarkName} çš„å£åƒè¢«æ²»å¥½äº†ï¼`);
                        effectDescriptionForAI += ` è¿™ä¸ªç‰©å“è§£é™¤äº†ä½ èº«ä¸Šçš„â€œå£åƒâ€æ•ˆæœã€‚`;
                    }
                } else {
                    const funcMatch = product.description.match(/åŠŸèƒ½ï¼š(.*?)(?:æ•ˆæœæŒç»­|å‰¯ä½œç”¨|$)/);
                    const durationMatch = product.description.match(/æ•ˆæœæŒç»­ï¼š(\d+)è½®å¯¹è¯/);
                    const sideEffectMatch = product.description.match(/å‰¯ä½œç”¨ï¼š(.*?)(?:å‰¯ä½œç”¨æŒç»­|$)/);
                    const sideEffectDurationMatch = product.description.match(/å‰¯ä½œç”¨æŒç»­ï¼š(\d+)è½®å¯¹è¯/);

                    if (funcMatch && durationMatch) {
                        const effect = {
                            duration: parseInt(durationMatch[1], 10),
                            isSideEffect: false
                        };
                        const funcText = funcMatch[1].trim();
                        
                        effectDescriptionForAI += ` è¿™ä¸ªç‰©å“çš„æ•ˆæœæ˜¯ï¼šâ€œ${funcText}â€ï¼Œæ•ˆæœå°†æŒç»­ ${effect.duration} è½®å¯¹è¯ã€‚`;
                        if (sideEffectMatch) {
                             effectDescriptionForAI += ` å‰¯ä½œç”¨æ˜¯ï¼šâ€œ${sideEffectMatch[1].trim()}â€ã€‚`;
                        }

                        if (funcText.includes('äº¤æ¢äººè®¾') || funcText.includes('è§’è‰²äº’æ¢')) effect.type = 'role_swap';
                        else if (funcText.includes('åªèƒ½è¯´çœŸè¯')) effect.type = 'truth_only';
                        else if (funcText.includes('å®³ç¾') || funcText.includes('å†…å‘')) effect.type = 'shy';
                        else if (funcText.includes('å¤±å¿†')) effect.type = 'amnesia';
                        else if (funcText.includes('åŠ¨ç‰©åŒ–')) {
                            effect.type = 'animalization';
                            effect.animal = funcText.replace('åŠ¨ç‰©åŒ–', '').trim() || 'çŒ«';
                        }
                        
                        if (sideEffectMatch && sideEffectDurationMatch) {
                            const sideEffect = { duration: parseInt(sideEffectDurationMatch[1], 10) };
                            const sideEffectText = sideEffectMatch[1].trim();
                            if (sideEffectText.includes('å£åƒ')) sideEffect.type = 'stutter';
                            if (sideEffect.type) effect.sideEffect = sideEffect;
                        }
                        
                        if (effect.type) {
                            char.activeEffects.push(effect);
                            showToast(`${char.remarkName} ä½¿ç”¨äº†ç‰¹æ®Šç‰©å“ï¼`);
                        }
                    }
                }
            }
            
            const contextMessageContent = `[system: ${effectDescriptionForAI} è¯·æ ¹æ®ä½ çš„äººè®¾å¯¹æ­¤ä½œå‡ºå›åº”ï¼Œä½ çš„å›åº”è¦ä½“ç°å‡ºä½ å·²ç»å¼€å§‹å—åˆ°å½±å“ã€‚]`;
            
            const contextMessage = {
                id: `msg_delivery_receipt_${Date.now()}`,
                role: 'user',
                content: contextMessageContent,
                parts: [{ type: 'text', text: contextMessageContent }],
                timestamp: Date.now()
            };
            char.history.push(contextMessage);
            
            await saveData();
            
            if (currentChatId === char.id) {
                getAiReply();
            }
            
            break;
        }
    }
}

// --- æ–°å¢ï¼šä¸–ç•Œä¹¦åˆ†ç±»åŠŸèƒ½ ---
function setupWorldBookCategorySystem() {
    const addCategoryBtn = document.getElementById('add-world-book-category-btn');
    const addCategoryModal = document.getElementById('add-category-modal');
    const addCategoryForm = document.getElementById('add-category-form');
    const categoryNameInput = document.getElementById('category-name-input');
    const worldBookListContainer = document.getElementById('world-book-list-container');

    addCategoryBtn.addEventListener('click', () => {
        addCategoryForm.reset();
        addCategoryModal.classList.add('visible');
    });

    addCategoryForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const name = categoryNameInput.value.trim();
        if (name) {
            db.worldBookCategories.push({
                id: `cat_${Date.now()}`,
                name: name,
                isCollapsed: false
            });
            await saveData();
            renderWorldBookList();
            showToast(`åˆ†ç±»â€œ${name}â€å·²åˆ›å»º`);
            addCategoryModal.classList.remove('visible');
        }
    });

    // ä¿®æ”¹ï¼šåˆå¹¶å¤„ç†æ‰€æœ‰åˆ†ç±»çš„ç‚¹å‡»äº‹ä»¶
    worldBookListContainer.addEventListener('click', async (e) => {
        const categoryHeader = e.target.closest('.category-header');
        if (!categoryHeader) return;

        const categoryWrapper = categoryHeader.parentElement;
        const categoryId = categoryWrapper.dataset.id;
        
        if (categoryId === 'uncategorized') {
            // --- è¿™æ˜¯å¤„ç†â€œæœªåˆ†ç±»â€æŠ˜å çš„æ–°é€»è¾‘ ---
            db.uncategorizedCollapsed = !db.uncategorizedCollapsed;
            categoryWrapper.classList.toggle('collapsed', db.uncategorizedCollapsed);
            await saveData();
        } else {
            // è¿™æ˜¯å¤„ç†æ™®é€šåˆ†ç±»æŠ˜å çš„æ—§é€»è¾‘
            const category = db.worldBookCategories.find(cat => cat.id === categoryId);
            if (category) {
                category.isCollapsed = !category.isCollapsed;
                categoryWrapper.classList.toggle('collapsed', category.isCollapsed);
                await saveData();
            }
        }
    });
    
    // --- æ–°å¢ï¼šç»Ÿä¸€å¤„ç†é•¿æŒ‰/å³é”®èœå• ---
// ä½¿ç”¨è¿™æ®µæ–°ä»£ç æ›¿æ¢æ—§çš„ handleLongPress å‡½æ•°
const handleLongPress = (targetElement, clientX, clientY) => {
    const categoryId = targetElement.dataset.id;
    let menuItems = [];

    if (categoryId === 'uncategorized') {
        menuItems.push({
            label: 'åˆ é™¤æ­¤åˆ†ç±»ä¸­çš„æ‰€æœ‰æ¡ç›®',
            danger: true,
            action: async () => {
                if (confirm(`æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤â€œæœªåˆ†ç±»â€ä¸­çš„æ‰€æœ‰ä¸–ç•Œä¹¦æ¡ç›®ï¼Œç¡®å®šå—ï¼Ÿ`)) {
                    db.worldBooks = db.worldBooks.filter(book => book.categoryId !== 'uncategorized');
                    await saveData();
                    renderWorldBookList();
                    showToast('â€œæœªåˆ†ç±»â€æ¡ç›®å·²å…¨éƒ¨åˆ é™¤');
                }
            }
        });
    } else {
        const category = db.worldBookCategories.find(cat => cat.id === categoryId);
        if (category) {
             menuItems.push({
                label: 'åˆ é™¤åˆ†ç±»åŠå…¶ä¸­æ‰€æœ‰æ¡ç›®',
                danger: true,
                action: async () => {
                    const booksInCategoryCount = db.worldBooks.filter(book => book.categoryId === categoryId).length;
                    if (confirm(`æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤åˆ†ç±»â€œ${category.name}â€ä»¥åŠå…¶ä¸­çš„ ${booksInCategoryCount} ä¸ªæ¡ç›®ï¼Œæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`)) {
                        // è¿‡æ»¤æ‰å±äºè¯¥åˆ†ç±»çš„ä¸–ç•Œä¹¦æ¡ç›®
                        db.worldBooks = db.worldBooks.filter(book => book.categoryId !== categoryId);
                        
                        // è¿‡æ»¤æ‰è¯¥åˆ†ç±»æœ¬èº«
                        db.worldBookCategories = db.worldBookCategories.filter(cat => cat.id !== categoryId);
                        
                        await saveData();
                        renderWorldBookList();
                        showToast(`åˆ†ç±»â€œ${category.name}â€åŠå…¶å†…å®¹å·²åˆ é™¤`);
                    }
                }
            });
        }
    }
    if (menuItems.length > 0) {
        createContextMenu(menuItems, clientX, clientY);
    }
};
    
    worldBookListContainer.addEventListener('contextmenu', e => {
        const categoryWrapper = e.target.closest('.world-book-category');
        if (categoryWrapper) {
            e.preventDefault();
            handleLongPress(categoryWrapper, e.clientX, e.clientY);
        }
    });

    worldBookListContainer.addEventListener('touchstart', (e) => {
        const categoryWrapper = e.target.closest('.world-book-category');
        if (categoryWrapper) {
            longPressTimer = setTimeout(() => {
                const touch = e.touches[0];
                handleLongPress(categoryWrapper, touch.clientX, touch.clientY);
            }, 500);
        }
    });
    worldBookListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
    worldBookListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
}
// ç¡®ä¿ db å¯¹è±¡ä¸­æœ‰åˆ†ç±»æ•°ç»„
if (!db.worldBookCategories) {
    db.worldBookCategories = [];
}
// ä¸ºæ—§æ•°æ®åšå…¼å®¹å¤„ç†ï¼Œå°†æ²¡æœ‰åˆ†ç±»çš„ä¸–ç•Œä¹¦æ”¾å…¥â€œæœªåˆ†ç±»â€
db.worldBooks.forEach(book => {
    if (book.categoryId === undefined) {
        book.categoryId = 'uncategorized';
    }
});
setupWorldBookCategorySystem();

// --- ä¿®æ”¹ setupWorldBookApp å‡½æ•° ---
const originalSetupWorldBookApp = setupWorldBookApp;
// â–¼â–¼â–¼ ç”¨ä¸‹é¢è¿™ä¸ªå®Œæ•´çš„ä»£ç å—ï¼Œæ›¿æ¢æ‰ä½ æ–‡ä»¶ä¸­æ—§çš„ setupWorldBookApp å‡½æ•° â–¼â–¼â–¼
setupWorldBookApp = function() {
    originalSetupWorldBookApp(); // è°ƒç”¨åŸå§‹å‡½æ•°ä»¥ä¿ç•™å…¶åŠŸèƒ½

    // ã€é‡è¦ã€‘æ­¤å¤„çš„æ—§çš„ã€å±€éƒ¨çš„ populateCategorySelect å‡½æ•°å®šä¹‰å·²è¢«åˆ é™¤

    // ç›‘å¬æ‰“å¼€ç¼–è¾‘/åˆ›å»ºä¸–ç•Œä¹¦é¡µé¢çš„äº‹ä»¶
    addWorldBookBtn.addEventListener('click', () => {
        // ç°åœ¨è°ƒç”¨çš„æ˜¯å…¨å±€å‡½æ•°
        populateCategorySelect();
    });

    // ç›‘å¬ç‚¹å‡»ä¸–ç•Œä¹¦æ¡ç›®çš„äº‹ä»¶ (è¿™æ®µä»£ç åœ¨ä¹‹å‰çš„å…³é”®è¯åŠŸèƒ½ä¸­å·²æ›´æ–°ï¼Œç°åœ¨ä¿æŒä¸å˜)
    worldBookListContainer.addEventListener('click', e => {
        const item = e.target.closest('.world-book-item');
        if (item) {
            const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
            if(book) {
                // åŠ è½½æ‰€æœ‰å­—æ®µ
                currentEditingWorldBookId = book.id;
                worldBookIdInput.value = book.id;
                worldBookNameInput.value = book.name;
                worldBookContentInput.value = book.content;
                document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                
                // ç°åœ¨è°ƒç”¨çš„æ˜¯å…¨å±€å‡½æ•°
                populateCategorySelect(book.categoryId || 'uncategorized');
                
                document.getElementById('world-book-keywords').value = book.keywords || '';
                document.getElementById('world-book-always-active').checked = book.alwaysActive || false;
                document.getElementById('world-book-case-sensitive').checked = book.caseSensitive || false;
                
                switchScreen('edit-world-book-screen');
            }
        }
    });

    // ä¿®æ”¹ä¿å­˜é€»è¾‘ (è¿™æ®µä»£ç åœ¨ä¹‹å‰çš„å…³é”®è¯åŠŸèƒ½ä¸­å·²æ›´æ–°ï¼Œç°åœ¨ä¿æŒä¸å˜)
    editWorldBookForm.onsubmit = async function(e) {
        e.preventDefault();
        const selectedCategoryId = document.getElementById('world-book-category-select').value;
        const name = worldBookNameInput.value.trim();
        const content = worldBookContentInput.value.trim();
        const position = document.querySelector('input[name="world-book-position"]:checked').value;
        
        const keywords = document.getElementById('world-book-keywords').value.trim();
        const alwaysActive = document.getElementById('world-book-always-active').checked;
        const caseSensitive = document.getElementById('world-book-case-sensitive').checked;

        if (!name || !content) return showToast('åç§°å’Œå†…å®¹ä¸èƒ½ä¸ºç©º');
        
        const bookData = { name, content, position, categoryId: selectedCategoryId, keywords, alwaysActive, caseSensitive };

        if (currentEditingWorldBookId) {
            const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
            if (book) Object.assign(book, bookData);
        } else {
            bookData.id = `wb_${Date.now()}`;
            db.worldBooks.push(bookData);
        }
        
        await saveData();
        showToast('ä¸–ç•Œä¹¦æ¡ç›®å·²ä¿å­˜');
        renderWorldBookList();
        switchScreen('world-book-screen');
    };
};


// --- é‡å†™ renderWorldBookList å‡½æ•°ä»¥æ”¯æŒåˆ†ç±» ---
const originalRenderWorldBookList = renderWorldBookList;
renderWorldBookList = function() {
    worldBookListContainer.innerHTML = '';
    const hasContent = db.worldBooks.length > 0 || db.worldBookCategories.length > 0;
    noWorldBooksPlaceholder.style.display = hasContent ? 'none' : 'block';

  const renderBooks = (books) => {
        let html = '';
        books.forEach(book => {
            html += `
                <li class="list-item world-book-item" data-id="${book.id}">
                    <div class="item-details" style="padding-left: 20px;">
                      
                        <div class="item-name">${escapeHTML(book.name)}</div>
                      
                        <div class="item-preview">${escapeHTML(book.content)}</div>
                    </div>
                </li>`;
        });
        return html;
    };
    
    // 1. æ¸²æŸ“æ‰€æœ‰åˆ†ç±»åŠå…¶ä¸‹çš„ä¸–ç•Œä¹¦
    db.worldBookCategories.forEach(cat => {
        const categoryDiv = document.createElement('div');
        categoryDiv.className = 'world-book-category';
        categoryDiv.dataset.id = cat.id;
        if (cat.isCollapsed) {
            categoryDiv.classList.add('collapsed');
        }
        
        const booksInCategory = db.worldBooks.filter(b => b.categoryId === cat.id);
        
        categoryDiv.innerHTML = `
            <div class="category-header">
                <span class="category-name">${cat.name} (${booksInCategory.length})</span>
                <span class="category-toggle-icon">â–¼</span>
            </div>
            <ul class="category-book-list">
                ${renderBooks(booksInCategory)}
            </ul>
        `;
        worldBookListContainer.appendChild(categoryDiv);
    });

    // 2. æ¸²æŸ“æœªåˆ†ç±»çš„ä¸–ç•Œä¹¦ (å¢åŠ äº¤äº’åŠŸèƒ½)
    const uncategorizedBooks = db.worldBooks.filter(b => b.categoryId === 'uncategorized');
    if(uncategorizedBooks.length > 0) {
        const uncategorizedDiv = document.createElement('div');
        uncategorizedDiv.className = 'world-book-category'; // å¤ç”¨æ ·å¼
        uncategorizedDiv.dataset.id = 'uncategorized'; // æ·»åŠ ç‰¹æ®ŠID
        if (db.uncategorizedCollapsed) {
            uncategorizedDiv.classList.add('collapsed'); // æ ¹æ®ä¿å­˜çš„çŠ¶æ€æ·»åŠ æŠ˜å class
        }

        uncategorizedDiv.innerHTML = `
            <div class="category-header" id="uncategorized-header"> <!-- æ·»åŠ IDä¾¿äºäº‹ä»¶ç›‘å¬ -->
                <span class="category-name">æœªåˆ†ç±» (${uncategorizedBooks.length})</span>
                <span class="category-toggle-icon">â–¼</span> <!-- æ·»åŠ æŠ˜å å›¾æ ‡ -->
            </div>
            <ul class="category-book-list">
                ${renderBooks(uncategorizedBooks)}
            </ul>
        `;
        worldBookListContainer.appendChild(uncategorizedDiv);
    }
};
        
        // v-- åœ¨è¿™é‡Œï¼ˆinit å‡½æ•°å¤–éƒ¨ï¼‰æ·»åŠ ä¸‹é¢çš„æ–°å‡½æ•° --v
        // (ç”¨ä¸‹é¢çš„é•¿ä»£ç å—ï¼Œå®Œæ•´æ›¿æ¢æ‰ä½ æ–‡ä»¶ä¸­å·²æœ‰çš„é‚£ä¸ªç®€çŸ­çš„ setupMusicPlayer å‡½æ•°)
        function parseLRC(lrcContent) {
            if (!lrcContent) return [];
            const lines = lrcContent.split('\n');
            const result = [];
            const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;

            for (const line of lines) {
                const match = line.match(timeRegex);
                if (match) {
                    const minutes = parseInt(match[1], 10);
                    const seconds = parseInt(match[2], 10);
                    const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
                    const time = minutes * 60 + seconds + milliseconds / 1000;
                    const text = line.replace(timeRegex, '').trim();
                    if (text) {
                        result.push({ time, text });
                    }
                }
            }
            return result.sort((a, b) => a.time - b.time);
        }

        function updateLyrics(currentTime) {
            if (!parsedLyrics.length) return;

            // å¯»æ‰¾å½“å‰åº”è¯¥é«˜äº®çš„æ­Œè¯è¡Œç´¢å¼•
            let newLyricIndex = parsedLyrics.findIndex(line => line.time > currentTime) - 1;
            if (newLyricIndex === -2) { // å¦‚æœæ’­æ”¾æ—¶é—´è¶…è¿‡äº†æœ€åä¸€å¥æ­Œè¯
                newLyricIndex = parsedLyrics.length - 1;
            }
            if (newLyricIndex < 0) {
                 newLyricIndex = 0;
            }

            if (newLyricIndex !== currentLyricIndex) {
                currentLyricIndex = newLyricIndex;
                const lyricsPanel = document.getElementById('lyrics-panel');
                const innerPanel = lyricsPanel.querySelector('.lyrics-panel-inner');
                const allLines = innerPanel.querySelectorAll('.lyric-line');

                allLines.forEach((line, index) => {
                    line.classList.toggle('active', index === currentLyricIndex);
                });

                // è®¡ç®—æ»šåŠ¨ä½ç½®
                const activeLine = allLines[currentLyricIndex];
                if (activeLine) {
                    const panelHeight = lyricsPanel.clientHeight;
                    const activeLineOffset = activeLine.offsetTop + (activeLine.clientHeight / 2);
                    const scrollAmount = activeLineOffset - (panelHeight / 2);
                    innerPanel.style.transform = `translateY(-${scrollAmount}px)`;
                }
            }
        }
        function setupMusicPlayer() {
            // --- DOM å…ƒç´ ç¼“å­˜ ---
            audioPlayer = document.getElementById('global-audio-player');
            const musicWidget = document.getElementById('music-app-widget');
            const musicModal = document.getElementById('music-player-modal');
            const playlistPanel = document.getElementById('music-playlist-panel');
            const addSongModal = document.getElementById('add-song-modal');
            const shareMusicModal = document.getElementById('share-music-modal');
            
            const playBtn = musicModal.querySelector('.play-btn');
            const nextBtn = musicModal.querySelector('.side-btn[title="ä¸‹ä¸€é¦–"]');
            const prevBtn = musicModal.querySelector('.side-btn[title="ä¸Šä¸€é¦–"]');
            const loopBtn = musicModal.querySelector('.music-extra-controls button[title="å¾ªç¯æ¨¡å¼"]');
            const openPlaylistBtn = musicModal.querySelector('.music-extra-controls button[title="æ­Œæ›²åˆ—è¡¨"]');
            const openAddSongModalBtn = document.getElementById('open-add-song-modal-btn');
            const addSongForm = document.getElementById('add-song-form');
            const shareBtn = musicModal.querySelector('.share-btn');
            const confirmShareBtn = document.getElementById('confirm-music-share-btn');

            // --- æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ---
        // â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æ–°çš„ã€å®Œæ•´çš„ã€‘å‡½æ•°æ›¿æ¢æ‰æ‚¨æ–‡ä»¶ä¸­æ—§çš„ updatePlayerUI å‡½æ•° â–¼â–¼â–¼
const updatePlayerUI = () => {
    const song = db.playlist[currentSongIndex];
    const albumArt = musicModal.querySelector('.music-album-art');
    const songTitle = musicModal.querySelector('.song-title');
    const lyricsPanel = musicModal.querySelector('#lyrics-panel');
    const playBtn = musicModal.querySelector('.play-btn');

    // --- æ ¸å¿ƒä¿®å¤ï¼šå·²ç»åˆ é™¤äº†æ‰€æœ‰å¯¹ä¸»å±å¹•å°éƒ¨ä»¶ï¼ˆwidgetï¼‰çš„æ— æ•ˆæ“ä½œ ---

    if (song) {
        const defaultArt = 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
        albumArt.src = song.albumArt || defaultArt;
        songTitle.textContent = song.name;
        playBtn.innerHTML = isPlaying ? '<svg viewBox="0 0 24 24"><path d="M14,19H18V5H14M6,19H10V5H6V19Z"/></svg>' : '<svg viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"/></svg>';
    } else {
        // å½“æ²¡æœ‰æ­Œæ›²æ—¶ï¼Œåªæ›´æ–°æ’­æ”¾å™¨å¼¹çª—å†…çš„æ ‡é¢˜
        songTitle.textContent = 'æ­Œæ›²å';
        if (lyricsPanel) {
            lyricsPanel.innerHTML = '<p class="lyric-line">æ­Œè¯é¢æ¿</p>';
        }
    }
};
// â–²â–²â–² æ›¿æ¢åˆ°æ­¤ç»“æŸ â–²â–²â–²

                                    const playSong = async (index) => {
                if (index < 0 || index >= db.playlist.length) {
                    isPlaying = false;
                    audioPlayer.pause();
                    currentSongIndex = -1;
                    updatePlayerUI();
                    return;
                }
                currentSongIndex = index;
                const song = db.playlist[index];
                audioPlayer.src = song.url;

                // --- æ­Œè¯å¤„ç† ---
                const lyricsPanel = document.getElementById('lyrics-panel');
                lyricsPanel.innerHTML = ''; // æ¸…ç©ºæ—§æ­Œè¯
                
                // â–¼â–¼â–¼ ä¿®æ­£ï¼šç§»é™¤äº† letï¼Œç›´æ¥ç»™å…¨å±€å˜é‡èµ‹å€¼ â–¼â–¼â–¼
                parsedLyrics = [];
                currentLyricIndex = -1;
                // â–²â–²â–² ä¿®æ­£ç»“æŸ â–²â–²â–²

                if (song.lyrics) {
                    parsedLyrics = parseLRC(song.lyrics);
                }

                if (parsedLyrics.length > 0) {
                    const innerPanel = document.createElement('div');
                    innerPanel.className = 'lyrics-panel-inner';
                    parsedLyrics.forEach(line => {
                        const p = document.createElement('p');
                        p.className = 'lyric-line';
                        p.textContent = line.text;
                        innerPanel.appendChild(p);
                    });
                    lyricsPanel.appendChild(innerPanel);
                } else {
                    lyricsPanel.innerHTML = '<p class="lyric-line">æš‚æ— æ­Œè¯</p>';
                }
                // --- æ­Œè¯å¤„ç†ç»“æŸ ---

                try {
                    await audioPlayer.play();
                    isPlaying = true;
                } catch (error) {
                    isPlaying = false;
                    showToast(`æ­Œæ›² ${song.name} æ’­æ”¾å¤±è´¥`);
                }
                updatePlayerUI();
                notifyAiOfSongChange();
            };

            const togglePlayPause = () => {
                if (isPlaying) {
                    audioPlayer.pause();
                    isPlaying = false;
                } else {
                    if (currentSongIndex === -1 && db.playlist.length > 0) {
                        playSong(0);
                    } else if (currentSongIndex !== -1) {
                        audioPlayer.play();
                        isPlaying = true;
                    } else {
                        showToast("æ’­æ”¾åˆ—è¡¨ä¸ºç©º, è¯·å…ˆæ·»åŠ æ­Œæ›²");
                    }
                }
                updatePlayerUI();
            };
            
            const createShuffleOrder = () => {
                shuffleOrder = [...Array(db.playlist.length).keys()];
                for (let i = shuffleOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffleOrder[i], shuffleOrder[j]] = [shuffleOrder[j], shuffleOrder[i]];
                }
            };

            const playNext = () => {
                if (db.playlist.length === 0) return;
                const mode = db.musicPlayerSettings.playbackMode;
                if (mode === 'shuffle') {
                    if (shuffleOrder.length === 0) createShuffleOrder();
                    const currentIndexInShuffle = shuffleOrder.indexOf(currentSongIndex);
                    const nextIndexInShuffle = (currentIndexInShuffle + 1) % shuffleOrder.length;
                    playSong(shuffleOrder[nextIndexInShuffle]);
                } else {
                    const nextIndex = (currentSongIndex + 1) % db.playlist.length;
                    playSong(nextIndex);
                }
            };
            
            const playPrev = () => {
                if (db.playlist.length === 0) return;
                const mode = db.musicPlayerSettings.playbackMode;
                if (mode === 'shuffle') {
                     if (shuffleOrder.length === 0) createShuffleOrder();
                    const currentIndexInShuffle = shuffleOrder.indexOf(currentSongIndex);
                    const prevIndexInShuffle = (currentIndexInShuffle - 1 + shuffleOrder.length) % shuffleOrder.length;
                    playSong(shuffleOrder[prevIndexInShuffle]);
                } else {
                    const prevIndex = (currentSongIndex - 1 + db.playlist.length) % db.playlist.length;
                    playSong(prevIndex);
                }
            };

            const changePlaybackMode = async () => {
                const modes = ['sequential', 'loop', 'shuffle'];
                const currentModeIndex = modes.indexOf(db.musicPlayerSettings.playbackMode);
                const nextModeIndex = (currentModeIndex + 1) % modes.length;
                db.musicPlayerSettings.playbackMode = modes[nextModeIndex];
                
                if (db.musicPlayerSettings.playbackMode === 'shuffle') createShuffleOrder();
                else shuffleOrder = [];

                let iconHtml = '', toastMessage = '';
                switch (db.musicPlayerSettings.playbackMode) {
                    case 'loop':
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5Z"/></svg>';
                        toastMessage = 'å•æ›²å¾ªç¯';
                        audioPlayer.loop = true;
                        break;
                    case 'shuffle':
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M10.59,9.17L5.41,4L4,5.41L9.17,10.59L10.59,9.17M14.83,13.41L13.41,14.83L18,19.42L19.42,18L14.83,13.41M14.83,9.17L19.42,4.58L18,3.17L13.41,7.76L14.83,9.17M4.2,19.2L5.6,17.8L4.2,16.4L2.8,17.8L4.2,19.2M9.17,14.83L7.76,13.41L3.17,18L4.58,19.42L9.17,14.83Z"/></svg>';
                        toastMessage = 'éšæœºæ’­æ”¾';
                        audioPlayer.loop = false;
                        break;
                    default:
                        iconHtml = '<svg viewBox="0 0 24 24"><path d="M17,17H7V14L3,18L7,22V19H19V13H17M7,7H17V10L21,6L17,2V5H5V11H7V7Z"/></svg>';
                        toastMessage = 'é¡ºåºæ’­æ”¾';
                        audioPlayer.loop = false;
                        break;
                }
                loopBtn.innerHTML = iconHtml;
                showToast(toastMessage);
                await saveData();
            };
            
            const renderPlaylistPanel = () => {
                const container = document.getElementById('playlist-container');
                container.innerHTML = '';
                if (db.playlist.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">æ’­æ”¾åˆ—è¡¨æ˜¯ç©ºçš„</p>';
                    return;
                }
                db.playlist.forEach((song, index) => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    if(index === currentSongIndex) li.style.backgroundColor = 'var(--bg-color)';
                    li.style.cssText += 'display: flex; justify-content: space-between; align-items: center;';
                    li.innerHTML = `
                        <div class="item-details" style="cursor: pointer; flex-grow: 1;">
                            <div class="item-name">${song.name}</div>
                            <div class="item-preview">${song.artist}</div>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <button class="btn btn-small" data-index="${index}" style="padding: 4px 8px; background-color: #eee; color: #333;">è¯</button>
                            <button class="btn btn-danger btn-small" data-index="${index}" style="padding: 4px 10px;">ç§»é™¤</button>
                        </div>
                    `;
                    li.querySelector('.item-details').addEventListener('click', () => {
                        playSong(index);
                        playlistPanel.classList.remove('visible');
                    });
                    li.querySelector('button.btn-danger').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        db.playlist.splice(index, 1);
                        if (currentSongIndex === index) { playNext(); } 
                        else if (currentSongIndex > index) { currentSongIndex--; }
                        await saveData();
                        renderPlaylistPanel();
                    });
                    li.querySelector('button[data-index]').addEventListener('click', async (e) => {
                         e.stopPropagation();
                         if(e.target.classList.contains('btn-danger')) return;
                         // è¿™æ˜¯â€œè¯â€æŒ‰é’®çš„é€»è¾‘
                         const lrcContent = await new Promise(resolve => {
                             const lrcInput = document.getElementById('lrc-upload-input');
                             const handler = (event) => {
                                 const file = event.target.files[0];
                                 if (file) {
                                     const reader = new FileReader();
                                     reader.onload = (re) => resolve(re.target.result);
                                     reader.readAsText(file);
                                 } else { resolve(null); }
                                 lrcInput.removeEventListener('change', handler);
                                 lrcInput.value = '';
                             };
                             lrcInput.addEventListener('change', handler);
                             lrcInput.click();
                         });
                         if (lrcContent !== null) {
                             db.playlist[index].lyrics = lrcContent;
                             await saveData();
                             showToast('æ­Œè¯å·²å…³è”ï¼');
                             if (currentSongIndex === index) { playSong(index); }
                         }
                    });
                    container.appendChild(li);
                });
            };

                       const renderShareModal = () => {
                const container = document.getElementById('share-music-selection-list');
                container.innerHTML = '';
                const allChats = [...db.characters, ...db.groups];
                if (allChats.length === 0) {
                    container.innerHTML = '<li style="color:#888; text-align:center; padding: 20px 0;">æ²¡æœ‰å¯ä»¥åˆ†äº«çš„èŠå¤©</li>';
                    return;
                }
                allChats.forEach(chat => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item'; // å¤ç”¨ç°æœ‰æ ·å¼
                    const isChecked = sharedWithChatIds.has(chat.id);
                    const name = chat.remarkName || chat.name;
                    const avatar = chat.avatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    
                    li.innerHTML = `
                        <input type="checkbox" id="share-select-${chat.id}" value="${chat.id}" ${isChecked ? 'checked' : ''}>
                        <label for="share-select-${chat.id}" style="display: flex; align-items: center; width: 100%; gap: 10px;">
                            <img src="${avatar}" alt="${name}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
                            <span>${name}</span>
                        </label>
                    `;
                    container.appendChild(li);
                });
            };
                    // â–¼â–¼â–¼ è¯·ç”¨ä¸‹é¢è¿™ã€ä¸€æ•´å—ã€‘ä»£ç ï¼Œå®Œæ•´æ›¿æ¢æ‰ä½ æ–‡ä»¶ä¸­æ—§çš„ sendMusicCard å‡½æ•° â–¼â–¼â–¼
        const sendMusicCard = async (chatId, song) => {
            const chat = db.characters.find(c => c.id === chatId) || db.groups.find(g => g.id === chatId);
            if (!chat) return;

            // --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨æ›´å¯é çš„æ–¹å¼æ¥åˆ¤æ–­èŠå¤©ç±»å‹ ---
            // å¦‚æœ chat å¯¹è±¡æœ‰ .me å±æ€§, è¯´æ˜æ˜¯ç¾¤èŠï¼›å¦åˆ™å°±æ˜¯å•èŠã€‚
            const myName = chat.me ? chat.me.nickname : chat.myName;
            const content = `[${myName}åˆ†äº«äº†éŸ³ä¹ï¼š${song.name} - ${song.artist}]`;

            const message = { 
                id: `msg_music_${Date.now()}`, 
                role: 'user', 
                content, 
                parts: [{ type: 'text', text: content }], 
                timestamp: Date.now(), 
                senderId: 'user_me' 
            };
            
            chat.history.push(message);
            // åªæœ‰å½“åˆ†äº«çš„ç›®æ ‡å°±æ˜¯å½“å‰æ‰“å¼€çš„èŠå¤©æ—¶ï¼Œæ‰ç«‹å³åœ¨ç•Œé¢ä¸Šæ·»åŠ æ°”æ³¡
            if (currentChatId === chatId) {
                addMessageBubble(message);
            }
        };
        // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²
            const notifyAiOfSongChange = async () => {
                if (currentSongIndex === -1 || sharedWithChatIds.size === 0) return;
                
                const song = db.playlist[currentSongIndex];
                const notificationContent = `[system-context-only: æˆ‘æ­£åœ¨å¬çš„æ­Œæ›²å·²åˆ‡æ¢ä¸º: ${song.name} - ${song.artist}ã€‚æ­Œè¯: ${song.lyrics || 'æ— '}]`;
                
                for (const chatId of sharedWithChatIds) {
                    const chat = db.characters.find(c => c.id === chatId) || db.groups.find(g => g.id === chatId);
                    if (chat) {
                        const message = { id: `msg_music_update_${Date.now()}`, role: 'user', content: notificationContent, parts: [{ type: 'text', text: notificationContent }], timestamp: Date.now(), senderId: 'user_me' };
                        chat.history.push(message);
                    }
                }
                await saveData();
            };

            // --- äº‹ä»¶ç›‘å¬å™¨ ---
            musicWidget.addEventListener('click', () => musicModal.classList.add('visible'));
            playBtn.addEventListener('click', togglePlayPause);
            nextBtn.addEventListener('click', playNext);
            prevBtn.addEventListener('click', playPrev);
            loopBtn.addEventListener('click', changePlaybackMode);
            openPlaylistBtn.addEventListener('click', () => { renderPlaylistPanel(); playlistPanel.classList.add('visible'); });
            openAddSongModalBtn.addEventListener('click', () => { addSongForm.reset(); addSongModal.classList.add('visible'); });

            addSongForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newSong = {
                    id: `song_${Date.now()}`,
                    url: document.getElementById('song-url-input').value.trim(),
                    name: document.getElementById('song-name-input').value.trim(),
                    artist: document.getElementById('song-artist-input').value.trim(),
                    albumArt: document.getElementById('song-album-art-input').value.trim(),
                    lyrics: document.getElementById('song-lyrics-input').value.trim()
                };
                if (!newSong.url.startsWith("https://files.catbox.moe/")) { showToast("è¯·è¾“å…¥æœ‰æ•ˆçš„Catboxé“¾æ¥"); return; }
                db.playlist.push(newSong);
                await saveData();
                showToast("æ­Œæ›²å·²æ·»åŠ ");
                addSongModal.classList.remove('visible');
                renderPlaylistPanel();
                if (currentSongIndex === -1) updatePlayerUI();
            });

            shareBtn.addEventListener('click', () => {
                if (currentSongIndex === -1) { showToast("è¯·å…ˆæ’­æ”¾ä¸€é¦–æ­Œæ›²å†åˆ†äº«"); return; }
                renderShareModal();
                shareMusicModal.classList.add('visible');
            });
            
            confirmShareBtn.addEventListener('click', async () => {
                const checkboxes = shareMusicModal.querySelectorAll('input[type="checkbox"]');
                const song = db.playlist[currentSongIndex];
                let newShares = new Set();
                
                for (const cb of checkboxes) {
                    if (cb.checked) {
                        newShares.add(cb.value);
                        if (!sharedWithChatIds.has(cb.value)) await sendMusicCard(cb.value, song);
                    }
                }
                sharedWithChatIds = newShares;
                await notifyAiOfSongChange();
                
                shareMusicModal.classList.remove('visible');
                showToast("åˆ†äº«è®¾ç½®å·²æ›´æ–°");
            });

            audioPlayer.addEventListener('ended', () => { if (!audioPlayer.loop) playNext(); });
            audioPlayer.addEventListener('play', () => { isPlaying = true; updatePlayerUI(); });
            audioPlayer.addEventListener('pause', () => { isPlaying = false; updatePlayerUI(); });
            // ... a few lines above this ...
            audioPlayer.addEventListener('timeupdate', () => { updateLyrics(audioPlayer.currentTime); });

            [musicModal, playlistPanel, addSongModal, shareMusicModal].forEach(el => {
                el.addEventListener('click', (e) => { if (e.target === el) el.classList.remove('visible'); });
            });
            
            // åˆå§‹åŒ–
            updatePlayerUI();
            if (db.playlist.length > 0) playSong(0); // å°è¯•è‡ªåŠ¨æ’­æ”¾ç¬¬ä¸€é¦–
        }
// ^-- æ–°å‡½æ•°åˆ°æ­¤ç»“æŸ --^
        function updateClock() {
            const now = new Date();
            const timeDisplay = document.getElementById('time-display');
            const dateDisplay = document.getElementById('date-display');
            if (timeDisplay) timeDisplay.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
            if (dateDisplay) dateDisplay.textContent = `${now.getFullYear()}å¹´${pad(now.getMonth() + 1)}æœˆ${pad(now.getDate())}æ—¥`;
        }

        // --- App Setup Functions ---
        // START: æ–°å¢ä¸»é¡µç¿»é¡µé€»è¾‘
// START: ç”µè„‘ç«¯/æ‰‹æœºç«¯é€šç”¨ç¿»é¡µé€»è¾‘ (é¼ æ ‡æ‹–æ‹½ + é”®ç›˜æ–¹å‘é”®)
function setupHomeScreenPaging() {
    const container = document.querySelector('.home-page-wrapper');
    const dots = document.querySelectorAll('.home-page-indicator .dot');
    const homeContainer = document.getElementById('home-container');
    
    let startX = 0;
    let isDragging = false;
    let currentPageIndex = 0;

    // æ‰§è¡Œç¿»é¡µåŠ¨ä½œ
    function goToPage(index) {
        if (index < 0 || index > 1) return; // ç›®å‰åªæœ‰2é¡µï¼Œé˜²æ­¢è¶Šç•Œ
        container.style.transform = `translateX(-${index * 50}%)`;
        
        // æ›´æ–°åº•éƒ¨åœ†ç‚¹çŠ¶æ€
        dots.forEach(dot => dot.classList.remove('active'));
        if(dots[index]) dots[index].classList.add('active');
        
        currentPageIndex = index;
    }

    // ===========================
    // 1. æ‰‹æœºç«¯è§¦æ‘¸æ”¯æŒ (åŸé€»è¾‘)
    // ===========================
    homeContainer.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
    });

    homeContainer.addEventListener('touchend', (e) => {
        const touchEndX = e.changedTouches[0].clientX;
        handleSwipe(startX, touchEndX);
    });

    // ===========================
    // 2. ç”µè„‘ç«¯é¼ æ ‡æ‹–æ‹½æ”¯æŒ (æ–°å¢)
    // ===========================
    homeContainer.addEventListener('mousedown', (e) => {
        startX = e.clientX;
        isDragging = true;
    });

    homeContainer.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        const endX = e.clientX;
        isDragging = false;
        handleSwipe(startX, endX);
    });
    
    // é˜²æ­¢é¼ æ ‡ç§»å‡ºå±å¹•å¯¼è‡´çŠ¶æ€å¡æ­»
    homeContainer.addEventListener('mouseleave', () => {
        isDragging = false;
    });

    // ===========================
    // 3. é€šç”¨æ»‘åŠ¨åˆ¤æ–­é€»è¾‘
    // ===========================
    function handleSwipe(start, end) {
        const diff = end - start;
        const threshold = 50; // æ»‘åŠ¨è¶…è¿‡50åƒç´ æ‰ç®—ç¿»é¡µï¼Œé˜²æ­¢è¯¯è§¦ç‚¹å‡»

        if (Math.abs(diff) > threshold) {
            if (diff < 0 && currentPageIndex === 0) {
                goToPage(1); // å‘å·¦æ»‘ -> å»ç¬¬äºŒé¡µ
            } else if (diff > 0 && currentPageIndex === 1) {
                goToPage(0); // å‘å³æ»‘ -> å›ç¬¬ä¸€é¡µ
            }
        }
    }

    // ===========================
    // 4. é”®ç›˜æ–¹å‘é”®æ”¯æŒ (æ–°å¢)
    // ===========================
    document.addEventListener('keydown', (e) => {
        // åªæœ‰å½“ä¸»å±å¹•æ˜¾ç¤ºæ—¶æ‰å“åº”é”®ç›˜
        if (document.getElementById('home-container').classList.contains('active')) {
            if (e.key === 'ArrowRight') {
                goToPage(1); // æŒ‰å³é”®å»ç¬¬äºŒé¡µ
            } else if (e.key === 'ArrowLeft') {
                goToPage(0); // æŒ‰å·¦é”®å›ç¬¬ä¸€é¡µ
            }
        }
    });

    // åº•éƒ¨åœ†ç‚¹ç‚¹å‡»åˆ‡æ¢
    dots.forEach(dot => {
        dot.addEventListener('click', () => goToPage(parseInt(dot.dataset.index)));
    });
}
// END: ç”µè„‘ç«¯/æ‰‹æœºç«¯é€šç”¨ç¿»é¡µé€»è¾‘

// END: æ–°å¢ä¸»é¡µç¿»é¡µé€»è¾‘
// START: æ–°å¢æ¸²æŸ“å™¨åº”ç”¨æ ¸å¿ƒé€»è¾‘
// START: æ¸²æŸ“å™¨åº”ç”¨æ ¸å¿ƒé€»è¾‘ (å®Œæ•´åŠŸèƒ½ç‰ˆ)
function setupRendererApp() {
    let currentRendererCategoryId = 'all';

    // --- DOMå…ƒç´ ç¼“å­˜ ---
    const categoryList = document.getElementById('renderer-category-list');
    const ruleList = document.getElementById('renderer-rule-list');
    const noRulesPlaceholder = document.getElementById('no-renderer-rules-placeholder');
    const addCategoryBtn = document.getElementById('add-renderer-category-btn');
    const addRuleBtn = document.getElementById('add-renderer-rule-btn');
    const importRulesBtn = document.getElementById('import-renderer-rules-btn');
    const importRulesInput = document.getElementById('renderer-import-input');

    const categoryModal = document.getElementById('renderer-category-modal');
    const categoryForm = document.getElementById('renderer-category-form');
    const categoryNameInput = document.getElementById('renderer-category-name');

    const ruleModal = document.getElementById('edit-renderer-rule-modal');
    const ruleForm = document.getElementById('edit-renderer-rule-form');
    const ruleIdInput = document.getElementById('renderer-rule-id');
    const ruleNameInput = document.getElementById('renderer-rule-name');
    const ruleRegexInput = document.getElementById('renderer-rule-regex');
    const ruleHtmlInput = document.getElementById('renderer-rule-html');
    const ruleTrimInput = document.getElementById('renderer-rule-trim');
    const ruleEnabledCheckbox = document.getElementById('renderer-rule-enabled');
    const charBindingList = document.getElementById('renderer-char-binding-list');

    // --- æ ¸å¿ƒæ¸²æŸ“å‡½æ•° ---
function updateRendererPreview() {
    const regexInput = document.getElementById('renderer-rule-regex').value;
    const htmlInput = document.getElementById('renderer-rule-html').value;
    const testInput = document.getElementById('renderer-rule-test-input').value;
    const previewOutput = document.getElementById('renderer-rule-preview-output');
    
    if (!testInput) {
        previewOutput.innerHTML = '<span style="color: #aaa;">è¯·è¾“å…¥æµ‹è¯•æ–‡æœ¬ä»¥æŸ¥çœ‹æ•ˆæœ</span>';
        return;
    }

    if (!regexInput || !htmlInput) {
        previewOutput.textContent = testInput; // æ²¡æœ‰è§„åˆ™å¯åº”ç”¨ï¼Œæ˜¾ç¤ºåŸæ–‡
        return;
    }
    
    try {
        const flags = Array.from(document.querySelectorAll('.regex-flags-container input:checked')).map(cb => cb.value).join('');
        const regex = new RegExp(regexInput, flags);
        
        // æµ‹è¯•æ­£åˆ™è¡¨è¾¾å¼æ˜¯å¦åŒ¹é…
        if (regex.test(testInput)) {
            // å¿…é¡»é‡ç½® lastIndex æ‰èƒ½ä¿è¯å…¨å±€åŒ¹é… (g flag) çš„æ­£ç¡®æ€§
            regex.lastIndex = 0; 
            previewOutput.innerHTML = testInput.replace(regex, htmlInput);
        } else {
            previewOutput.textContent = testInput; // æ²¡æœ‰åŒ¹é…ï¼Œæ˜¾ç¤ºåŸæ–‡
        }
    } catch (error) {
        // æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•æ— æ•ˆï¼Œæä¾›é”™è¯¯åé¦ˆ
        previewOutput.innerHTML = `<span style="color: red; font-weight: bold;">æ­£åˆ™è¡¨è¾¾å¼é”™è¯¯:</span><br><span style="font-family: monospace;">${error.message}</span>`;
    }
}
    function renderRendererCategories() {
        categoryList.innerHTML = '';
        const allItem = document.createElement('li');
        allItem.className = 'list-item';
        allItem.dataset.id = 'all';
        allItem.textContent = 'å…¨éƒ¨';
        if (currentRendererCategoryId === 'all') allItem.classList.add('active');
        categoryList.appendChild(allItem);

        (db.rendererCategories || []).forEach(cat => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = cat.id;
            li.textContent = cat.name;
            if (cat.id === currentRendererCategoryId) li.classList.add('active');
            categoryList.appendChild(li);
        });
    }

    function renderRendererRules() {
        ruleList.innerHTML = '';
        const rulesToRender = (currentRendererCategoryId === 'all')
            ? (db.renderers || [])
            : (db.renderers || []).filter(r => r.categoryId === currentRendererCategoryId);

        noRulesPlaceholder.style.display = rulesToRender.length === 0 ? 'block' : 'none';

        rulesToRender.forEach(rule => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = rule.id;
            li.innerHTML = `
                <div class="item-details">
                    <div class="rule-name">${rule.name} ${rule.enabled ? '' : '(å·²ç¦ç”¨)'}</div>
                    <div class="rule-regex">${rule.regex}</div>
                </div>
            `;
            ruleList.appendChild(li);
        });
    }// START: æ–°å¢æ¸²æŸ“å™¨åˆ†ç±»åˆ é™¤åŠŸèƒ½
// --- åˆ†ç±»åˆ—è¡¨é•¿æŒ‰/å³é”®åˆ é™¤ ---
categoryList.addEventListener('contextmenu', e => {
    e.preventDefault();
    const item = e.target.closest('.list-item');
    if (item && item.dataset.id !== 'all') { // "å…¨éƒ¨" åˆ†ç±»ä¸èƒ½åˆ é™¤
        const categoryId = item.dataset.id;
        const category = db.rendererCategories.find(c => c.id === categoryId);
        if (category) {
            createContextMenu([
                {
                    label: `åˆ é™¤åˆ†ç±» "${category.name}"`,
                    danger: true,
                    action: async () => {
                        if (confirm(`ç¡®å®šè¦åˆ é™¤åˆ†ç±» "${category.name}" å—ï¼Ÿ\nè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰è§„åˆ™å°†è¢«ç§»åŠ¨åˆ°æœªåˆ†ç±»çŠ¶æ€ã€‚`)) {
                            // 1. å°†è¯¥åˆ†ç±»ä¸‹çš„è§„åˆ™ categoryId è®¾ä¸º null
                            db.renderers.forEach(rule => {
                                if (rule.categoryId === categoryId) {
                                    rule.categoryId = null;
                                }
                            });
                            // 2. ä»åˆ†ç±»åˆ—è¡¨ä¸­åˆ é™¤è¯¥åˆ†ç±»
                            db.rendererCategories = db.rendererCategories.filter(c => c.id !== categoryId);
                            
                            await saveData();
                            
                            // 3. åˆ·æ–°UI
                            currentRendererCategoryId = 'all'; // è¿”å›â€œå…¨éƒ¨â€è§†å›¾
                            renderRendererCategories();
                            renderRendererRules();
                            showToast('åˆ†ç±»å·²åˆ é™¤');
                        }
                    }
                }
            ], e.clientX, e.clientY);
        }
    }
});

categoryList.addEventListener('touchstart', (e) => {
    const item = e.target.closest('.list-item');
    if (item && item.dataset.id !== 'all') {
        longPressTimer = setTimeout(() => {
            const touch = e.touches[0];
            const categoryId = item.dataset.id;
            const category = db.rendererCategories.find(c => c.id === categoryId);
            if(category) {
                // æ­¤å¤„ä»£ç ä¸ contextmenu é‡å¤ï¼Œå¯ä»¥å°è£…æˆä¸€ä¸ªå‡½æ•°ï¼Œä½†ä¸ºç®€å•èµ·è§ç›´æ¥å¤åˆ¶
                 createContextMenu([
                    {
                        label: `åˆ é™¤åˆ†ç±» "${category.name}"`,
                        danger: true,
                        action: async () => {
                            if (confirm(`ç¡®å®šè¦åˆ é™¤åˆ†ç±» "${category.name}" å—ï¼Ÿ\nè¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰è§„åˆ™å°†è¢«ç§»åŠ¨åˆ°æœªåˆ†ç±»çŠ¶æ€ã€‚`)) {
                                db.renderers.forEach(rule => {
                                    if (rule.categoryId === categoryId) {
                                        rule.categoryId = null;
                                    }
                                });
                                db.rendererCategories = db.rendererCategories.filter(c => c.id !== categoryId);
                                await saveData();
                                currentRendererCategoryId = 'all';
                                renderRendererCategories();
                                renderRendererRules();
                                showToast('åˆ†ç±»å·²åˆ é™¤');
                            }
                        }
                    }
                ], touch.clientX, touch.clientY);
            }
        }, 500);
    }
});
categoryList.addEventListener('touchend', () => clearTimeout(longPressTimer));
categoryList.addEventListener('touchmove', () => clearTimeout(longPressTimer));
// END: æ–°å¢æ¸²æŸ“å™¨åˆ†ç±»åˆ é™¤åŠŸèƒ½

    // --- å¼¹çª—ä¸è¡¨å•å¤„ç† ---
    
    // ç”¨è¿™ä¸ªæ–°ç‰ˆæœ¬æ›¿æ¢æ—§çš„ openRuleModal å‡½æ•°
    function openRuleModal(ruleId = null) {
        ruleForm.reset();
        charBindingList.innerHTML = '';

        db.characters.forEach(char => {
            const item = document.createElement('div');
            item.className = 'char-binding-item';
            item.innerHTML = `<input type="checkbox" id="bind-${char.id}" value="${char.id}"><label for="bind-${char.id}">${char.remarkName}</label>`;
            charBindingList.appendChild(item);
        });

        if (ruleId) { // ç¼–è¾‘æ¨¡å¼
            const rule = db.renderers.find(r => r.id === ruleId);
            if (rule) {
                ruleIdInput.value = rule.id;
                ruleNameInput.value = rule.name;
                ruleRegexInput.value = rule.regex;
                ruleHtmlInput.value = rule.html;
                ruleTrimInput.value = (rule.trimStrings || []).join('\n');
                ruleEnabledCheckbox.checked = rule.enabled;
                document.getElementById('renderer-rule-priority').value = rule.priority || 50; // åŠ è½½ä¼˜å…ˆçº§

                document.querySelectorAll('input[name="renderer-scope"]').forEach(cb => {
                    cb.checked = (rule.scope || []).includes(cb.value);
                });
                ['g', 'i', 's'].forEach(flag => {
                    const cb = document.getElementById(`regex-flag-${flag}`);
                    if(cb) cb.checked = (rule.flags || []).includes(flag);
                });
                (rule.characterIds || []).forEach(charId => {
                    const checkbox = document.getElementById(`bind-${charId}`);
                    if (checkbox) checkbox.checked = true;
                });
            }
        } else { // åˆ›å»ºæ¨¡å¼
            ruleIdInput.value = '';
            ruleEnabledCheckbox.checked = true;
            document.getElementById('regex-flag-g').checked = true;
            document.querySelector('input[name="renderer-scope"][value="ai"]').checked = true;
            document.getElementById('renderer-rule-priority').value = 50; // æ–°è§„åˆ™çš„é»˜è®¤ä¼˜å…ˆçº§
        }
        
        // é‡ç½®å¹¶ç»‘å®šå®æ—¶é¢„è§ˆåŠŸèƒ½
        document.getElementById('renderer-rule-test-input').value = '';
        updateRendererPreview(); // æ‰“å¼€æ—¶ç«‹å³æ›´æ–°ä¸€æ¬¡é¢„è§ˆ
        
        ['renderer-rule-regex', 'renderer-rule-html', 'renderer-rule-test-input'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateRendererPreview);
        });
        document.querySelectorAll('.regex-flags-container input').forEach(el => {
            el.addEventListener('change', updateRendererPreview);
        });
        
        ruleModal.classList.add('visible');
    }
    ruleForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const id = ruleIdInput.value;
        const selectedCharIds = Array.from(charBindingList.querySelectorAll('input:checked')).map(cb => cb.value);
        const selectedScopes = Array.from(document.querySelectorAll('input[name="renderer-scope"]:checked')).map(cb => cb.value);
        const selectedFlags = Array.from(document.querySelectorAll('.regex-flags-container input:checked')).map(cb => cb.value);

        const ruleData = {
            name: ruleNameInput.value.trim(),
            regex: ruleRegexInput.value.trim(),
            html: ruleHtmlInput.value,
            trimStrings: ruleTrimInput.value.split('\n').map(s => s.trim()).filter(Boolean),
            enabled: ruleEnabledCheckbox.checked,
            scope: selectedScopes,
            flags: selectedFlags,
            characterIds: selectedCharIds,
            categoryId: currentRendererCategoryId === 'all' ? ((db.rendererCategories && db.rendererCategories[0]?.id) || null) : currentRendererCategoryId,
            priority: parseInt(document.getElementById('renderer-rule-priority').value, 10) || 50 // ä¿å­˜ä¼˜å…ˆçº§
        };
        
        if (!ruleData.name || !ruleData.regex) return showToast('è§„åˆ™åç§°å’Œæ­£åˆ™è¡¨è¾¾å¼ä¸èƒ½ä¸ºç©ºï¼');

        if (id) {
            const index = db.renderers.findIndex(r => r.id === id);
            if (index > -1) db.renderers[index] = { ...db.renderers[index], ...ruleData };
        } else {
            ruleData.id = `rend_rule_${Date.now()}`;
            db.renderers.push(ruleData);
        }

        await saveData();
        showToast('æ¸²æŸ“è§„åˆ™å·²ä¿å­˜ï¼');
        renderRendererRules();
        ruleModal.classList.remove('visible');
    });

    categoryForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const name = categoryNameInput.value.trim();
        if (name && !(db.rendererCategories || []).some(c => c.name === name)) {
            const newCategory = { id: `rend_cat_${Date.now()}`, name };
            db.rendererCategories.push(newCategory);
            await saveData();
            currentRendererCategoryId = newCategory.id;
            renderRendererCategories();
            renderRendererRules();
            showToast(`åˆ†ç±»â€œ${name}â€å·²åˆ›å»º`);
        }
        categoryModal.classList.remove('visible');
    });
    
    // --- å¯¼å…¥åŠŸèƒ½ ---
    importRulesBtn.addEventListener('click', () => importRulesInput.click());
    importRulesInput.addEventListener('change', async (e) => {
        const files = e.target.files;
        if (!files.length) return;

        let importedCount = 0;
        for (const file of files) {
            try {
                const content = await file.text();
                const data = JSON.parse(content);

                // åˆ›å»ºåˆ†ç±»
                const categoryName = data.scriptName;
                let category = (db.rendererCategories || []).find(c => c.name === categoryName);
                if (!category) {
                    category = { id: `rend_cat_${Date.now()}_${importedCount}`, name: categoryName };
                    db.rendererCategories.push(category);
                }

                // è§£æRegex
                const regexMatch = data.findRegex.match(/^\/(.*)\/([gimsuy]*)$/);
                const regex = regexMatch ? regexMatch[1] : data.findRegex;
                const flags = regexMatch ? [...new Set(regexMatch[2].split(''))] : ['g'];
                
                // æ˜ å°„Scope
                const scopeMap = { 1: 'user', 2: 'ai' };
                const scope = (data.placement || [2]).map(p => scopeMap[p]).filter(Boolean);

                const newRule = {
                    id: `rend_rule_import_${Date.now()}_${importedCount}`,
                    name: data.scriptName,
                    regex: regex,
                    html: data.replaceString.replace(/^```html\n|```$/g, ''),
                    trimStrings: data.trimStrings || [],
                    enabled: !data.disabled,
                    scope: scope,
                    flags: flags,
                    characterIds: [], // é»˜è®¤ä¸ç»‘å®šä»»ä½•è§’è‰²
                    categoryId: category.id
                };
                db.renderers.push(newRule);
                importedCount++;
            } catch (err) {
                console.error('å¯¼å…¥æ¸²æŸ“å™¨è§„åˆ™å¤±è´¥:', err);
                showToast(`æ–‡ä»¶ ${file.name} å¯¼å…¥å¤±è´¥`);
            }
        }

        if (importedCount > 0) {
            await saveData();
            renderRendererCategories();
            renderRendererRules();
            showToast(`æˆåŠŸå¯¼å…¥ ${importedCount} æ¡è§„åˆ™ï¼`);
        }
        importRulesInput.value = null; // æ¸…ç©ºä»¥ä¾¿ä¸‹æ¬¡é€‰æ‹©
    });

    // --- äº‹ä»¶ç›‘å¬ ---
    document.querySelector('.app-icon[data-target="renderer-screen"]').addEventListener('click', () => {
        currentRendererCategoryId = 'all';
        renderRendererCategories();
        renderRendererRules();
    });
    addCategoryBtn.addEventListener('click', () => { categoryForm.reset(); categoryModal.classList.add('visible'); });
    addRuleBtn.addEventListener('click', () => openRuleModal(null));
    categoryList.addEventListener('click', e => {
        const item = e.target.closest('.list-item');
        if (item) {
            currentRendererCategoryId = item.dataset.id;
            renderRendererCategories();
            renderRendererRules();
        }
    });
    ruleList.addEventListener('click', e => {
        const item = e.target.closest('.list-item');
        if (item) openRuleModal(item.dataset.id);
    });
    ruleList.addEventListener('contextmenu', e => {
        e.preventDefault();
        const item = e.target.closest('.list-item');
        if (item) {
            const ruleId = item.dataset.id;
            createContextMenu([
                {
                    label: 'åˆ é™¤è§„åˆ™',
                    danger: true,
                    action: async () => {
                        if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è§„åˆ™å—ï¼Ÿ')) {
                            db.renderers = db.renderers.filter(r => r.id !== ruleId);
                            await saveData();
                            renderRendererRules();
                            showToast('è§„åˆ™å·²åˆ é™¤');
                        }
                    }
                }
            ], e.clientX, e.clientY);
        }
    });
}
// END: æ¸²æŸ“å™¨åº”ç”¨æ ¸å¿ƒé€»è¾‘

        
                // START: ä¿®æ”¹åçš„ setupHomeScreen å‡½æ•°
function setupHomeScreen() {
    const getIcon = (id) => db.customIcons[id] || defaultIcons[id]?.url;
    
    // --- æ¸²æŸ“ç¬¬ä¸€é¡µ ---
    const homeScreen1 = document.getElementById('home-screen');
    homeScreen1.innerHTML = `
        <div class="time-widget">
            <div class="date" id="date-display"></div>
            <div class="time" id="time-display"></div>
        </div>
        <div class="home-profile-header">
            <div class="home-hero"></div>
            <div class="home-avatar-wrap">
                <img id="home-profile-avatar" alt="å¤´åƒ" src="https://i.postimg.cc/GtbTnxhP/o-o-1.jpg">
            </div>
            <div class="home-info-card">
                <h2 class="home-profile-name">ç‚¹å‡»è®¾ç½®æ˜µç§°</h2>
                <p class="home-profile-signature">ç‚¹å‡»è®¾ç½®ä¸ªæ€§ç­¾å</p>
            </div>
        </div>
        <div class="main-content-area">
            <div class="left-column">
                <div class="contact-widgets-column">
                 <div class="contact-widget" id="custom-widget-1" data-widget-id="widget1">
                    <img src="https://i.ibb.co/6r11fGg/avatar1.png" alt="è‡ªå®šä¹‰ç»„ä»¶1">
                    <span>è‡ªå®šä¹‰</span>
                </div>
                <div class="contact-widget avatar-right" id="custom-widget-2" data-widget-id="widget2">
                    <img src="https://i.ibb.co/d28n82t/avatar2.png" alt="è‡ªå®šä¹‰ç»„ä»¶2">
                    <span>è‡ªå®šä¹‰</span>
                </div>
                </div>
                <div class="secondary-apps-dock">
                     <a href="#" class="app-icon" data-target="customize-screen"><img src="${getIcon('customize-screen')}" alt="è‡ªå®šä¹‰" class="icon-img"><span class="app-name">${defaultIcons['customize-screen'].name}</span></a>
                     <a href="#" class="app-icon" data-target="wallpaper-screen"><img src="${getIcon('wallpaper-screen')}" alt="å£çº¸" class="icon-img"><span class="app-name">${defaultIcons['wallpaper-screen'].name}</span></a>
                </div>
            </div>

            <div class="right-column">
                <div class="small-app-grid">
                    <a href="#" class="app-icon" data-target="chat-list-screen"><img src="${getIcon('chat-list-screen')}" alt="404" class="icon-img"><span class="app-name">${defaultIcons['chat-list-screen'].name}</span></a>
                    <a href="#" class="app-icon" data-target="api-settings-screen"><img src="${getIcon('api-settings-screen')}" alt="API" class="icon-img"><span class="app-name">${defaultIcons['api-settings-screen'].name}</span></a>
                    <a href="#" class="app-icon" data-target="world-book-screen"><img src="${getIcon('world-book-screen')}" alt="ä¸–ç•Œä¹¦" class="icon-img"><span class="app-name">${defaultIcons['world-book-screen'].name}</span></a>
                    <a href="#" class="app-icon" data-target="tutorial-screen"><img src="${getIcon('tutorial-screen')}" alt="æ•™ç¨‹" class="icon-img"><span class="app-name">${defaultIcons['tutorial-screen'].name}</span></a>
                </div>
                <div id="music-app-widget" class="record-player-widget">
                    <div class="record-sleeve" id="custom-record-sleeve"></div>
                    <div class="vinyl-record">
                        <div class="record-label" id="custom-record-label"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="dock">
            <a href="#" class="app-icon" id="day-mode-btn"><img src="${getIcon('day-mode-btn')}" alt="æ—¥é—´" class="icon-img"></a>
            <a href="#" class="app-icon" id="night-mode-btn"><img src="${getIcon('night-mode-btn')}" alt="å¤œé—´" class="icon-img"></a>
            <a href="#" class="app-icon" data-target="font-settings-screen"><img src="${getIcon('font-settings-screen')}" alt="å­—ä½“" class="icon-img"></a>
<a href="#" class="app-icon" data-target="ai-space-home-screen"><img src="${getIcon('ai-character-select-screen')}" alt="AIç©ºé—´" class="icon-img"></a>
        </div>`;

    // --- æ¸²æŸ“ç¬¬äºŒé¡µ ---
    const homeScreen2 = document.getElementById('home-screen-2');
 homeScreen2.innerHTML = `
        <div class="app-grid" style="margin-top: 80px;">
            <a href="#" class="app-icon" data-target="renderer-screen">
                <img src="${getIcon('renderer-screen')}" alt="æ¸²æŸ“å™¨" class="icon-img">
                <span class="app-name">${defaultIcons['renderer-screen'].name}</span>
            </a>
            <a href="#" class="app-icon" data-target="mall-screen">
                <img src="${getIcon('mall-screen')}" alt="å•†åŸ" class="icon-img">
                <span class="app-name">${defaultIcons['mall-screen'].name}</span>
            </a>
            <a href="#" class="app-icon" id="soul-bond-app-icon">
                <img src="${getIcon('soul-bond-app-icon')}" alt="å¿ƒçµç¾ç»Š" class="icon-img">
                <span class="app-name">${defaultIcons['soul-bond-app-icon'].name}</span>
            </a>
        </div>`;
    // --- ç»‘å®šäº‹ä»¶å’Œåº”ç”¨è®¾ç½® ---
    document.getElementById('custom-record-label').style.backgroundImage = `url('${getIcon('record-label')}')`;
    document.getElementById('custom-record-sleeve').style.backgroundImage = `url('${getIcon('record-sleeve')}')`;

    updateClock();
    applyWallpaper(db.wallpaper, homeScreen1);
    applyWallpaper(db.wallpaper2, homeScreen2);
    applyHomeScreenMode(db.homeScreenMode);

    const widget1Data = db.customWidgets.find(w => w.id === 'widget1');
    const widget2Data = db.customWidgets.find(w => w.id === 'widget2');
    const widget1El = document.getElementById('custom-widget-1');
    const widget2El = document.getElementById('custom-widget-2');

    if (widget1Data && widget1El) {
        widget1El.querySelector('img').src = widget1Data.imageUrl;
        widget1El.querySelector('span').textContent = widget1Data.text;
    }
    if (widget2Data && widget2El) {
        widget2El.querySelector('img').src = widget2Data.imageUrl;
        widget2El.querySelector('span').textContent = widget2Data.text;
    }

    document.getElementById('day-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('day'); });
    document.getElementById('night-mode-btn')?.addEventListener('click', (e) => { e.preventDefault(); applyHomeScreenMode('night'); });
    document.querySelector('[data-target="world-book-screen"]').addEventListener('click', renderWorldBookList);
    document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
    document.querySelector('[data-target="tutorial-screen"]').addEventListener('click', renderTutorialContent);
       
    setupHomeScreenProfileEditor(); 
}
// END: ä¿®æ”¹åçš„ setupHomeScreen å‡½æ•°
        

function applyWallpaper(url, element) {
            if (element) {
                element.style.backgroundImage = `url(${url})`;
            }
        }
// --- æ–°ä»£ç å¼€å§‹ ---
        function applyAiSpaceWallpaper(url) {
            const aiSpaceContent = document.querySelector('#ai-space-home-screen .content');
            if (aiSpaceContent) {
                if (url) {
                    aiSpaceContent.style.backgroundImage = `url(${url})`;
                    aiSpaceContent.style.backgroundSize = 'cover';
                    aiSpaceContent.style.backgroundPosition = 'center';
                    aiSpaceContent.style.backgroundColor = ''; // æ¸…é™¤é»˜è®¤èƒŒæ™¯è‰²
                } else {
                    // å¦‚æœæ²¡æœ‰è®¾ç½®å£çº¸ï¼Œåˆ™æ¢å¤é»˜è®¤æ ·å¼
                    aiSpaceContent.style.backgroundImage = 'none';
                    aiSpaceContent.style.backgroundColor = '#f5f5f5';
                }
            }
        }
// --- æ–°ä»£ç ç»“æŸ ---
        async function applyHomeScreenMode(mode) {
            if (mode === 'day') {
                homeScreen.classList.add('day-mode');
            } else {
                homeScreen.classList.remove('day-mode');
            }
            db.homeScreenMode = mode;
            await saveData();
        }

  function setupCustomizeApp() {
    // ç›‘å¬â€œè‡ªå®šä¹‰â€Appå›¾æ ‡çš„ç‚¹å‡»äº‹ä»¶ï¼Œä»¥ä¾¿åœ¨æ¯æ¬¡è¿›å…¥æ—¶éƒ½é‡æ–°æ¸²æŸ“æœ€æ–°çš„å›¾æ ‡ç½‘æ ¼
    document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
}
// â–¼â–¼â–¼ åœ¨ renderCustomizeForm å‡½æ•°çš„ä¸Šæ–¹ï¼Œæ·»åŠ è¿™ä¸ªæ–°å‡½æ•° â–¼â–¼â–¼
function applyLayoutPreference() {
    const phoneScreen = document.querySelector('.phone-screen');
    if (db.useWechatLayout) {
        phoneScreen.classList.add('wechat-layout-active');
    } else {
        phoneScreen.classList.remove('wechat-layout-active');
    }
}
// â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
// --- æ–°ä»£ç å¼€å§‹ (å®Œæ•´ç‰ˆï¼Œæ— ä»»ä½•çœç•¥) ---
function renderCustomizeForm() {
    const form = document.getElementById('customize-form');
    form.innerHTML = ''; // æ¸…ç©ºæ‰€æœ‰å†…å®¹ï¼Œå‡†å¤‡é‡æ–°æ„å»º

    // ================== ç¬¬1éƒ¨åˆ†ï¼šä¸»å±å¹•å›¾æ ‡è‡ªå®šä¹‰ ==================
    const mainGridTitleHtml = `
        <div style="padding: 0 15px;">
            <p style="font-weight: 600; font-size: 16px; color: var(--secondary-color); margin-bottom: 5px;">ä¸»å±å¹•åŠç»„ä»¶å›¾æ ‡</p>
        </div>
    `;
    form.insertAdjacentHTML('beforeend', mainGridTitleHtml);

    const mainGridContainer = document.createElement('div');
    mainGridContainer.className = 'app-grid';
    mainGridContainer.style.gridTemplateColumns = 'repeat(4, 1fr)';
    mainGridContainer.style.padding = '20px';
    mainGridContainer.style.gap = '15px';
    mainGridContainer.style.marginTop = '10px';
    
    Object.entries(defaultIcons).forEach(([id, { name, url }]) => {
        if (id.startsWith('ai-space-')) return; // æ’é™¤AIæ‰‹æœºçš„å›¾æ ‡
        const currentIcon = db.customIcons[id] || url;
        const iconHTML = `
            <a href="#" class="app-icon" data-icon-id="${id}">
                <img src="${currentIcon}" alt="${name}" class="icon-img">
                <span class="app-name">${name || 'æ¨¡å¼åˆ‡æ¢'}</span>
            </a>`;
        mainGridContainer.innerHTML += iconHTML;
    });
    form.appendChild(mainGridContainer);

    // ================== ç¬¬2éƒ¨åˆ†ï¼šAIæ‰‹æœºå›¾æ ‡è‡ªå®šä¹‰ ==================
    const aiSpaceGridTitleHtml = `
        <hr style="border:none; border-top:1px solid #f0f0f0; margin: 25px 0;">
        <div style="padding: 0 15px;">
            <p style="font-weight: 600; font-size: 16px; color: var(--secondary-color); margin-bottom: 5px;">AIæ‰‹æœºå›¾æ ‡</p>
        </div>
    `;
    form.insertAdjacentHTML('beforeend', aiSpaceGridTitleHtml);

    const aiSpaceGridContainer = document.createElement('div');
    aiSpaceGridContainer.className = 'app-grid';
    aiSpaceGridContainer.style.gridTemplateColumns = 'repeat(4, 1fr)';
    aiSpaceGridContainer.style.padding = '20px';
    aiSpaceGridContainer.style.gap = '15px';
    aiSpaceGridContainer.style.marginTop = '10px';

    Object.entries(defaultIcons).forEach(([id, { name, icon }]) => {
        if (!id.startsWith('ai-space-')) return; // åªé€‰æ‹©AIæ‰‹æœºçš„å›¾æ ‡
        const currentIcon = db.customIcons[id] || icon;
        const iconHTML = `
            <a href="#" class="app-icon" data-icon-id="${id}">
                <img src="${currentIcon}" alt="${name}" class="icon-img">
                <span class="app-name">${name}</span>
            </a>`;
        aiSpaceGridContainer.innerHTML += iconHTML;
    });
    form.appendChild(aiSpaceGridContainer);

    // ================== ç¬¬3éƒ¨åˆ†ï¼šå…¨å±€CSSå’Œå¸ƒå±€åˆ‡æ¢ ==================
    const globalCssHtml = `
        <hr style="border:none; border-top:1px solid #f0f0f0; margin: 25px 0;">
        <div class="global-css-section" style="padding: 0 15px;">
             <p style="font-weight: 600; font-size: 16px; color: var(--secondary-color); margin-bottom: 5px;">å…¨å±€æ ·å¼ (CSS) è‡ªå®šä¹‰</p>
             <p style="font-size: 13px; color: #888; margin-top: 0; margin-bottom: 15px;">è¿™é‡Œçš„ä»£ç ä¼šè¦†ç›–æ•´ä¸ªåº”ç”¨çš„é»˜è®¤æ ·å¼ï¼Œè¯·è°¨æ…ä½¿ç”¨ã€‚</p>
            <textarea id="global-custom-css" rows="12" placeholder="/* ç¤ºä¾‹ï¼šä¿®æ”¹èŠå¤©æ°”æ³¡é¢œè‰² */\n\n.message-bubble.sent {\n  background: linear-gradient(to right, #6a11cb 0%, #2575fc 100%);\n}" style="width: 100%; border-radius: 10px; padding: 10px; border: 2px solid #fce4ec; font-family: monospace; font-size: 13px;"></textarea>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button type="button" class="btn btn-primary" id="apply-global-css-btn" style="flex: 1;">åº”ç”¨æ ·å¼</button>
                <button type="button" class="btn btn-secondary" id="export-global-css-btn" style="flex: 1; margin-bottom: 0;">å¯¼å‡º</button>
                <label for="import-css-input" class="btn btn-neutral" style="flex: 1; margin-bottom: 0;">å¯¼å…¥</label>
            </div>
        </div>
        <input type="file" id="import-css-input" accept=".yu, .css, .txt" style="display: none;">`;
    form.insertAdjacentHTML('beforeend', globalCssHtml);

    const layoutToggleHtml = `
        <hr style="border:none; border-top:1px solid #f0f0f0; margin: 25px 0;">
        <div class="icon-custom-item" style="padding: 0 15px;">
            <div class="icon-details">
                <p>åˆ‡æ¢ä¸ºå¾®ä¿¡è¾“å…¥æ å¸ƒå±€</p>
                <p style="font-size:12px; color:#888; font-weight:normal;">å¯ç”¨åï¼ŒèŠå¤©è¾“å…¥æ å°†å˜ä¸ºå·¦ä¾§â€œ+â€å·ï¼Œå³ä¾§å‘é€çš„æ ·å¼ã€‚</p>
            </div>
            <input type="checkbox" id="toggle-wechat-layout" style="width: auto; height: 24px;">
        </div>`;
    form.insertAdjacentHTML('beforeend', layoutToggleHtml);

    // ================== ç¬¬4éƒ¨åˆ†ï¼šä¸ºæ‰€æœ‰åŠŸèƒ½é‡æ–°ç»‘å®šäº‹ä»¶ ==================
    
    const modal = document.getElementById('customize-icon-modal');
    const fileInput = document.getElementById('customize-icon-upload');
    const modalTitle = document.getElementById('customize-icon-modal-title');
    let currentEditingIconId = null;

    form.addEventListener('click', (e) => {
        const iconLink = e.target.closest('.app-icon[data-icon-id]');
        if (iconLink) {
            e.preventDefault();
            currentEditingIconId = iconLink.dataset.iconId;
            const iconName = iconLink.querySelector('.app-name').textContent;
            modalTitle.textContent = `è‡ªå®šä¹‰ "${iconName}"`;
            modal.classList.add('visible');
        }
    });
    
    document.getElementById('icon-edit-from-url-btn').onclick = async () => {
        const newUrl = prompt('è¯·è¾“å…¥æ–°çš„å›¾æ ‡URL:');
        if (newUrl && newUrl.trim()) {
            db.customIcons[currentEditingIconId] = newUrl.trim();
            await saveData();
            renderCustomizeForm();
            setupHomeScreen();
            renderAiSpaceHomeScreen();
            showToast('å›¾æ ‡å·²æ›´æ–°');
        }
        modal.classList.remove('visible');
    };
    document.getElementById('icon-edit-from-local-btn').onclick = () => {
        fileInput.click();
        modal.classList.remove('visible');
    };
    document.getElementById('icon-edit-reset-btn').onclick = async () => {
        delete db.customIcons[currentEditingIconId];
        await saveData();
        renderCustomizeForm();
        setupHomeScreen();
        renderAiSpaceHomeScreen();
        showToast('å›¾æ ‡å·²æ¢å¤é»˜è®¤');
        modal.classList.remove('visible');
    };
    document.getElementById('icon-edit-cancel-btn').onclick = () => modal.classList.remove('visible');
    modal.onclick = (e) => { if (e.target === modal) modal.classList.remove('visible'); };
    fileInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (file && currentEditingIconId) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 });
                db.customIcons[currentEditingIconId] = compressedUrl;
                await saveData();
                renderCustomizeForm();
                setupHomeScreen();
                renderAiSpaceHomeScreen();
                showToast('å›¾æ ‡å·²æ›´æ–°');
            } catch (error) { showToast('å›¾ç‰‡å¤„ç†å¤±è´¥'); }
        }
        e.target.value = null;
    };

    const cssTextarea = document.getElementById('global-custom-css');
    if (cssTextarea && db.globalCustomCss) {
        cssTextarea.value = db.globalCustomCss;
    }
    document.getElementById('apply-global-css-btn').addEventListener('click', async () => {
        const cssCode = cssTextarea.value;
        db.globalCustomCss = cssCode;
        applyGlobalCss(cssCode);
        await saveData();
        showToast('å…¨å±€æ ·å¼å·²åº”ç”¨å¹¶ä¿å­˜ï¼');
    });
    document.getElementById('export-global-css-btn').addEventListener('click', () => {
        const cssCode = cssTextarea.value;
        if (!cssCode.trim()) { showToast('æ²¡æœ‰å†…å®¹å¯å¯¼å‡ºã€‚'); return; }
        const blob = new Blob([cssCode], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `é¥­ç‰ˆå°æ‰‹æœº_ç¾åŒ–æ ·å¼.yu`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    });
    document.getElementById('import-css-input').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            cssTextarea.value = e.target.result;
            showToast('æ ·å¼å·²å¯¼å…¥ï¼Œè¯·ç‚¹å‡»â€œåº”ç”¨æ ·å¼â€æ¥ä¿å­˜å¹¶æŸ¥çœ‹æ•ˆæœã€‚');
        };
        reader.readAsText(file);
        event.target.value = null;
    });

    const layoutToggle = document.getElementById('toggle-wechat-layout');
    layoutToggle.checked = db.useWechatLayout || false;
    layoutToggle.addEventListener('change', async (e) => {
        db.useWechatLayout = e.target.checked;
        await saveData();
        applyLayoutPreference();
        showToast('å¸ƒå±€å·²åˆ‡æ¢ï¼Œé‡æ–°è¿›å…¥èŠå¤©å®¤ç”Ÿæ•ˆ');
    });
}
// --- æ–°ä»£ç ç»“æŸ ---

// --- æ–°ä»£ç ç»“æŸ ---

        function setupTutorialApp() {
            tutorialContentArea.addEventListener('click', (e) => {
                const header = e.target.closest('.tutorial-header');
                if (header) {
                    header.parentElement.classList.toggle('open');
                }
            });
        }
        let loadingBtn = false

        function renderTutorialContent() {
            const tutorials = [
                {title: 'å†™åœ¨å‰é¢', imageUrls: ['https://i.postimg.cc/7PgyMG9S/image.jpg']},
                {
                    title: 'è½¯ä»¶ä»‹ç»',
                    imageUrls: ['https://i.postimg.cc/VvsJRh6q/IMG-20250713-162647.jpg', 'https://i.postimg.cc/8P5FfxxD/IMG-20250713-162702.jpg', 'https://i.postimg.cc/3r94R3Sn/IMG-20250713-162712.jpg']
                },
                {
                    title: '404',
                    imageUrls: ['https://i.postimg.cc/x8scFPJW/IMG-20250713-162756.jpg', 'https://i.postimg.cc/pX6mfqtj/IMG-20250713-162809.jpg', 'https://i.postimg.cc/YScjV00q/IMG-20250713-162819.jpg', 'https://i.postimg.cc/13VfJw9j/IMG-20250713-162828.jpg']
                },
                {title: '404-ç¾¤èŠ', imageUrls: ['https://i.postimg.cc/X7LSmRTJ/404.jpg']}
            ];
            tutorialContentArea.innerHTML = '';
            tutorials.forEach(tutorial => {
                const item = document.createElement('div');
                item.className = 'tutorial-item';
                const imagesHtml = tutorial.imageUrls.map(url => `<img src="${url}" alt="${tutorial.title}æ•™ç¨‹å›¾ç‰‡">`).join('');
                item.innerHTML = `<div class="tutorial-header">${tutorial.title}</div><div class="tutorial-content">${imagesHtml}</div>`;
                tutorialContentArea.appendChild(item);
            });

            const backupDataBtn = document.createElement('button');
            backupDataBtn.className = 'btn btn-primary';
            backupDataBtn.textContent = 'å¤‡ä»½æ•°æ®';
            backupDataBtn.disabled = loadingBtn

         backupDataBtn.addEventListener('click', async () => {
                if(loadingBtn) return;
                loadingBtn = true;
                try {
                    // æ–°å¢ï¼šæ”¶é›†æ‰€æœ‰localStorageä¸­çš„é¢„è®¾æ•°æ®
                    const localStorageData = {};
                    const presetKeys = ['fontPresets', 'apiPresets', 'bubblePresets', 'myPersonaPresets'];
                    presetKeys.forEach(key => {
                        const data = localStorage.getItem(key);
                        if (data) {
                            localStorageData[key] = data;
                        }
                    });

                    if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                        db.momentsData = await window.AppDB_Moments.moments.toArray();
                    }

                    // æ–°å¢ï¼šåˆ›å»ºä¸€ä¸ªåŒ…å«æ‰€æœ‰æ•°æ®çš„å¤‡ä»½å¯¹è±¡
                    const backupObject = {
                        dbData: db,
                        localStorageData: localStorageData
                    };

                    const jsonString = JSON.stringify(backupObject);
                    const dataBlob = new Blob([jsonString]);
                    const compressionStream = new CompressionStream('gzip');
                    const compressedStream = dataBlob.stream().pipeThrough(compressionStream);
                    const compressedBlob = await new Response(compressedStream).blob();
                    const url = URL.createObjectURL(compressedBlob);
                    const a = document.createElement('a');
                    const now = new Date();
                    a.href = url;
                    a.download = `ç« é±¼å–·å¢¨_å¤‡ä»½æ•°æ®_${now.toISOString().slice(0, 10)}_${now.toTimeString().slice(0, 8).replace(/:/g, '')}.ee`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    if (db.momentsData) {
                        delete db.momentsData;
                    }

                    loadingBtn = false;
                    showToast('å®Œæ•´æ•°æ®å¤‡ä»½æˆåŠŸï¼');
                } catch (e) {
                    showToast(`å¯¼å‡ºå¤±è´¥, å‘ç”Ÿé”™è¯¯: ${e.message}`);
                }
            });

            const importDataBtn = document.createElement('label');
            importDataBtn.className = 'btn btn-neutral';
            importDataBtn.textContent = 'å¯¼å…¥æ•°æ®';
            importDataBtn.style.marginTop = '15px';
            importDataBtn.style.display = 'block';
            importDataBtn.disabled = loadingBtn;
            importDataBtn.setAttribute('for', 'import-data-input');
            
            // --- ä¿®æ”¹ï¼šæ›´æ–°å¯¼å…¥é€»è¾‘ ---
            document.querySelector('#import-data-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if(confirm('æ­¤æ“ä½œå°†è¦†ç›–å½“å‰æ‰€æœ‰æ•°æ®ï¼ˆåŒ…æ‹¬èŠå¤©ã€è®¾ç½®å’Œé¢„è®¾ï¼‰ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ')){
                    try {
                        const decompressionStream = new DecompressionStream('gzip');
                        const decompressedStream = file.stream().pipeThrough(decompressionStream);
                        const jsonString = await new Response(decompressedStream).text();
                        const importedObject = JSON.parse(jsonString);

                        let dbDataToSave;

                        // æ–°å¢ï¼šæ£€æŸ¥æ˜¯æ–°æ ¼å¼è¿˜æ˜¯æ—§æ ¼å¼çš„å¤‡ä»½
                        if (importedObject.dbData) { // æ–°æ ¼å¼
                            // æ¢å¤localStorageä¸­çš„é¢„è®¾
                            if (importedObject.localStorageData) {
                                Object.entries(importedObject.localStorageData).forEach(([key, value]) => {
                                    localStorage.setItem(key, value);
                                });
                            }
                            dbDataToSave = importedObject.dbData;
                        } else { // æ—§æ ¼å¼
                            dbDataToSave = importedObject;
                            showToast('æç¤ºï¼šæ­£åœ¨å¯¼å…¥æ—§ç‰ˆå¤‡ä»½ï¼Œéƒ¨åˆ†è®¾ç½®ï¼ˆå¦‚é¢„è®¾ï¼‰å¯èƒ½ä¸ä¼šè¢«æ¢å¤ã€‚');
                        }

                        // æ¸…ç©ºæ—§æ•°æ®
                        await dataStorage.clearAll();
                        if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                            await window.AppDB_Moments.moments.clear();
                        }
                        
                        // æ¢å¤åŠ¨æ€æ•°æ®
                        if (dbDataToSave.momentsData && Array.isArray(dbDataToSave.momentsData)) {
                             if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                                await window.AppDB_Moments.moments.bulkPut(dbDataToSave.momentsData);
                            }
                            delete dbDataToSave.momentsData;
                        }
                        
                        // ä¿å­˜æ–°çš„ä¸»æ•°æ®
                        await saveData(dbDataToSave);
                        showToast(`æ•°æ®å·²æˆåŠŸæ¢å¤ã€‚åº”ç”¨å³å°†åˆ·æ–°ã€‚`);
                        setTimeout(() => window.location.reload(), 1500);

                    } catch (error) {
                        console.error("å¯¼å…¥å¤±è´¥:", error);
                        showToast(`å¯¼å…¥æˆ–è§£ææ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`);
                    } finally {
                        event.target.value = null;
                    }
                } else {
                    event.target.value = null;
                }
            });

            tutorialContentArea.appendChild(backupDataBtn);
            tutorialContentArea.appendChild(importDataBtn);
        }
// ===============================================================
// START: è§’è‰²å¡å¯¼å…¥åŠŸèƒ½ (ç²˜è´´åˆ° setupChatListScreen å‡½æ•°ä¸Šæ–¹)
// ===============================================================
/**
         * åœ¨å½“å‰èŠå¤©è®°å½•ä¸­æ‰§è¡Œæœç´¢
         * @param {string} query - æœç´¢å…³é”®è¯
         */
        async function performSearch(query) {
            showToast('æ­£åœ¨æœç´¢...');
            const results = [];
            const lowerCaseQuery = query.toLowerCase();
            
            // ç›´æ¥è·å–å½“å‰èŠå¤©å¯¹è±¡
            const chat = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId)
                : db.groups.find(g => g.id === currentChatId);

            if (!chat) {
                showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°å½“å‰èŠå¤©');
                return;
            }

            const history = await dataStorage.getChatMessages(chat.id, currentChatType);
            
            for (const message of history) {
                let contentToSearch = message.content || '';
                // å‰¥ç¦»æ¶ˆæ¯å¤–å£³ï¼Œåªæœç´¢çº¯æ–‡æœ¬å†…å®¹
                const contentMatch = contentToSearch.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/);
                if (contentMatch) {
                    contentToSearch = contentMatch[1];
                }
                
                if (contentToSearch.toLowerCase().includes(lowerCaseQuery)) {
                    results.push({
                        message,
                        chatId: chat.id,
                        chatType: currentChatType,
                        chatName: chat.name || chat.remarkName,
                        chatAvatar: chat.avatar
                    });
                }
            }
            
            renderSearchResults(results, query);
            switchScreen('search-results-screen');
        }
/**
 * å¤„ç†ä»æ–‡ä»¶è¾“å…¥æ¡†é€‰æ‹©çš„è§’è‰²å¡æ–‡ä»¶
 * @param {Event} event - æ–‡ä»¶è¾“å…¥æ¡†çš„ change äº‹ä»¶
 */
function handleCardImport(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (file.name.endsWith('.png')) {
        handlePngImport(file);
    } else if (file.name.endsWith('.json')) {
        handleJsonImport(file);
    } else {
        showToast('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œè¯·é€‰æ‹© .png æˆ– .json æ–‡ä»¶');
    }

    // æ¸…ç©ºè¾“å…¥æ¡†ï¼Œä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥é€‰æ‹©ç›¸åŒçš„æ–‡ä»¶
    event.target.value = null;
}

/**
 * å¤„ç† .json æ ¼å¼çš„è§’è‰²å¡
 * @param {File} file - ç”¨æˆ·é€‰æ‹©çš„ .json æ–‡ä»¶
 */
function handleJsonImport(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const cardData = JSON.parse(e.target.result);
            // JSON æ–‡ä»¶æ²¡æœ‰å†…åµŒå›¾ç‰‡ï¼Œä½¿ç”¨é»˜è®¤å¤´åƒ
            const defaultAvatar = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            createCharacterFromCard(cardData, defaultAvatar);
        } catch (error) {
            console.error("JSON è§£æå¤±è´¥:", error);
            showToast(`å¯¼å…¥å¤±è´¥: ${error.message}`);
        }
    };
    reader.readAsText(file);
}

/**
 * å¤„ç† .png æ ¼å¼çš„è§’è‰²å¡ (åŒ…å«å›¾ç‰‡å’Œå†…ç½®æ•°æ®) - å·²ä¿®æ­£ä¹±ç é—®é¢˜
 * @param {File} file - ç”¨æˆ·é€‰æ‹©çš„ .png æ–‡ä»¶
 */
function handlePngImport(file) {
    // ç¬¬ä¸€æ­¥ï¼šè¯»å–å›¾ç‰‡æœ¬èº«ä½œä¸ºå¤´åƒ
    const imageReader = new FileReader();
    imageReader.readAsDataURL(file);
    imageReader.onload = (e) => {
        const avatarUrl = e.target.result;

        // ç¬¬äºŒæ­¥ï¼šè¯»å–æ–‡ä»¶å†…å®¹ä»¥æå–å†…ç½®çš„JSONæ•°æ®
        const dataReader = new FileReader();
        dataReader.onload = (e) => {
            try {
                const text = e.target.result;
                // SillyTavern å°† Base64 ç¼–ç çš„ JSON å­˜å‚¨åœ¨ "chara" å…³é”®è¯ä¹‹å
                const keyword = "chara";
                const startIndex = text.indexOf(keyword);

                if (startIndex === -1) {
                    throw new Error("PNGå¡ç‰‡ä¸­æœªæ‰¾åˆ° 'chara' æ•°æ®å—ã€‚");
                }

                // æå–å¯èƒ½æ˜¯ Base64 çš„é•¿å­—ç¬¦ä¸²
                const b64Regex = /[A-Za-z0-9+/=]{200,}/g; // æŸ¥æ‰¾è¶³å¤Ÿé•¿çš„Base64å­—ç¬¦ä¸²
                const textAfterKeyword = text.substring(startIndex + keyword.length);
                const match = textAfterKeyword.match(b64Regex);

                if (!match) {
                    throw new Error("æ— æ³•ä»PNGä¸­æå–è§’è‰²æ•°æ®ã€‚");
                }

                // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ­£ï¼šä½¿ç”¨ TextDecoder å¤„ç† UTF-8 ç¼–ç  â–¼â–¼â–¼
                const b64Decoded = atob(match[0]); // Base64è§£ç ä¸ºäºŒè¿›åˆ¶å­—ç¬¦ä¸²
                // å°†äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºUint8Arrayå­—èŠ‚æ•°ç»„
                const uint8Array = new Uint8Array(b64Decoded.length).map((_, i) => b64Decoded.charCodeAt(i));
                // ä½¿ç”¨UTF-8è§£ç å™¨å°†å­—èŠ‚æ•°ç»„è½¬æ¢ä¸ºæ­£ç¡®çš„å­—ç¬¦ä¸²
                const utf8String = new TextDecoder('utf-8').decode(uint8Array);
                const cardData = JSON.parse(utf8String);
                // â–²â–²â–² ä¿®æ­£ç»“æŸ â–²â–²â–²

                createCharacterFromCard(cardData, avatarUrl);
            } catch (error) {
                console.error("PNG æ•°æ®æå–æˆ–è§£æå¤±è´¥:", error);
                showToast(`å¯¼å…¥å¤±è´¥: ${error.message}`);
            }
        };
        // æ³¨æ„ï¼šè¿™é‡Œä»ç„¶ä½¿ç”¨ 'latin1' æ¥è¯»å–åŸå§‹å­—èŠ‚æµï¼Œè¿™æ˜¯æ­£ç¡®çš„
        dataReader.readAsText(file, 'latin1');
    };
}
/**
 * æ ¹æ®è§£æå‡ºçš„è§’è‰²å¡æ•°æ®å’Œå¤´åƒURLï¼Œåˆ›å»ºæ–°è§’è‰²å’Œä¸–ç•Œä¹¦ï¼ˆå·²æ›´æ–°åˆ†ç±»å’Œæ¡ç›®æ‹†åˆ†é€»è¾‘ï¼‰
 * @param {object} cardData - ä» .json æˆ– .png ä¸­è§£æå‡ºçš„è§’è‰²æ•°æ®å¯¹è±¡
 * @param {string} avatarUrl - è§’è‰²çš„å¤´åƒ Data URL æˆ–é»˜è®¤ URL
 */
async function createCharacterFromCard(cardData, avatarUrl) {
    // å…¼å®¹ä¸åŒç‰ˆæœ¬çš„è§’è‰²å¡æ ¼å¼ (v2/v3)
    const data = cardData.data || cardData;
    if (!data || !data.name) {
        showToast('å¯¼å…¥å¤±è´¥ï¼šè§’è‰²å¡æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘åç§°ã€‚');
        return;
    }

    // ç”¨äºæ”¶é›†æ‰€æœ‰æ–°åˆ›å»ºçš„ä¸–ç•Œä¹¦æ¡ç›®IDï¼Œä»¥ä¾¿å…³è”åˆ°è§’è‰²
    const worldBookIds = [];

    // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹é€»è¾‘å¼€å§‹ â–¼â–¼â–¼
    if (data.character_book && data.character_book.entries && data.character_book.entries.length > 0) {
        
        // 1. ä¸ºè¯¥è§’è‰²åˆ›å»ºä¸€ä¸ªæ–°çš„ä¸–ç•Œä¹¦åˆ†ç±»
        const categoryName = `${data.name} - ä¸–ç•Œä¹¦`;
        const newCategory = {
            id: `cat_${Date.now()}`,
            name: categoryName,
            isCollapsed: false // é»˜è®¤å±•å¼€
        };
        db.worldBookCategories.push(newCategory);
        showToast(`å·²è‡ªåŠ¨åˆ›å»ºåˆ†ç±»: "${categoryName}"`);

        let entryCounter = 1; // ç”¨äºå‘½åæ‹†åˆ†åçš„æ¡ç›®

        // 2. éå†æ‰€æœ‰ä¸–ç•Œä¹¦æ¡ç›®
        for (const entry of data.character_book.entries) {
            if (!entry.content) continue;

            // 3. ä½¿ç”¨ "---" åˆ†å‰²å†…å®¹ï¼Œå¹¶æ¸…ç†ç©ºæ•°æ®
            const contentParts = entry.content.split('---')
                .map(part => part.trim()) // å»é™¤æ¯ä¸ªéƒ¨åˆ†å‰åçš„ç©ºæ ¼
                .filter(part => part.length > 0); // è¿‡æ»¤æ‰ç©ºçš„éƒ¨åˆ†

            // 4. ä¸ºæ¯ä¸ªåˆ†å‰²åçš„å†…å®¹éƒ¨åˆ†åˆ›å»ºç‹¬ç«‹çš„ä¸–ç•Œä¹¦æ¡ç›®
            for (const partContent of contentParts) {
                const newWorldBook = {
                    id: `wb_${Date.now()}_${entryCounter}`,
                    name: `${data.name} - æ¡ç›® ${entryCounter}`, // è‡ªåŠ¨å‘½å
                    content: partContent,
                    position: 'before', // é»˜è®¤å‰ç½®æ³¨å…¥
                    categoryId: newCategory.id // å…³è”åˆ°æ–°åˆ›å»ºçš„åˆ†ç±»
                };
                db.worldBooks.push(newWorldBook);
                worldBookIds.push(newWorldBook.id); // æ”¶é›†IDç”¨äºè§’è‰²å…³è”
                entryCounter++;
            }
        }
    }
    // â–²â–²â–² æ ¸å¿ƒä¿®æ”¹é€»è¾‘ç»“æŸ â–²â–²â–²

    // åˆ›å»ºæ–°è§’è‰²å¯¹è±¡
    const newChar = {
        id: `char_${Date.now()}`,
        realName: data.name,
        isOfflineMode: false,
        remarkName: data.name,
        persona: data.description || '',
        avatar: avatarUrl,
        myName: 'æˆ‘',
        myPersona: '',
        myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
        theme: 'white_pink',
        maxMemory: 10,
        chatBg: '',
        history: [],
        diaries: [],
        messageCountSinceLastDiary: 0,
        isPinned: false,
        status: 'åœ¨çº¿',
        worldBookIds: worldBookIds, // å…³è”æ‰€æœ‰æ–°åˆ›å»ºçš„ä¸–ç•Œä¹¦æ¡ç›®ID
        useCustomBubbleCss: false,
        customBubbleCss: '',
        pendingMessages: [],
        aiProactiveChatEnabled: false, // æ–°å¢
    aiProactiveChatDelay: 0,      // æ–°å¢
        isBlockedByUser: false,
        isBlockedByAi: false,
        userBlockTimestamp: null,
        aiBlockTimestamp: null,
        blockEndTime: null,
    };
if (data.character_book && data.character_book.entries && data.character_book.entries.length > 0) {
        const regexEntries = data.character_book.entries.filter(entry => entry.use_regex && entry.keys.length > 0 && entry.content);
        if (regexEntries.length > 0) {
            // ä¸ºè¯¥è§’è‰²åˆ›å»ºä¸€ä¸ªæ¸²æŸ“å™¨åˆ†ç±»
            const categoryName = data.name;
            let category = db.rendererCategories.find(c => c.name === categoryName);
            if (!category) {
                category = {
                    id: `rend_cat_${Date.now()}`,
                    name: categoryName
                };
                db.rendererCategories.push(category);
            }

            regexEntries.forEach((entry, index) => {
                const newRule = {
                    id: `rend_rule_${Date.now()}_${index}`,
                    name: entry.comment || `${data.name} è§„åˆ™ ${index + 1}`,
                    regex: entry.keys.join('|'),
                    html: entry.content,
                    characterIds: [newChar.id], // è‡ªåŠ¨ç»‘å®šåˆ°æ–°åˆ›å»ºçš„è§’è‰²
                    enabled: entry.enabled,
                    categoryId: category.id
                };
                db.renderers.push(newRule);
            });
            showToast(`å·²ä¸ºâ€œ${data.name}â€è‡ªåŠ¨å¯¼å…¥ ${regexEntries.length} æ¡æ¸²æŸ“è§„åˆ™ï¼`);
        }
    }
    // æ·»åŠ åˆ°æ•°æ®åº“å¹¶ä¿å­˜
    db.characters.push(newChar);
    await saveData();

    // åˆ·æ–°UI
    renderChatList();
    showToast(`è§’è‰²â€œ${newChar.remarkName}â€å·²æˆåŠŸå¯¼å…¥ï¼`);
}

/**
         * è®¾ç½®èŠå¤©å†…æœç´¢åŠŸèƒ½
         */
        function setupSearchInChat() {
            // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œå› ä¸ºä¸¤ä¸ªè®¾ç½®é¢æ¿é‡Œéƒ½æœ‰æœç´¢æŒ‰é’®
            document.body.addEventListener('click', (e) => {
                if (e.target.id === 'search-history-btn' || e.target.id === 'search-group-history-btn') {
                    // å…³é—­è®¾ç½®ä¾§è¾¹æ 
                    const openSidebar = document.querySelector('.settings-sidebar.open');
                    if (openSidebar) {
                        openSidebar.classList.remove('open');
                    }
                    searchModal.classList.add('visible');
                    searchModalInput.focus();
                }
            });

            // æœç´¢è¡¨å•æäº¤
            searchModalForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const query = searchModalInput.value.trim();
                if (query) {
                    performSearch(query);
                    searchModal.classList.remove('visible');
                    searchModalForm.reset();
                }
            });

            // ç‚¹å‡»å¼¹çª—å¤–éƒ¨å…³é—­
            searchModal.addEventListener('click', (e) => {
                if (e.target === searchModal) {
                    searchModal.classList.remove('visible');
                }
            });

            // ä¸ºæœç´¢ç»“æœåˆ—è¡¨æ·»åŠ ç‚¹å‡»äº‹ä»¶å§”æ‰˜
            searchResultsList.addEventListener('click', (e) => {
                const resultItem = e.target.closest('.search-result-item');
                if (resultItem) {
                    const { chatId, chatType, messageId } = resultItem.dataset;
                    // è®¾ç½®ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œç”¨äºå‘ŠçŸ¥ openChatRoom éœ€è¦è·³è½¬
                    window.targetMessageId = messageId; 
                    openChatRoom(chatId, chatType);
                }
            });
        }

        // --- Chat List & Chat Room ---
        function setupChatListScreen() {
            renderChatList();
            addChatBtn.addEventListener('click', () => {
                addCharModal.classList.add('visible');
                addCharForm.reset();
            });
            chatListContainer.addEventListener('click', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    currentChatId = chatItem.dataset.id;
                    currentChatType = chatItem.dataset.type;
                    openChatRoom(currentChatId, currentChatType);
                }
            });
            chatListContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, e.clientX, e.clientY);
            });
            chatListContainer.addEventListener('touchstart', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, touch.clientX, touch.clientY);
                }, 400);
            });
            chatListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
            chatListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
        }
/**
         * åœ¨å½“å‰èŠå¤©è®°å½•ä¸­æ‰§è¡Œæœç´¢
         * @param {string} query - æœç´¢å…³é”®è¯
         */
        async function performSearch(query) {
            showToast('æ­£åœ¨æœç´¢...');
            const results = [];
            const lowerCaseQuery = query.toLowerCase();
            
            // ç›´æ¥è·å–å½“å‰èŠå¤©å¯¹è±¡
            const chat = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId)
                : db.groups.find(g => g.id === currentChatId);

            if (!chat) {
                showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°å½“å‰èŠå¤©');
                return;
            }

            const history = await dataStorage.getChatMessages(chat.id, currentChatType);
            
            for (const message of history) {
                let contentToSearch = message.content || '';
                // å‰¥ç¦»æ¶ˆæ¯å¤–å£³ï¼Œåªæœç´¢çº¯æ–‡æœ¬å†…å®¹
                const contentMatch = contentToSearch.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/);
                if (contentMatch) {
                    contentToSearch = contentMatch[1];
                }
                
                if (contentToSearch.toLowerCase().includes(lowerCaseQuery)) {
                    results.push({
                        message,
                        chatId: chat.id,
                        chatType: currentChatType,
                        chatName: chat.name || chat.remarkName,
                        chatAvatar: chat.avatar
                    });
                }
            }
            
            renderSearchResults(results, query);
            switchScreen('search-results-screen');
        }

        /**
         * æ¸²æŸ“æœç´¢ç»“æœåˆ—è¡¨
         * @param {Array} results - æœç´¢åˆ°çš„ç»“æœæ•°ç»„
         * @param {string} query - åŸå§‹æœç´¢å…³é”®è¯ï¼Œç”¨äºé«˜äº®
         */
        function renderSearchResults(results, query) {
            searchResultsList.innerHTML = '';
            noResultsPlaceholder.style.display = results.length === 0 ? 'block' : 'none';

            // æŒ‰æ—¶é—´å€’åºæ’åˆ—ç»“æœ
            results.sort((a, b) => b.message.timestamp - a.message.timestamp);

            const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

            for (const result of results) {
                const li = document.createElement('li');
                li.className = 'list-item search-result-item';
                li.dataset.chatId = result.chatId;
                li.dataset.chatType = result.chatType;
                li.dataset.messageId = result.message.id;

                let previewText = result.message.content || '';
                const match = previewText.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/);
                if (match) {
                    previewText = match[1];
                }

                // é«˜äº®å…³é”®è¯
                const highlightedText = escapeHTML(previewText).replace(regex, (match) => `<span class="highlight">${match}</span>`);
                
                const date = new Date(result.message.timestamp);
                const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;

                li.innerHTML = `
                    <img src="${result.chatAvatar}" alt="${result.chatName}" class="chat-avatar ${result.chatType === 'group' ? 'group-avatar' : ''}">
                    <div class="item-details">
                        <div class="item-details-row">
                            <span class="item-name">${result.chatName}</span>
                            <span class="item-preview">${dateString}</span>
                        </div>
                        <div class="item-preview search-preview">${highlightedText}</div>
                    </div>
                `;
                searchResultsList.appendChild(li);
            }
        }
        function handleChatListLongPress(chatId, chatType, x, y) {
            clearTimeout(longPressTimer);
            const chatItem = (chatType === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chatItem) return;
            const itemName = chatType === 'private' ? chatItem.remarkName : chatItem.name;
            const menuItems = [{
                label: chatItem.isPinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶èŠå¤©',
                action: async () => {
                    chatItem.isPinned = !chatItem.isPinned;
                    await saveData();
                    renderChatList();
                }
            }, {
                label: 'åˆ é™¤èŠå¤©',
                danger: true,
                action: async () => {
                    if (confirm(`ç¡®å®šè¦åˆ é™¤ä¸"${itemName}"çš„èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`)) {
                        // 1. ä»å†…å­˜æ•°ç»„ä¸­ç§»é™¤
                        if (chatType === 'private') {
                            db.characters = db.characters.filter(c => c.id !== chatId);
                        } else {
                            db.groups = db.groups.filter(g => g.id !== chatId);
                        }
                        
                        // 2. æ¸…é™¤ IndexedDB ä¸­çš„æ¶ˆæ¯å—ï¼ˆå…³é”®æ­¥éª¤ï¼ï¼‰
                        await dataStorage.clearChatMessages(chatId, chatType);
                        
                        // 3. åˆ é™¤ IndexedDB ä¸­çš„è§’è‰²/ç¾¤ç»„åŸºç¡€æ•°æ®
                        const dataKey = chatType === 'private' ? `character_${chatId}` : `group_${chatId}`;
                        await dataStorage.removeData(dataKey);
                        
                        // 4. ä¿å­˜æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
                        await saveData();
                        
                        // 5. åˆ·æ–°åˆ—è¡¨
                        renderChatList();
                        showToast('èŠå¤©å·²åˆ é™¤');
                    }
                }
            }];
            createContextMenu(menuItems, x, y);
        }

        function renderChatList() {
            chatListContainer.innerHTML = '';
            const allChats = [...db.characters.map(c => ({...c, type: 'private'})), ...db.groups.map(g => ({
                ...g,
                type: 'group'
            }))];
            noChatsPlaceholder.style.display = (db.characters.length + db.groups.length) === 0 ? 'block' : 'none';
            const sortedChats = allChats.sort((a, b) => {
                if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
                const lastMsgTimeA = a.history && a.history.length > 0 ? a.history[a.history.length - 1].timestamp : 0;
                const lastMsgTimeB = b.history && b.history.length > 0 ? b.history[b.history.length - 1].timestamp : 0;
                return lastMsgTimeB - lastMsgTimeA;
            });
            // â–¼â–¼â–¼ æ€§èƒ½ä¼˜åŒ–ï¼šåœ¨å¾ªç¯å¤–è·å–ä¸€æ¬¡ä¼´ä¾£åå†Œ â–¼â–¼â–¼
            const roster = updateBondRoster(null, 'get');
            // â–²â–²â–² æ€§èƒ½ä¼˜åŒ–ç»“æŸ â–²â–²â–²
            sortedChats.forEach(chat => {
                let lastMessageText = 'å¼€å§‹èŠå¤©å§...';
                if (chat.history && chat.history.length > 0) {
                const invisibleRegex = /\[[\s\S]*?(?:æ¥æ”¶|é€€å›)[\s\S]*?çš„è½¬è´¦\]|\[[\s\S]*?æ›´æ–°çŠ¶æ€ä¸ºï¼š[\s\S]*?\]|\[[\s\S]*?å·²æ¥æ”¶ç¤¼ç‰©\]|\[system:[\s\S]*?\]|\[system-context-only:[\s\S]*?\]|\[[\s\S]*?é‚€è¯·[\s\S]*?åŠ å…¥äº†ç¾¤èŠ\]|\[[\s\S]*?ä¿®æ”¹ç¾¤åä¸ºï¼š[\s\S]*?\]|\[system-display:[\s\S]*?\]/;
                    const visibleHistory = chat.history.filter(msg => !invisibleRegex.test(msg.content));
                    if (visibleHistory.length > 0) {
                        const lastMsg = visibleHistory[visibleHistory.length - 1];
                        const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
                        const imageRecogRegex = /\[.*?å‘æ¥äº†ä¸€å¼ å›¾ç‰‡ï¼š\]/
                        const voiceRegex = /\[.*?çš„è¯­éŸ³ï¼š.*?\]/;
                        const photoVideoRegex = /\[.*?å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘ï¼š.*?\]/;
                        const transferRegex = /\[.*?çš„è½¬è´¦ï¼š.*?å…ƒ.*?\]|\[.*?ç»™ä½ è½¬è´¦ï¼š.*?å…ƒ.*?\]|\[.*?å‘.*?è½¬è´¦ï¼š.*?å…ƒ.*?\]/;
                        const stickerRegex = /\[.*?çš„è¡¨æƒ…åŒ…ï¼š.*?\]|\[.*?å‘é€çš„è¡¨æƒ…åŒ…ï¼š.*?\]/;
                        const giftRegex = /\[.*?é€æ¥çš„ç¤¼ç‰©ï¼š.*?\]|\[.*?å‘.*?é€æ¥äº†ç¤¼ç‰©ï¼š.*?\]/;



                        if (giftRegex.test(lastMsg.content)) {
                            lastMessageText = '[ç¤¼ç‰©]';
                        } else if (stickerRegex.test(lastMsg.content)) {
                            lastMessageText = '[è¡¨æƒ…åŒ…]';
                        } else if (voiceRegex.test(lastMsg.content)) {
                            lastMessageText = '[è¯­éŸ³]';
                        } else if (photoVideoRegex.test(lastMsg.content)) {
                            lastMessageText = '[ç…§ç‰‡/è§†é¢‘]';
                        } else if (transferRegex.test(lastMsg.content)) {
                            lastMessageText = '[è½¬è´¦]';
                        } else if (imageRecogRegex.test(lastMsg.content) || (lastMsg.parts && lastMsg.parts.some(p => p.type === 'image'))) {
                            lastMessageText = '[å›¾ç‰‡]';
                        }else if ((lastMsg.parts && lastMsg.parts.some(p => p.type === 'html'))) {
                            lastMessageText = '[äº’åŠ¨]';
                        } else {
                            const textMatch = lastMsg.content.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+)\]/);
                            let text = textMatch ? textMatch[1].trim() : lastMsg.content.trim();
                            lastMessageText = urlRegex.test(text) ? '[å›¾ç‰‡]' : text;
                        }
                    } else {
                        const lastEverMsg = chat.history[chat.history.length - 1];
                        const inviteRegex = /\[(.*?)é‚€è¯·(.*?)åŠ å…¥äº†ç¾¤èŠ\]/;
                        const renameRegex = /\[.*?ä¿®æ”¹ç¾¤åä¸ºï¼š.*?\]/;
                        const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
                        const timeSkipMatch = lastEverMsg.content.match(timeSkipRegex);

                        if (timeSkipMatch) {
                            lastMessageText = timeSkipMatch[1];
                        } else if (inviteRegex.test(lastEverMsg.content)) {
                            lastMessageText = 'æ–°æˆå‘˜åŠ å…¥äº†ç¾¤èŠ';
                        } else if (renameRegex.test(lastEverMsg.content)) {
                            lastMessageText = 'ç¾¤èŠåç§°å·²ä¿®æ”¹';
                        }
                    }
                }
                const li = document.createElement('li');
                li.className = 'list-item chat-item';
                if (chat.isPinned) li.classList.add('pinned');
                li.dataset.id = chat.id;
                li.dataset.type = chat.type;
                const avatarClass = chat.type === 'group' ? 'group-avatar' : '';
                const itemName = chat.type === 'private' ? chat.remarkName : chat.name;
                    // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹ 1ï¼šä½¿ç”¨æ–°çš„SVGå›¾æ ‡ â–¼â–¼â–¼
        let soulBondIconHTML = '';
        if (chat.type === 'private') {
            // â–¼â–¼â–¼ UIæ˜¾ç¤ºä¿®å¤ï¼šæ˜¾ç¤ºæ‰€æœ‰å·²ç»‘å®šçš„ä¼´ä¾£ï¼ˆåŒ…æ‹¬ä¼‘çœ çŠ¶æ€ï¼‰â–¼â–¼â–¼
            // åªè¦è§’è‰²IDåœ¨åå†Œé‡Œï¼Œæˆ–è€…çŠ¶æ€ä¸º activeï¼Œéƒ½æ˜¾ç¤ºçˆ±å¿ƒ
            if (roster.includes(chat.id) || chat.soulBondStatus === 'active') {
                soulBondIconHTML = `
                    <span class="soul-bond-icon" data-char-id="${chat.id}" title="è§£é™¤å¿ƒåŠ¨å…³ç³»">
                        <svg class="soul-bond-icon-svg" viewBox="0 0 24 24">
                            <path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"></path>
                        </svg>
                    </span>`;
            }
            // â–²â–²â–² UIæ˜¾ç¤ºä¿®å¤ç»“æŸ â–²â–²â–²
        }
        // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²
                const pinBadgeHTML = chat.isPinned ? '<span class="pin-badge">ç½®é¡¶</span>' : '';
                // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹ 2ï¼šåœ¨HTMLç»“æ„ä¸­æ’å…¥å›¾æ ‡ â–¼â–¼â–¼
        li.innerHTML = `
            <img src="${chat.avatar}" alt="${itemName}" class="chat-avatar ${avatarClass}">
            <div class="item-details">
                <div class="item-details-row">
                    <div class="item-name">${itemName}</div>
                    ${soulBondIconHTML}
                </div>
                <div class="item-preview-wrapper">
                    <div class="item-preview">${lastMessageText}</div>
                    ${pinBadgeHTML}
                </div>
            </div>`;
        // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²
                chatListContainer.appendChild(li);
            });
      document.querySelectorAll('.soul-bond-icon').forEach(icon => {
        icon.style.cursor = 'pointer';
        icon.addEventListener('click', async (e) => {
            e.stopPropagation();
            
            const charId = e.currentTarget.dataset.charId;
            const character = db.characters.find(c => c.id === charId);
            if (!character) return;
            
            if (confirm(`ä½ ç¡®å®šè¦ä¸ ${character.remarkName} è§£é™¤å¿ƒåŠ¨å…³ç³»å—ï¼Ÿ`)) {
                // ä»ä¼´ä¾£åå†Œä¸­ç§»é™¤
                updateBondRoster(charId, 'remove');
                
                // æ›´æ–°è§’è‰²çŠ¶æ€
                character.isSoulBound = false;
                character.soulBondStatus = 'none';

                // åˆ›å»ºå¹¶æ³¨å…¥ä¸€æ¡é€šçŸ¥AIçš„ç³»ç»Ÿæ¶ˆæ¯
                const systemContent = `[system: ${character.myName} å·²ä¸ä½ è§£é™¤å¿ƒåŠ¨å…³ç³»ã€‚]`;
                const contextMessage = {
                    id: `msg_unbond_ctx_${Date.now()}`,
                    role: 'user',
                    content: systemContent,
                    parts: [{ type: 'text', text: systemContent }],
                    timestamp: Date.now()
                };
                character.history.push(contextMessage);

                // ä¿å­˜æ‰€æœ‰æ›´æ”¹
                await saveData();
                
                // åˆ·æ–°UIå¹¶æç¤ºç”¨æˆ·
                renderChatList();
                showToast('å¿ƒåŠ¨å…³ç³»å·²è§£é™¤');
            }
        });
    });
    // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²
        }
// åœ¨ setupChatListScreen() å‡½æ•°çš„æœ«å°¾æ·»åŠ 

const importCardBtn = document.getElementById('import-card-btn');
const cardImportInput = document.getElementById('card-import-input');

if (importCardBtn && cardImportInput) {
    importCardBtn.addEventListener('click', () => {
        cardImportInput.click();
    });
    cardImportInput.addEventListener('change', handleCardImport);
}
        function setupAddCharModal() {
            addCharForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newChar = {
isBlockedByUser: false,
isBlockedByAi: false,
userBlockTimestamp: null,
aiBlockTimestamp: null,
blockEndTime: null,
isOfflineMode: false,
                    id: `char_${Date.now()}`,
                    realName: document.getElementById('char-real-name').value,
                    remarkName: document.getElementById('char-remark-name').value,
                    persona: '',
                    avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    myName: document.getElementById('my-name-for-char').value,
                    myPersona: '',
                    myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    diaries: [],
    messageCountSinceLastDiary: 0,
    // --- æ·»åŠ ç»“æŸ ---
                    isPinned: false,
                    status: 'åœ¨çº¿',
                    worldBookIds: [],
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    pendingMessages: [],
                    aiProactiveChatEnabled: false,
                    aiProactiveChatDelay: 0,
                    aiProactiveChatInterval: 0,
                };
                db.characters.push(newChar);
                await saveData();
                renderChatList();
                addCharModal.classList.remove('visible');
                showToast(`è§’è‰²â€œ${newChar.remarkName}â€åˆ›å»ºæˆåŠŸï¼`);
            });
        }
// --- åœ¨ setupChatRoom() å‡½æ•°çš„å‰é¢ï¼Œç²˜è´´ä¸‹é¢çš„ä»£ç å— ---

function startQuoteReply(messageId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    // æå–å¹²å‡€çš„æ–‡æœ¬å†…å®¹ç”¨äºé¢„è§ˆ
    let previewText = message.content;
    const regexes = [
        /\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/,
        /\[.*?çš„è¯­éŸ³ï¼š([\s\S]+?)\]/,
        /\[.*?å¼•ç”¨äº†â€œ.*?â€çš„æ¶ˆæ¯?å¹¶å›å¤ï¼š([\s\S]+?)\]/,
        /\[.*?å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘ï¼š([\s\S]+?)\]/
    ];

    for (const regex of regexes) {
        const match = message.content.match(regex);
        if (match) {
            previewText = match[1];
            break;
        }
    }
    
    if (message.parts && message.parts.some(p => p.type === 'image')) {
        previewText = '[å›¾ç‰‡]';
    } else if (message.quote) {
        previewText = message.replyText;
    }

    currentQuotedMessageId = messageId;
    document.getElementById('quoted-message-preview').textContent = `å›å¤ï¼š${previewText}`;
    document.getElementById('quote-reply-bar').style.display = 'flex';
    messageInput.focus();
}

function cancelQuoteReply() {
    currentQuotedMessageId = null;
    document.getElementById('quote-reply-bar').style.display = 'none';
}

    // â–¼â–¼â–¼ ç”¨ä¸‹é¢è¿™ä¸ªå®Œæ•´çš„å‡½æ•°ï¼Œæ›¿æ¢æ‰ä½ æ–‡ä»¶ä¸­æ—§çš„ setupChatRoom å‡½æ•° â–¼â–¼â–¼
// START: ä¿®å¤ç‰ˆ setupChatRoom (ä¿®å¤è½¬è´¦ç‚¹å‡»åˆ¤å®šé€»è¾‘)
function setupChatRoom() {
    sendMessageBtn.addEventListener('click', sendMessage);
    sendMessageBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        sendMessage();
        setTimeout(() => { messageInput.focus(); }, 50);
    });
    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !isGenerating) sendMessage();
    });
    getReplyBtn.addEventListener('click', getAiReply);

    // --- å¾®ä¿¡å¸ƒå±€çš„äº‹ä»¶ç›‘å¬ ---
    const wechatMessageInput = document.getElementById('wechat-message-input');
    const wechatSendMessageBtn = document.getElementById('wechat-send-message-btn');
    const wechatGetReplyBtn = document.getElementById('wechat-get-reply-btn');
    
    if (wechatSendMessageBtn) {
        wechatSendMessageBtn.addEventListener('click', () => sendMessage(wechatMessageInput));
    }
    if (wechatMessageInput) {
        wechatMessageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !isGenerating) sendMessage(wechatMessageInput);
        });
    }
    if (wechatGetReplyBtn) {
        wechatGetReplyBtn.addEventListener('click', getAiReply);
    }

    // --- ç»Ÿä¸€å¤„ç† messageArea ä¸Šçš„æ‰€æœ‰ç‚¹å‡»äº‹ä»¶ ---
    messageArea.addEventListener('click', (e) => {
        // 1. æˆªå›¾æ¨¡å¼ä¸‹çš„ç‚¹å‡»é€»è¾‘ (æœ€é«˜ä¼˜å…ˆçº§)
        if (isInScreenshotMode) {
            const messageWrapper = e.target.closest('.message-wrapper');
            if (messageWrapper) {
                toggleScreenshotSelection(messageWrapper.dataset.id);
            }
            return;
        }
        
        // 2. å…³é—­è¡¨æƒ…åŒ…é¢æ¿
        if (stickerModal.classList.contains('visible')) {
            stickerModal.classList.remove('visible');
            return;
        }

        // 3. åŠ è½½æ›´å¤šæ¶ˆæ¯
        if (e.target && e.target.id === 'load-more-btn') {
            loadMoreMessages();
            return;
        }

        // 4. å¤šé€‰åˆ é™¤æ¨¡å¼
        if (isInMultiSelectMode) {
            const messageWrapper = e.target.closest('.message-wrapper');
            if (messageWrapper) {
                toggleMessageSelection(messageWrapper.dataset.id);
            }
            return;
        }
        
        // ===== TTS è¯­éŸ³æ’­æ”¾äº‹ä»¶å§”æ‰˜ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰ =====
        const voiceBubble = e.target.closest('.voice-bubble');
        if (voiceBubble) {
            console.log('ğŸµ ç‚¹å‡»äº‹ä»¶è¢«æ•è·ï¼ç‚¹å‡»äº†ï¼š', e.target, 'æœ€è¿‘çš„.voice-bubble:', voiceBubble);

            // æ£€æŸ¥æ˜¯å¦æœ‰è¯­éŸ³IDï¼ˆTTSåŠŸèƒ½ï¼‰
            if (voiceBubble.dataset.voiceId) {
                console.log('ğŸ¤ æ£€æµ‹åˆ°TTSè¯­éŸ³ID:', voiceBubble.dataset.voiceId);

                const character = db.characters.find(c => c.id === currentChatId);
                if (character && character.enableTts !== false) {
                    console.log('â–¶ï¸ è§¦å‘TTSæ’­æ”¾...');
                    // æ’­æ”¾TTSè¯­éŸ³ï¼ˆä¸é˜»æ­¢å±•å¼€æ–‡å­—ï¼‰
                    playTtsAudio(voiceBubble);
                } else {
                    console.log('ğŸš« TTSåŠŸèƒ½æœªå¯ç”¨æˆ–è§’è‰²æœªæ‰¾åˆ°');
                }
            }

            // ç»Ÿä¸€æ‰§è¡Œå±•å¼€/æŠ˜å æ–‡å­—é€»è¾‘ï¼ˆæ— è®ºæ˜¯å¦æ’­æ”¾TTSï¼‰
            const transcript = voiceBubble.closest('.message-wrapper').querySelector('.voice-transcript');
            if (transcript) {
                transcript.classList.toggle('active');
                console.log('ğŸ“ å±•å¼€/æŠ˜å æ–‡å­—ï¼š', transcript.classList.contains('active') ? 'å±•å¼€' : 'æŠ˜å ');
            }
        }        

        // 5. å…¶ä»–æ™®é€šç‚¹å‡»äº‹ä»¶ï¼ˆè¯­éŸ³ã€å¡ç‰‡ç­‰ï¼‰
        
        const pvCard = e.target.closest('.pv-card');
        if (pvCard) {
            const imageOverlay = pvCard.querySelector('.pv-card-image-overlay');
            const footer = pvCard.querySelector('.pv-card-footer');
            imageOverlay.classList.toggle('hidden');
            footer.classList.toggle('hidden');
        }
        
        const giftCard = e.target.closest('.gift-card');
        if (giftCard) {
            const description = giftCard.closest('.message-wrapper').querySelector('.gift-card-description');
            if (description) description.classList.toggle('active');
        }
        
        const locationCard = e.target.closest('.location-card');
        if (locationCard) {
            displayLocationMain.textContent = locationCard.dataset.locationMain;
            displayLocationDetail.textContent = locationCard.dataset.locationDetail;
            displayLocationModal.classList.add('visible');
        }
        
        // --- æ ¸å¿ƒä¿®å¤ï¼šæ›´å®½å®¹çš„è½¬è´¦ç‚¹å‡»é€»è¾‘ ---
        const transferCard = e.target.closest('.transfer-card.received-transfer');
        if (transferCard && currentChatType === 'private') {
            const wrapper = transferCard.closest('.message-wrapper');
            const messageId = wrapper.dataset.id;
            const chat = db.characters.find(c => c.id === currentChatId);
            const message = chat ? chat.history.find(m => m.id === messageId) : null;
            
            if (message) {
                // ä¿®å¤é€»è¾‘ï¼šåªè¦çŠ¶æ€ä¸æ˜¯â€œå·²æ¥æ”¶â€æˆ–â€œå·²é€€å›â€ï¼Œå°±é»˜è®¤å…è®¸ç‚¹å‡»å¤„ç†ï¼ˆè§†ä¸º pendingï¼‰
                if (message.transferStatus !== 'received' && message.transferStatus !== 'returned') {
                    handleReceivedTransferClick(message.id);
                }
            }
        }
        // --- ä¿®å¤ç»“æŸ ---

        // å¿ƒåŠ¨ç»‘å®šæŒ‰é’®ç‚¹å‡»
        const bondAcceptBtn = e.target.closest('.bond-accept-btn');
        if (bondAcceptBtn) {
            const messageId = bondAcceptBtn.closest('.message-wrapper').dataset.id;
            handleBondRequestResponse(messageId, 'accepted');
        }
        const bondDeclineBtn = e.target.closest('.bond-decline-btn');
        if (bondDeclineBtn) {
            const messageId = bondDeclineBtn.closest('.message-wrapper').dataset.id;
            handleBondRequestResponse(messageId, 'declined');
        }

        // ä»£ä»˜æŒ‰é’®ç‚¹å‡»
        const acceptBtn = e.target.closest('.payment-request-accept');
        const declineBtn = e.target.closest('.payment-request-decline');
        const messageWrapper = e.target.closest('.message-wrapper');
        if (messageWrapper && (acceptBtn || declineBtn)) {
            const messageId = messageWrapper.dataset.id;
            const decision = acceptBtn ? 'paid' : 'declined';
            handleAiPaymentDecision(messageId, decision);
        }

        // æ’¤å›æ¶ˆæ¯ç‚¹å‡»
        const placeholder = e.target.closest('.recalled-message-placeholder');
        if (placeholder) {
            // è¿™é‡Œä¸ºäº†ç®€å•ï¼Œå‡è®¾ viewRecalledModal é€»è¾‘å·²ç»ç»‘å®šåœ¨ setupViewRecalledModal ä¸­
            // å¦‚æœ setupViewRecalledModal ä½¿ç”¨äº†ç‹¬ç«‹çš„ç›‘å¬å™¨ï¼Œè¿™é‡Œä¸åšå¤„ç†ä¹Ÿè¡Œ
            // ä½†ä¸ºäº†ä¿é™©ï¼Œæˆ‘ä»¬å¯ä»¥æ¨¡æ‹Ÿè§¦å‘ç‚¹å‡»ï¼ˆå¦‚æœé€»è¾‘å†™åœ¨è¿™é‡Œçš„è¯ï¼‰
        }
    });

    // --- é•¿æŒ‰/å³é”®èœå•äº‹ä»¶ ---
    messageArea.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (e.target.id === 'load-more-btn' || isInMultiSelectMode || isInScreenshotMode) return;
        const messageWrapper = e.target.closest('.message-wrapper');
        if (!messageWrapper) return;
        handleMessageLongPress(messageWrapper, e.clientX, e.clientY);
    });
    
    messageArea.addEventListener('touchstart', (e) => {
        if (e.target.id === 'load-more-btn' || isInMultiSelectMode || isInScreenshotMode) return;
        const messageWrapper = e.target.closest('.message-wrapper');
        if (!messageWrapper) return;
        longPressTimer = setTimeout(() => {
            const touch = e.touches[0];
            handleMessageLongPress(messageWrapper, touch.clientX, touch.clientY);
        }, 400);
    });
    messageArea.addEventListener('touchend', () => clearTimeout(longPressTimer));
    messageArea.addEventListener('touchmove', () => clearTimeout(longPressTimer));

    // --- å…¶ä»–æŒ‰é’®çš„äº‹ä»¶ç›‘å¬ ---
    cancelMultiSelectBtn.addEventListener('click', exitMultiSelectMode);
    deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);
    document.getElementById('cancel-quote-reply-btn').addEventListener('click', cancelQuoteReply);
    document.getElementById('cancel-screenshot-select').addEventListener('click', exitScreenshotSelectionMode);
    document.getElementById('confirm-screenshot-select').addEventListener('click', generateSelectedMessagesScreenshot);

    // --- ç¼–è¾‘æ¶ˆæ¯å¼¹çª—äº‹ä»¶ç›‘å¬ ---
    const messageEditForm = document.getElementById('message-edit-form');
    if (messageEditForm) {
        messageEditForm.addEventListener('submit', (e) => {
            e.preventDefault();
            saveMessageEdit();
        });
    }

    const cancelEditModalBtn = document.getElementById('cancel-edit-modal-btn');
    if (cancelEditModalBtn) {
        cancelEditModalBtn.addEventListener('click', cancelMessageEdit);
    }

    // --- å¾®ä¿¡å¸ƒå±€åŠŸèƒ½é¢æ¿äº‹ä»¶ ---
    const plusBtn = document.getElementById('plus-btn');
    const functionPanel = document.getElementById('function-panel');
    const chatRoomContent = document.querySelector('#chat-room-screen .content');

    if (plusBtn) {
        plusBtn.addEventListener('click', () => {
            functionPanel.classList.toggle('visible');
            if (functionPanel.classList.contains('visible')) {
                chatRoomContent.style.paddingBottom = (functionPanel.offsetHeight + 70) + 'px';
            } else {
                chatRoomContent.style.paddingBottom = '70px';
            }
        });
    }

    if (chatRoomContent) {
        chatRoomContent.addEventListener('click', () => {
            if (functionPanel && functionPanel.classList.contains('visible')) {
                functionPanel.classList.remove('visible');
                chatRoomContent.style.paddingBottom = '70px';
            }
        });
    }

    if (functionPanel) {
        functionPanel.addEventListener('click', (e) => {
            const item = e.target.closest('.function-item');
            if (!item) return;

            const action = item.dataset.action;
            functionPanel.classList.remove('visible');
            chatRoomContent.style.paddingBottom = '70px';

            switch (action) {
                case 'sticker': 
                    stickerModal.classList.add('visible'); 
                    renderStickerTabs(); // ğŸ†• æ¸²æŸ“æ ‡ç­¾æ 
                    renderStickerGrid(); 
                    break;
                case 'photo-video': sendPvForm.reset(); sendPvModal.classList.add('visible'); break;
                case 'image-recognition': imageUploadInput.click(); break;
                case 'voice-message': sendVoiceForm.reset(); voiceDurationPreview.textContent = '0"'; sendVoiceModal.classList.add('visible'); break;
                case 'voice-call': if (currentChatType === 'private') startUserInitiatedCall(); else showToast('ç¾¤èŠæš‚ä¸æ”¯æŒé€šè¯'); break;
                case 'wallet': walletBtn.click(); break;
                case 'gift': giftBtn.click(); break;
                case 'time-skip': timeSkipForm.reset(); timeSkipModal.classList.add('visible'); break;
                case 'file': sendFileForm.reset(); sendFileModal.classList.add('visible'); break;
                case 'location': sendLocationForm.reset(); sendLocationModal.classList.add('visible'); break;
                case 'rollback': if(document.getElementById('rollback-btn')) document.getElementById('rollback-btn').click(); break;
                case 'continue-writing': handleContinueWriting(); break;
                case 'diary':
                    if (currentChatId && currentChatType === 'private') {
                        document.getElementById('diary-actionsheet').classList.add('visible');
                    } else {
                        showToast('æ­¤åŠŸèƒ½ä»…åœ¨ç§èŠä¸­å¯ç”¨');
                    }
                    break;
            }
        });
    }
}

// === æ–°å¢ï¼šå¤„ç†ç”¨æˆ·å¯¹ç»‘å®šé‚€è¯·çš„å›åº” ===
async function handleBondRequestResponse(messageId, response) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    const message = character.history.find(m => m.id === messageId);
    if (!message || !message.bondRequestData || message.bondRequestData.status !== 'pending') return;

    // 1. æ›´æ–°å¡ç‰‡çŠ¶æ€
    message.bondRequestData.status = response;

    // 2. æ›´æ–°è§’è‰²çš„å¿ƒåŠ¨çŠ¶æ€
    if (response === 'accepted') {
        // ä½¿ç”¨ä¼´ä¾£åå†Œç®¡ç†æœºåˆ¶
        const roster = updateBondRoster(character.id, 'add');
        
        if (roster.length === 2) {
            // å¦‚æœåå†Œå·²æ»¡ï¼ˆ2ä¸ªè§’è‰²ï¼‰ï¼Œæ‰¾åˆ°å¦ä¸€ä¸ªè§’è‰²å¹¶ä¼‘çœ 
            const otherCharId = roster.find(id => id !== character.id);
            const otherCharacter = db.characters.find(c => c.id === otherCharId);
            if (otherCharacter) {
                otherCharacter.isSoulBound = false; // ä¼‘çœ ï¼Œä½†ä¿ç•™ soulBondStatus ä¸º 'active'
                // æ³¨æ„ï¼šæˆ‘ä»¬ä¸æ”¹å˜ otherCharacter.soulBondStatusï¼Œä¿æŒä¸º 'active'
            }
        } else {
            // å¦‚æœåå†Œæœªæ»¡ï¼Œå°†æ‰€æœ‰å…¶ä»–è§’è‰²è§£ç»‘ï¼ˆæ¸…é™¤ç»‘å®šçŠ¶æ€ï¼‰
            db.characters.forEach(c => {
                if (c.id !== character.id) {
                    c.isSoulBound = false;
                    c.soulBondStatus = 'none';
                }
            });
        }
        
        // ç»‘å®šå½“å‰AI
        character.isSoulBound = true;
        character.soulBondStatus = 'active';
        showToast(`ä½ ä¸ ${character.remarkName} å·²æˆåŠŸç»‘å®šï¼`);
    } else {
        character.soulBondStatus = 'none';
        showToast('ä½ æ‹’ç»äº†é‚€è¯·');
    }
    
    // 3. æ³¨å…¥ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯ï¼Œå‘ŠçŸ¥AIä½ çš„å†³å®š
    const systemContent = `[system: æˆ‘${response === 'accepted' ? 'åŒæ„' : 'æ‹’ç»'}äº†ä½ çš„å¿ƒåŠ¨ç»‘å®šè¯·æ±‚ã€‚]`;
    const contextMessage = {
        id: `msg_bond_resp_ctx_${Date.now()}`,
        role: 'user',
        content: systemContent,
        parts: [{ type: 'text', text: systemContent }],
        timestamp: Date.now()
    };
    character.history.push(contextMessage);

    await saveData();

    // 4. åˆ·æ–°UIå¹¶è§¦å‘AIçš„åç»­ååº”
    renderMessages(false, true);
    renderChatList(); // åˆ·æ–°èŠå¤©åˆ—è¡¨ä»¥æ˜¾ç¤ºï¼ˆæˆ–ç§»é™¤ï¼‰çˆ±å¿ƒ
    getAiReply();
}

        function handleMessageLongPress(messageWrapper, x, y) {
            if (isInMultiSelectMode) return;
            clearTimeout(longPressTimer);
            const messageId = messageWrapper.dataset.id;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            const isImageRecognitionMsg = message.parts && message.parts.some(p => p.type === 'image');
            const isVoiceMessage = /\[.*?çš„è¯­éŸ³ï¼š.*?\]/.test(message.content);
            const isStickerMessage = /\[.*?çš„è¡¨æƒ…åŒ…ï¼š.*?\]|\[.*?å‘é€çš„è¡¨æƒ…åŒ…ï¼š.*?\]/.test(message.content);
            const isPhotoVideoMessage = /\[.*?å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘ï¼š.*?\]/.test(message.content);
            const isTransferMessage = /\[.*?ç»™ä½ è½¬è´¦ï¼š.*?\]|\[.*?çš„è½¬è´¦ï¼š.*?\]|\[.*?å‘.*?è½¬è´¦ï¼š.*?\]/.test(message.content);
            const isGiftMessage = /\[.*?é€æ¥çš„ç¤¼ç‰©ï¼š.*?\]|\[.*?å‘.*?é€æ¥äº†ç¤¼ç‰©ï¼š.*?\]/.test(message.content);
            const isInvisibleMessage = /\[.*?(?:æ¥æ”¶|é€€å›).*?çš„è½¬è´¦\]|\[.*?æ›´æ–°çŠ¶æ€ä¸ºï¼š.*?\]|\[.*?å·²æ¥æ”¶ç¤¼ç‰©\]|\[system:.*?\]|\[.*?é‚€è¯·.*?åŠ å…¥äº†ç¾¤èŠ\]|\[.*?ä¿®æ”¹ç¾¤åä¸ºï¼š.*?\]|\[system-display:.*?\]/.test(message.content);

            let menuItems = [];
            menuItems.push({label: 'å¼•ç”¨', action: () => startQuoteReply(messageId)});
     const isSent = messageWrapper.classList.contains('sent');
    const twoMinutes = 2 * 60 * 1000;
    if (isSent && (Date.now() - message.timestamp < twoMinutes) && !message.recalled) {
        menuItems.push({
            label: 'æ’¤å›',
            action: async () => {
                const msgIndex = chat.history.findIndex(m => m.id === messageId);
                if (msgIndex > -1) {
                    // æ ¸å¿ƒä¿®æ”¹ï¼šä¸å†ä¿®æ”¹contentï¼Œè€Œæ˜¯æ·»åŠ æ ‡è®°
                    chat.history[msgIndex].recalled = true;
                    chat.history[msgIndex].recalledBy = 'user';
                    // åŒæ—¶ä¿å­˜ä¸€ä»½åŸå§‹å†…å®¹ï¼Œä»¥ä¾¿æŸ¥çœ‹
                    chat.history[msgIndex].originalContent = chat.history[msgIndex].content;
                    
                    await saveData();
                    renderMessages(false, true); // é‡æ–°æ¸²æŸ“ï¼Œè®©æ¶ˆæ¯å˜æˆå ä½ç¬¦
                }
            }
        });
    }

menuItems.push({
        label: 'é•¿æˆªå›¾ (é€‰æ‹©)',
        action: () => enterScreenshotSelectionMode(messageId)
    });
    if (!isImageRecognitionMsg && !isVoiceMessage && !isStickerMessage && !isPhotoVideoMessage && !isTransferMessage && !isGiftMessage && !isInvisibleMessage) {
        menuItems.push({label: 'ç¼–è¾‘', action: () => startMessageEdit(messageId)});
    }
    menuItems.push({label: 'åˆ é™¤', action: () => enterMultiSelectMode(messageId)});

            if (menuItems.length > 0) {
                createContextMenu(menuItems, x, y);
            }
        }

        function startMessageEdit(messageId) {
            exitMultiSelectMode();
            editingMessageId = messageId;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            const modal = document.getElementById('message-edit-modal');
            const textarea = document.getElementById('message-edit-textarea');

            let contentToEdit = message.content;
            const plainTextMatch = contentToEdit.match(/^\[.*?ï¼š([\s\S]*)\]$/);
            if (plainTextMatch && plainTextMatch[1]) {
                contentToEdit = plainTextMatch[1].trim();
            }
            contentToEdit = contentToEdit.replace(/\[å‘é€æ—¶é—´:.*?\]/g, '').trim();
            
            textarea.value = contentToEdit;
            modal.classList.add('visible');
            textarea.focus();
        }

        async function saveMessageEdit() {
            const newText = document.getElementById('message-edit-textarea').value.trim();
            if (!newText || !editingMessageId) {
                cancelMessageEdit();
                return;
            }

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
            if (messageIndex === -1) {
                cancelMessageEdit();
                return;
            }

            const oldContent = chat.history[messageIndex].content;
            const prefixMatch = oldContent.match(/(\[.*?çš„æ¶ˆæ¯ï¼š)[\s\S]+\]/);
            let newContent;

            if (prefixMatch && prefixMatch[1]) {
                const prefix = prefixMatch[1];
                newContent = `${prefix}${newText}]`;
            } else {
                newContent = newText;
            }

            chat.history[messageIndex].content = newContent;
            if (chat.history[messageIndex].parts) {
                chat.history[messageIndex].parts = [{type: 'text', text: newContent}];
            }

            await saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            
            cancelMessageEdit();
        }

        function cancelMessageEdit() {
            editingMessageId = null;
            const modal = document.getElementById('message-edit-modal');
            if (modal) {
                modal.classList.remove('visible');
            }
        }

        function enterMultiSelectMode(initialMessageId) {
            isInMultiSelectMode = true;
            chatRoomHeaderDefault.style.display = 'none';
            chatRoomHeaderSelect.style.display = 'flex';
            document.querySelector('.chat-input-wrapper').style.display = 'none';
            multiSelectBar.classList.add('visible');
            chatRoomScreen.classList.add('multi-select-active');
            selectedMessageIds.clear();
            if (initialMessageId) {
                toggleMessageSelection(initialMessageId);
            }
        }

        function exitMultiSelectMode() {
            isInMultiSelectMode = false;
            chatRoomHeaderDefault.style.display = 'flex';
            chatRoomHeaderSelect.style.display = 'none';
            document.querySelector('.chat-input-wrapper').style.display = 'block';
            multiSelectBar.classList.remove('visible');
            chatRoomScreen.classList.remove('multi-select-active');
            selectedMessageIds.forEach(id => {
                const el = messageArea.querySelector(`.message-wrapper[data-id="${id}"]`);
                if (el) el.classList.remove('multi-select-selected');
            });
            selectedMessageIds.clear();
        }

        function toggleMessageSelection(messageId) {
            const el = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (!el) return;
            if (selectedMessageIds.has(messageId)) {
                selectedMessageIds.delete(messageId);
                el.classList.remove('multi-select-selected');
            } else {
                selectedMessageIds.add(messageId);
                el.classList.add('multi-select-selected');
            }
            selectCount.textContent = `å·²é€‰æ‹© ${selectedMessageIds.size} é¡¹`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;
        }

        async function deleteSelectedMessages() {
            if (selectedMessageIds.size === 0) return;
            const deletedCount = selectedMessageIds.size;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            chat.history = chat.history.filter(m => !selectedMessageIds.has(m.id));
            await saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            exitMultiSelectMode();
            showToast(`å·²åˆ é™¤ ${deletedCount} æ¡æ¶ˆæ¯`);
        }

// --- æ–°ä»£ç å¼€å§‹ ---
     // --- æ–°ä»£ç å¼€å§‹ ---
    // --- æ–°ä»£ç å¼€å§‹ ---
// --- æ–°ä»£ç å¼€å§‹ ---
        function openChatRoom(chatId, type) { // ä¿®æ”¹ï¼šå‡½æ•°ä¸å†éœ€è¦ async
            const chat = (type === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chat) return;

            // ä¿®æ”¹ï¼šå¤„ç†æš‚å­˜æ¶ˆæ¯çš„é€»è¾‘å·²è¢«ç§»é™¤

            // åç»­é€»è¾‘ä¿æŒä¸å˜ï¼Œä½†é‡æ–°æ¢³ç†äº†æ¸²æŸ“é¡ºåº
            exitScreenshotSelectionMode(); 
            checkAndUpdateUiForAiBlock();
            exitMultiSelectMode();
            cancelMessageEdit();

            if (window.targetMessageId) {
                const targetId = window.targetMessageId;
                const messageIndex = chat.history.findIndex(m => m.id === targetId);
                if (messageIndex > -1) {
                    const page = Math.floor((chat.history.length - 1 - messageIndex) / MESSAGES_PER_PAGE) + 1;
                    currentPage = page;
                    window.targetMessageIdForHighlight = targetId;
                } else {
                    currentPage = 1; 
                    showToast('æ— æ³•åœ¨å†å²è®°å½•ä¸­å®šä½åˆ°è¯¥æ¶ˆæ¯');
                }
                window.targetMessageId = null; 
            } else {
                currentPage = 1;
            }

            const diaryBtn = document.getElementById('diary-btn');
            const trajectoryBtn = document.getElementById('ai-trajectory-btn');

            if (type === 'private') {
                voiceCallBtn.style.display = 'flex';
                diaryBtn.style.display = 'flex';
                trajectoryBtn.style.display = 'flex';
            } else { 
                voiceCallBtn.style.display = 'none';
                diaryBtn.style.display = 'none';
                trajectoryBtn.style.display = 'none';
            }

            chatRoomTitle.textContent = (type === 'private') ? chat.remarkName : chat.name;
            const subtitle = document.getElementById('chat-room-subtitle');
            if (type === 'private') {
                subtitle.style.display = 'flex';
                chatRoomStatusText.textContent = chat.status || 'åœ¨çº¿';
            } else {
                subtitle.style.display = 'none';
            }
            getReplyBtn.style.display = 'inline-flex';
            chatRoomScreen.style.backgroundImage = chat.chatBg ? `url(${chat.chatBg})` : 'none';
            chatRoomScreen.style.setProperty('--bubble-scale', type === 'group' ? (chat.bubbleScale || 1) : 1);
            typingIndicator.style.display = 'none';
            isGenerating = false;
            getReplyBtn.disabled = false;
            chatRoomScreen.className = chatRoomScreen.className.replace(/\bchat-active-[^ ]+\b/g, '');
            chatRoomScreen.classList.add(`chat-active-${chatId}`);
            updateCustomBubbleStyle(chatId, chat.customBubbleCss, chat.useCustomBubbleCss);
            
            messageArea.innerHTML = '';
            switchScreen('chat-room-screen');
            
            setTimeout(() => {
                renderMessages(false, !window.targetMessageIdForHighlight);
            }, 50);
        }
// --- æ–°ä»£ç ç»“æŸ ---
// --- æ–°ä»£ç ç»“æŸ ---
// --- æ–°ä»£ç ç»“æŸ ---

function renderMessages(isLoadMore = false, forceScrollToBottom = false) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) return;

            // â–¼â–¼â–¼ åœ¨å‡½æ•°å¼€å¤´ï¼Œè¯»å–å¹¶æ¶ˆè´¹é«˜äº®æ ‡è®° â–¼â–¼â–¼
            const targetIdToHighlight = window.targetMessageIdForHighlight;
            window.targetMessageIdForHighlight = null; // æ¶ˆè´¹æ‰è¿™ä¸ªIDï¼Œé˜²æ­¢ä¸‹æ¬¡æ¸²æŸ“æ—¶é‡å¤æ‰§è¡Œ

            const oldScrollHeight = messageArea.scrollHeight;
            const totalMessages = chat.history.length;
            const end = totalMessages - (currentPage - 1) * MESSAGES_PER_PAGE;
            const start = Math.max(0, end - MESSAGES_PER_PAGE);
            const messagesToRender = chat.history.slice(start, end);

            if (!isLoadMore) messageArea.innerHTML = '';
            
            const fragment = document.createDocumentFragment();
            messagesToRender.forEach(msg => {
                const bubble = createMessageBubbleElement(msg);
                if (bubble) fragment.appendChild(bubble);
            });
            
            const existingLoadBtn = document.getElementById('load-more-btn');
            if (existingLoadBtn) existingLoadBtn.remove();
            
            messageArea.prepend(fragment);
            
            if (totalMessages > currentPage * MESSAGES_PER_PAGE) {
                const loadMoreButton = document.createElement('button');
                loadMoreButton.id = 'load-more-btn';
                loadMoreButton.className = 'load-more-btn';
                loadMoreButton.textContent = 'åŠ è½½æ›´æ—©çš„æ¶ˆæ¯';
                messageArea.prepend(loadMoreButton);
            }

            // â–¼â–¼â–¼ æ–°å¢/ä¿®æ”¹çš„é«˜äº®ä¸æ»šåŠ¨é€»è¾‘ â–¼â–¼â–¼
            if (targetIdToHighlight) {
                // å¦‚æœæ˜¯ä»æœç´¢è·³è½¬è€Œæ¥
                setTimeout(() => { // ä½¿ç”¨setTimeoutç¡®ä¿DOMæ›´æ–°å®Œæ¯•
                    const targetElement = messageArea.querySelector(`.message-wrapper[data-id="${targetIdToHighlight}"]`);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        targetElement.classList.add('message-highlight');
                        // 2ç§’åç§»é™¤é«˜äº®æ•ˆæœ
                        setTimeout(() => {
                            targetElement.classList.remove('message-highlight');
                        }, 2000); 
                    }
                }, 100); // å»¶è¿Ÿ100æ¯«ç§’ç­‰å¾…æ¸²æŸ“
            } else if (forceScrollToBottom) {
                // æ­£å¸¸æ‰“å¼€èŠå¤©æ—¶ï¼Œæ»šåŠ¨åˆ°åº•éƒ¨
                setTimeout(() => {
                    messageArea.scrollTop = messageArea.scrollHeight;
                }, 0);
            } else if (isLoadMore) {
                // åŠ è½½æ›´å¤šæ—¶ï¼Œä¿æŒå½“å‰è§†å£ä½ç½®
                messageArea.scrollTop = messageArea.scrollHeight - oldScrollHeight;
            }
            // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²
        }
        function loadMoreMessages() {
            currentPage++;
            renderMessages(true, false);
        }

        function calculateVoiceDuration(text) {
            return Math.max(1, Math.min(60, Math.ceil(text.length / 3.5)));
        }

                                 
// START: å®Œæ•´ç‰ˆ createMessageBubbleElement å‡½æ•° (æ›¿æ¢æ—§ç‰ˆæœ¬)
// START: æœ€ç»ˆç‰ˆ createMessageBubbleElement å‡½æ•° (æ›¿æ¢æ—§ç‰ˆæœ¬)
// â–¼â–¼â–¼ ã€V3.1 | æœ€ç»ˆä¿®å¤ç‰ˆã€‘è¯·ç”¨è¿™ä¸ªå‡½æ•°å®Œæ•´æ›¿æ¢æ—§çš„ createMessageBubbleElement â–¼â–¼â–¼

/**
 * ã€é‡æ„ç‰ˆã€‘æ ¹æ®æ¶ˆæ¯å¯¹è±¡åˆ›å»ºå¹¶è¿”å›ä¸€ä¸ªå®Œæ•´çš„æ¶ˆæ¯æ°”æ³¡DOMå…ƒç´ ã€‚
 * @param {object} message - æ¶ˆæ¯å¯¹è±¡
 * @returns {HTMLElement|null} - åˆ›å»ºå¥½çš„æ¶ˆæ¯åŒ…è£…å™¨å…ƒç´ ï¼Œæˆ–åœ¨ä¸éœ€æ¸²æŸ“æ—¶è¿”å›null
 */
// START: å®Œç¾ä¿®å¤ç‰ˆ createMessageBubbleElement (è¡¨æƒ…åŒ…æ¢å¤åŸæ ·ï¼ŒæŠ¥å‘Šå›¾ç‰‡å—é™)
// â–¼â–¼â–¼ æ–°å¢ï¼šIDéš”ç¦»å·¥å…· (è§£å†³å¤šä¸ªå°å‰§åœºå†²çªé—®é¢˜) â–¼â–¼â–¼
// â–¼â–¼â–¼ å¢å¼ºç‰ˆï¼šIDä¸Radioéš”ç¦»å·¥å…· (è§£å†³å‰§åœºäº’æ–¥ã€ç©ºç™½é—®é¢˜) â–¼â–¼â–¼
function isolateHtmlIds(html, suffix) {
    if (!html || !suffix) return html;
    
    let result = html;

    // --- 1. éš”ç¦» ID (è§£å†³æ ·å¼å’ŒJSå®šä½å†²çª) ---
    const idMatches = [...html.matchAll(/id=["']([a-zA-Z][\w-]*)["']/g)];
    const ids = new Set(idMatches.map(m => m[1]));
    
    ids.forEach(oldId => {
        const newId = `${oldId}_${suffix}`;
        
        // 1.1 æ›¿æ¢ HTML å±æ€§ (id, for, aria-controls, list)
        // æ³¨æ„ï¼šæ›¿æ¢ label çš„ for å±æ€§éå¸¸é‡è¦ï¼Œå¦åˆ™ç‚¹å‡»æ–‡å­—æ²¡ååº”
        result = result.replace(new RegExp(`(id|for|aria-controls|list)=["']${oldId}["']`, 'g'), `$1="${newId}"`);
        
        // 1.2 æ›¿æ¢ CSS æ ·å¼ä¸­çš„ ID é€‰æ‹©å™¨ (#page1 { ... })
        result = result.replace(new RegExp(`#${oldId}(?![\\w-])`, 'g'), `#${newId}`);
        
        // 1.3 æ›¿æ¢ JS ä»£ç ä¸­çš„ ID å¼•ç”¨ ('page1', "page1")
        result = result.replace(new RegExp(`(['"])${oldId}\\1`, 'g'), `$1${newId}$1`);
        
        // 1.4 æ›¿æ¢ href é”šç‚¹é“¾æ¥ (#page1)
        result = result.replace(new RegExp(`href=["']#${oldId}["']`, 'g'), `href="#${newId}"`);
    });

    // --- 2. éš”ç¦» Name (æ ¸å¿ƒä¿®å¤ï¼šè§£å†³â€œç‚¹ä¸€ä¸ªç­ä¸€ä¸ªâ€çš„é—®é¢˜) ---
    // ä¸“é—¨é’ˆå¯¹ <input type="radio" name="...">
    const nameMatches = [...html.matchAll(/name=["']([^"']+)["']/g)];
    const names = new Set(nameMatches.map(m => m[1]));

    names.forEach(oldName => {
        const newName = `${oldName}_${suffix}`;
        // å…¨å±€æ›¿æ¢è¯¥ nameï¼Œç¡®ä¿è¿™ç»„æŒ‰é’®åªåœ¨å½“å‰å‰§åœºå†…äº’æ–¥
        result = result.replace(new RegExp(`name=["']${oldName}["']`, 'g'), `name="${newName}"`);
    });
    
    return result;
}
// â–²â–²â–² å·¥å…·ç»“æŸ â–²â–²â–²
// â–²â–²â–² å·¥å…·ç»“æŸ â–²â–²â–²
// START: é˜²å†²çªå¢å¼ºç‰ˆ createMessageBubbleElement (è‡ªåŠ¨éš”ç¦»å°å‰§åœºID)
// START: ä¿®å¤ç‰ˆ createMessageBubbleElement (å®Œç¾ä¿®å¤è¯­éŸ³å´©æºƒå’Œè½¬è´¦æ˜¾ç¤º)
// START: ä¿®å¤ç‰ˆ createMessageBubbleElement (ä¿®å¤è½¬è´¦æ— æ³•ç‚¹å‡» + è¯­éŸ³é˜²ç™½å±)
function createMessageBubbleElement(message) {
    // --- 1. å¤„ç†ç³»ç»Ÿæ¶ˆæ¯ã€æ’¤å›æ¶ˆæ¯ç­‰ç‰¹æ®Šç±»å‹ ---
    const updateStatusRegexForRender = /\[.*?æ›´æ–°çŠ¶æ€ä¸º[:ï¼š].*?\]/;
    if (message.content.startsWith('[system:') || message.content.startsWith('[system-context-only:') || updateStatusRegexForRender.test(message.content)) {
        return null;
    }

    if (message.recalled) {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-notification';
        wrapper.dataset.id = message.id;
        const recaller = (message.recalledBy === 'user') ? 'ä½ ' : 'å¯¹æ–¹';
        const placeholder = document.createElement('div');
        placeholder.className = 'recalled-message-placeholder';
        placeholder.textContent = `${recaller}æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
        placeholder.style.cursor = 'pointer';
        placeholder.dataset.recalledMessageId = message.id;
        wrapper.appendChild(placeholder);
        return wrapper;
    }

    const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
    const inviteRegex = /\[(.*?)é‚€è¯·(.*?)åŠ å…¥äº†ç¾¤èŠ\]/;
    const renameRegex = /\[(.*?)ä¿®æ”¹ç¾¤åä¸ºï¼š(.*?)\]/;
    const timeSkipMatch = message.content.match(timeSkipRegex);
    const inviteMatch = message.content.match(inviteRegex);
    const renameMatch = message.content.match(renameRegex);
    
    if (timeSkipMatch || inviteMatch || renameMatch) {
        const wrapper = document.createElement('div');
        wrapper.dataset.id = message.id;
        wrapper.className = 'message-wrapper system-notification';
        let bubbleText = '';
        if (timeSkipMatch) bubbleText = timeSkipMatch[1];
        if (inviteMatch) bubbleText = `${inviteMatch[1]}é‚€è¯·${inviteMatch[2]}åŠ å…¥äº†ç¾¤èŠ`;
        if (renameMatch) bubbleText = `${renameMatch[1]}ä¿®æ”¹ç¾¤åä¸ºâ€œ${renameMatch[2]}â€`;
        wrapper.innerHTML = `<div class="system-notification-bubble">${bubbleText}</div>`;
        return wrapper;
    }

    // --- 2. å‡†å¤‡æ¸²æŸ“æ‰€éœ€çš„åŸºç¡€æ•°æ® ---
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return null;

    const { role, content, timestamp, id, senderId, transferStatus, giftStatus, stickerData } = message;
    const isSent = (currentChatType === 'group') ? (senderId === 'user_me') : (role === 'user');
    let avatarUrl, bubbleTheme, senderNickname = '', titleBadgeHTML = '';
    
    const themeKey = chat.theme || 'white_pink';
    const theme = colorThemes[themeKey] || colorThemes['white_pink'];
    bubbleTheme = isSent ? theme.sent : theme.received;

    if (currentChatType === 'group') {
        const sender = isSent ? chat.me : chat.members.find(m => m.id === senderId);
        if (sender) {
            avatarUrl = sender.avatar;
            senderNickname = sender.nickname || sender.groupNickname;
            if (sender.groupTitle) {
                const badgeClass = getBadgeClassForTitle(sender.groupTitle);
                titleBadgeHTML = `<span class="group-title-badge ${badgeClass}">${sender.groupTitle}</span>`;
            }
        } else {
            avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            senderNickname = 'æœªçŸ¥æˆå‘˜';
        }
    } else {
        avatarUrl = isSent ? chat.myAvatar : chat.avatar;
    }

    // --- 3. æ¸²æŸ“æ ¸å¿ƒé€»è¾‘ ---
    let finalContentHTML;
    let isRenderedByRule = false;

    let rawText = content;
    // ğŸ†• æ”¾å®½æ­£åˆ™åŒ¹é…ï¼šæ”¯æŒä¸­è‹±æ–‡å†’å·ï¼Œå…è®¸ç©ºæ ¼
    const textMatchForRender = content.match(/\[(?:.+?)çš„æ¶ˆæ¯[:ï¼š]\s*([\s\S]+?)\]/);
    if (textMatchForRender && textMatchForRender[1]) {
        rawText = textMatchForRender[1].trim();
    } else {
        // ğŸ†• ä¿åº•æœºåˆ¶ï¼šå¦‚æœæ­£åˆ™åŒ¹é…å¤±è´¥ï¼Œå°è¯•æå–åŸå§‹å†…å®¹
        if (rawText.startsWith('[') && rawText.endsWith(']')) {
            const looseMatch = rawText.match(/\[.*?[:ï¼š]\s*(.*?)\]/s);
            if (looseMatch && looseMatch[1]) {
                rawText = looseMatch[1].trim();
            } else {
                // å®Œå…¨æ— æ³•åŒ¹é…ï¼Œå»æ‰é¦–å°¾æ–¹æ‹¬å·åä½¿ç”¨
                rawText = rawText.slice(1, -1).trim();
            }
        }
    }
    
    const renderResult = applyAdvancedRenderingRules(rawText, currentChatId, isSent ? 'user' : 'ai');

    // é€šç”¨æ ·å¼
    const universalStyle = `<style>.ai-generated-theater img, .ai-theater img { max-width: 100% !important; height: auto !important; border-radius: 8px; display: block; margin: 5px 0; } .ai-generated-theater, .ai-theater { width: 100%; overflow-x: hidden; word-wrap: break-word; pointer-events: auto !important; }</style>`;

    if (renderResult.isRendered) {
        const suffix = (id || Date.now()).toString().slice(-6);
        finalContentHTML = universalStyle + isolateHtmlIds(renderResult.html, suffix);
        isRenderedByRule = true;
    } 
    else if (content.includes('<div class="ai-theater"') || content.includes('class="ai-generated-theater"')) {
        const suffix = (id || Date.now()).toString().slice(-6);
        finalContentHTML = universalStyle + isolateHtmlIds(content, suffix); 
        isRenderedByRule = true;    
    }
    else {
        // æ­£åˆ™åŒ¹é…å‡†å¤‡
        const aiQuoteRegex = /\[(?:.*?)å¼•ç”¨äº†â€œ(?:.*?:)?\s?([\s\S]+?)â€çš„æ¶ˆæ¯?å¹¶å›å¤ï¼š([\s\S]+?)\]/;
        const musicShareRegex = /\[(?:.*?)åˆ†äº«äº†éŸ³ä¹ï¼š([\s\S]+?) - ([\s\S]+?)\]/;
        const locationRegex = /\[(.*?)çš„ä½ç½®å…±äº«ï¼šä¸»ä½ç½® '(.*?)', è¯¦ç»†ä½ç½® '(.*?)'\]|\[(.*?)åˆ†äº«äº†ä½ç½®ï¼šä¸»ä½ç½® '(.*?)', è¯¦ç»†ä½ç½® '(.*?)'\]/i;
        const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
        const sentStickerRegex = /\[(?:.+?)çš„è¡¨æƒ…åŒ…ï¼š.+?\]/i;
        const receivedStickerRegex = /\[(?:.+?)å‘é€çš„è¡¨æƒ…åŒ…ï¼š([\s\S]+?)\]/i;
        const bareImageLinkRegex = /^\[(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg))\]$/i;
        const voiceRegex = /\[(?:.+?)çš„è¯­éŸ³ï¼š([\s\S]+?)\]/;
        const photoVideoRegex = /\[(?:.+?)å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘ï¼š([\s\S]+?)\]/;
        const privateSentTransferRegex = /\[.*?ç»™ä½ è½¬è´¦ï¼š([\d.]+)å…ƒï¼›å¤‡æ³¨ï¼š(.*?)\]/;
        const privateReceivedTransferRegex = /\[.*?çš„è½¬è´¦ï¼š([\d.]+)å…ƒï¼›å¤‡æ³¨ï¼š(.*?)\]/;
        const groupTransferRegex = /\[(.*?)\s*å‘\s*(.*?)\s*è½¬è´¦ï¼š([\d.]+)å…ƒï¼›å¤‡æ³¨ï¼š(.*?)\]/;
        const privateGiftRegex = /\[(?:.+?)é€æ¥çš„ç¤¼ç‰©ï¼š([\s\S]+?)\]/;
        const groupGiftRegex = /\[(.*?)\s*å‘\s*(.*?)\s*é€æ¥äº†ç¤¼ç‰©ï¼š([\s\S]+?)\]/; 
        const imageRecogRegex = /\[.*?å‘æ¥äº†ä¸€å¼ å›¾ç‰‡ï¼š\]/;
        // ğŸ†• æ”¾å®½æ­£åˆ™åŒ¹é…ï¼šæ”¯æŒä¸­è‹±æ–‡å†’å·ï¼Œå…è®¸ç©ºæ ¼
        const textRegex = /\[(?:.+?)çš„æ¶ˆæ¯[:ï¼š]\s*([\s\S]+?)\]/;
        const fileRegex = /\[(?:.+?)å‘é€äº†æ–‡ä»¶ï¼š(\{[\s\S]*?\})\]/;

        const aiQuoteMatch = content.match(aiQuoteRegex);
        const musicMatch = content.match(musicShareRegex);
        const locationMatch = content.match(locationRegex);
        const sentStickerMatch = content.match(sentStickerRegex);
        const receivedStickerMatch = content.match(receivedStickerRegex);
        const bareImageLinkMatch = content.match(bareImageLinkRegex);
        const voiceMatch = content.match(voiceRegex);
        const photoVideoMatch = content.match(photoVideoRegex);
        const privateSentTransferMatch = content.match(privateSentTransferRegex);
        const privateReceivedTransferMatch = content.match(privateReceivedTransferRegex);
        const groupTransferMatch = content.match(groupTransferRegex);
        const privateGiftMatch = content.match(privateGiftRegex);
        const groupGiftMatch = content.match(groupGiftRegex);
        const imageRecogMatch = content.match(imageRecogRegex);
        const textMatch = content.match(textRegex);
        const fileMatch = content.match(fileRegex);

        if (message.bondRequestData) {
            // å¿ƒåŠ¨ç»‘å®šå¡ç‰‡
            const data = message.bondRequestData;
            let statusText = 'ç­‰å¾…å›åº”...';
            let statusColor = '#888';
            let actionsHTML = '';
            if (data.status === 'accepted') { statusText = 'âœ“ å·²åŒæ„'; statusColor = '#4CAF50'; } 
            else if (data.status === 'declined') { statusText = 'âœ— å·²æ‹’ç»'; statusColor = '#F44336'; } 
            else { 
                if (!isSent) { 
                    actionsHTML = `<div class="bond-request-actions"><button class="btn btn-neutral btn-small bond-decline-btn">å†æƒ³æƒ³</button><button class="btn btn-primary btn-small bond-accept-btn">æˆ‘æ„¿æ„</button></div>`;
                    statusText = ''; 
                }
            }
            finalContentHTML = `<div class="bond-request-card"><p>${isSent ? 'ä½ å‘å¯¹æ–¹å‘èµ·äº†å¿ƒåŠ¨ç»‘å®šé‚€è¯·' : `${senderNickname} å‘ä½ å‘èµ·äº†å¿ƒåŠ¨ç»‘å®šé‚€è¯·`}</p>${actionsHTML}<p class="bond-request-status" style="color: ${statusColor};">${statusText || '&nbsp;'}</p></div>`;
        
        } else if (message.quote || aiQuoteMatch) {
            let quotedSender, quotedText, replyText;
            if (message.quote) {
                quotedSender = message.quote.sender;
                quotedText = message.quote.content;
                replyText = message.replyText;
            } else {
                quotedSender = senderNickname || (currentChatType === 'private' ? chat.remarkName : 'ç¾¤æˆå‘˜');
                quotedText = aiQuoteMatch[1].trim();
                replyText = aiQuoteMatch[2].trim();
            }
            finalContentHTML = `<div class="quoted-content"><div class="quoted-sender">${quotedSender}</div><div class="quoted-text">${quotedText}</div></div><div class="reply-text">${replyText}</div>`;
        
        } else if (musicMatch) {
            finalContentHTML = `<div class="music-card"><img src="https://i.postimg.cc/d10J4VzR/image.png" alt="music icon" class="music-card-icon"><div class="music-card-info"><p class="music-card-title">${musicMatch[1].trim()}</p><p class="music-card-artist">${musicMatch[2].trim()}</p></div></div>`;
        
        } else if (message.deliveryData) {
            finalContentHTML = `<div class="product-delivery-card"><img src="${message.deliveryData.productImage}" alt="å•†å“" class="product-delivery-card-icon"><div class="product-delivery-card-info"><p class="product-delivery-card-title">${message.deliveryData.productName}</p><p class="delivery-countdown-display" data-countdown-type="delivery" data-eta="${message.deliveryData.eta}"></p></div></div>`;
        
        } else if (message.paymentRequestData) {
            // ä»£ä»˜å¡ç‰‡
            const data = message.paymentRequestData;
            let actionsHTML = '';
            let statusText = '';
            if (data.status === 'pending' && isSent) { statusText = `<p class="payment-request-status">ç­‰å¾…å¯¹æ–¹ä»˜æ¬¾...</p>`; } 
            else if (data.status === 'pending' && !isSent) {
                actionsHTML = `<div class="payment-request-actions"><button class="btn btn-neutral btn-small payment-request-decline">æ®‹å¿æ‹’ç»</button><button class="btn btn-primary btn-small payment-request-accept">ä¸ºTaä»˜æ¬¾</button></div>`;
            } else if (data.status === 'paid') { statusText = `<p class="payment-request-status" style="color: #4CAF50;">âœ“ å·²æ”¯ä»˜</p>`; } 
            else if (data.status === 'declined') { statusText = `<p class="payment-request-status" style="color: #F44336;">âœ— å·²æ‹’ç»</p>`; }
            finalContentHTML = `<div class="payment-request-card"><p class="payment-request-title">${data.requesterName} å‘èµ·çš„ä»£ä»˜</p><p class="payment-request-amount">Â¥${data.amount.toFixed(2)}</p><p class="payment-request-desc">${data.items.map(i => i.name).join(', ')}</p>${actionsHTML}${statusText}</div>`;
        
        } else if (message.fileData && message.fileData.name) {
            const fileSize = formatFileSize(new Blob([message.fileData.content]).size);
            finalContentHTML = `<div class="file-card" data-file-name="${escapeHTML(message.fileData.name)}" data-file-content="${escapeHTML(message.fileData.content)}"><img src="https://i.postimg.cc/vms1Vd9X/1040g2sg31hh9ub1v3oeg5pbsckvn39vt3mbflao.png" alt="file icon" class="file-card-icon"><div class="file-card-info"><p class="file-card-name">${escapeHTML(message.fileData.name)}</p><p class="file-card-size">${fileSize}</p></div></div>`;
        
        } else if (fileMatch) {
            let fileName = 'æœªå‘½åæ–‡ä»¶.txt', fileContent = '', parseSuccess = false;
            const rawJson = fileMatch[1];
            try { let cleanJson = rawJson.replace(/[\u201C\u201D]/g, '"').replace(/'/g, '"').replace(/(?:\r\n|\r|\n)/g, '\\n'); const fileData = JSON.parse(cleanJson); if (fileData) { fileName = fileData.name || fileName; fileContent = fileData.content || ''; parseSuccess = true; } } catch (e) {}
            if (!parseSuccess) { try { const nameMatch = rawJson.match(/name["']?\s*[:ï¼š]\s*["']([^"']+)["']/i); if (nameMatch) fileName = nameMatch[1]; const contentMatch = rawJson.match(/content["']?\s*[:ï¼š]\s*["']([\s\S]*?)["']\s*(?:,|}|\])/i); if (contentMatch) { fileContent = contentMatch[1]; parseSuccess = true; } } catch (e2) {} }
            if (parseSuccess || fileContent.length > 0) {
                const fileSize = formatFileSize(new Blob([fileContent]).size);
                finalContentHTML = `<div class="file-card" data-file-name="${escapeHTML(fileName)}" data-file-content="${escapeHTML(fileContent)}"><img src="https://i.postimg.cc/vms1Vd9X/1040g2sg31hh9ub1v3oeg5pbsckvn39vt3mbflao.png" alt="file icon" class="file-card-icon"><div class="file-card-info"><p class="file-card-name">${escapeHTML(fileName)}</p><p class="file-card-size">${fileSize}</p></div></div>`;
            } else { finalContentHTML = `<div class="system-notification-bubble">æ–‡ä»¶ç”Ÿæˆæ ¼å¼æœ‰è¯¯ï¼Œæ— æ³•æ˜¾ç¤º</div>`; }
        
        } else if (message.locationData || locationMatch) {
            let mainLoc, detailLoc;
            if (message.locationData) { mainLoc = message.locationData.main; detailLoc = message.locationData.detail; } 
            else { mainLoc = locationMatch[2] || locationMatch[5]; detailLoc = locationMatch[3] || locationMatch[6]; }
            finalContentHTML = `<div class="location-card" data-location-main="${escapeHTML(mainLoc)}" data-location-detail="${escapeHTML(detailLoc)}"><div class="location-card-info"><p class="location-main">${escapeHTML(mainLoc)}</p><p class="location-detail">${escapeHTML(detailLoc)}</p></div><div class="location-map"></div></div>`;
        
        } else if ((isSent && sentStickerMatch) || (!isSent && receivedStickerMatch)) {
            let stickerSrc = null, stickerName = '';
            if (isSent) {
                stickerSrc = stickerData; 
                const match = content.match(/\[.*?çš„è¡¨æƒ…åŒ…ï¼š(.*?)\]/);
                if (match) stickerName = match[1];
            } else { 
                stickerName = receivedStickerMatch[1].trim();
                const sticker = db.myStickers.find(s => s.name === stickerName);
                if (sticker) { stickerSrc = sticker.data; } 
                else {
                    const urlMatch = stickerName.match(/https?:\/\/[^\s\])]+/);
                    if (urlMatch) { stickerSrc = urlMatch[0]; } 
                    else { const pathExtractionRegex = /[a-zA-Z0-9]+\/.*$/; const extractedPathMatch = stickerName.match(pathExtractionRegex); const finalPath = extractedPathMatch ? extractedPathMatch[0] : stickerName; stickerSrc = `https://i.postimg.cc/${finalPath}`; }
                }
            }
            if (stickerSrc) { finalContentHTML = `<div class="image-bubble"><img src="${stickerSrc}" alt="è¡¨æƒ…åŒ…: ${escapeHTML(stickerName)}"></div>`; } 
            else { finalContentHTML = escapeHTML(`[è¡¨æƒ…åŒ…ï¼š${stickerName}]`); }
        
        } else if (!isSent && bareImageLinkMatch) {
            finalContentHTML = `<div class="image-bubble"><img src="${bareImageLinkMatch[1]}" alt="è¡¨æƒ…åŒ…"></div>`;
        
        } else if (privateGiftMatch || groupGiftMatch) {
            const match = privateGiftMatch || groupGiftMatch;
            const description = groupGiftMatch ? groupGiftMatch[3].trim() : match[1].trim();
            let giftText;
            if (groupGiftMatch) { const from = groupGiftMatch[1]; const to = groupGiftMatch[2]; giftText = isSent ? `ä½ é€ç»™ ${to} çš„ç¤¼ç‰©` : `${from} é€ç»™ ${to} çš„ç¤¼ç‰©`; } 
            else { giftText = 'æ‚¨æœ‰ä¸€ä»½ç¤¼ç‰©ï½'; }
            finalContentHTML = `<div class="gift-card ${giftStatus === 'received' ? 'received' : ''}"><img src="https://i.postimg.cc/rp0Yg31K/chan-75.png" alt="gift" class="gift-card-icon"><div class="gift-card-text">${giftText}</div><div class="gift-card-received-stamp">å·²æŸ¥æ”¶</div></div><div class="gift-card-description">${description}</div>`;
        
        } else if (voiceMatch) {
            const duration = calculateVoiceDuration(voiceMatch[1].trim());

            // ===== TTS åŠŸèƒ½ï¼šä¸ºAIè¯­éŸ³æ¶ˆæ¯æ·»åŠ è¯­éŸ³ID =====
            let voiceIdAttr = '';
            if (!isSent) { // åªä¸ºAIæ¶ˆæ¯æ·»åŠ è¯­éŸ³ID
                const character = currentChatType === 'private' ? db.characters.find(c => c.id === currentChatId) : null;
                if (character && character.enableTts !== false && character.minimaxVoiceId) {
                    voiceIdAttr = ` data-voice-id="${character.minimaxVoiceId}" data-text="${encodeURIComponent(voiceMatch[1].trim())}"`;
                }
            }

            // æ„å»ºè¯­éŸ³æ°”æ³¡HTML - ç›´æ¥æ‹¼æ¥å±æ€§
            finalContentHTML = `
                <div class="voice-bubble" style="background-color: ${bubbleTheme.bg}; color: ${bubbleTheme.text};"${voiceIdAttr}>
                    <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg>
                    <span class="duration">${duration}"</span>
                </div>
                <div class="voice-transcript">${voiceMatch[1].trim()}</div>`;


        } else if (privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch) {
            let amount, remarkText, titleText, statusText, cardClass;
            
            // --- æ ¸å¿ƒä¿®å¤ï¼šè½¬è´¦å¡ç‰‡æ ·å¼é€»è¾‘ ---
            if (groupTransferMatch) {
                const from = groupTransferMatch[1]; const to = groupTransferMatch[2]; amount = parseFloat(groupTransferMatch[3]).toFixed(2); remarkText = groupTransferMatch[4] || ''; titleText = isSent ? `å‘ ${to} è½¬è´¦` : `${from} å‘ä½ è½¬è´¦`; cardClass = isSent ? 'sent-transfer' : 'received-transfer'; statusText = 'å¾…æŸ¥æ”¶'; 
            } 
            else if (privateSentTransferMatch) {
                amount = parseFloat(privateSentTransferMatch[1]).toFixed(2); 
                remarkText = privateSentTransferMatch[2] || ''; 
                
                // ä¿®å¤ï¼šå¦‚æœæ˜¯æˆ‘å‘çš„(isSent=true)ï¼Œå°±æ˜¯æˆ‘ç»™Taè½¬ï¼Œæ ·å¼ä¸ºå‘é€
                // å¦‚æœæ˜¯AIå‘çš„(isSent=false)ï¼Œè™½ç„¶å†…å®¹æ˜¯"ç»™ä½ è½¬è´¦"ï¼Œä½†å¯¹æˆ‘æ¥è¯´æ˜¯"æ¥æ”¶"ï¼Œæ ·å¼ä¸ºæ¥æ”¶
                titleText = isSent ? 'è½¬è´¦' : 'ç»™ä½ è½¬è´¦';
                cardClass = isSent ? 'sent-transfer' : 'received-transfer';
                
                statusText = 'å¾…æŸ¥æ”¶';
                if (transferStatus === 'received') { statusText = 'å·²æ”¶æ¬¾'; cardClass += ' received'; } 
                else if (transferStatus === 'returned') { statusText = 'å·²é€€å›'; cardClass += ' returned'; }
            } 
            else if (privateReceivedTransferMatch) {
                amount = parseFloat(privateReceivedTransferMatch[1]).toFixed(2); 
                remarkText = privateReceivedTransferMatch[2] || ''; 
                titleText = 'è½¬è´¦'; 
                cardClass = isSent ? 'sent-transfer' : 'received-transfer'; // åŠ¨æ€åˆ¤æ–­
                statusText = 'è½¬è´¦ç»™ä½ ';
                if (transferStatus === 'received') { statusText = 'å·²æ”¶æ¬¾'; cardClass += ' received'; } 
                else if (transferStatus === 'returned') { statusText = 'å·²é€€å›'; cardClass += ' returned'; }
            }
            // --- ä¿®å¤ç»“æŸ ---

            const remarkHTML = remarkText ? `<p class="transfer-remark">${remarkText}</p>` : '';
            finalContentHTML = `<div class="transfer-card ${cardClass}"><div class="overlay"></div><div class="transfer-content"><p class="transfer-title">${titleText}</p><p class="transfer-amount">Â¥${amount}</p>${remarkHTML}<p class="transfer-status">${statusText}</p></div></div>`;
        
        } else if (photoVideoMatch) {
            finalContentHTML = `<div class="pv-card"><div class="pv-card-content">${photoVideoMatch[1].trim()}</div><div class="pv-card-image-overlay" style="background-image: url('${isSent ? 'https://i.postimg.cc/L8NFrBrW/1752307494497.jpg' : 'https://i.postimg.cc/1tH6ds9g/1752301200490.jpg'}');"></div><div class="pv-card-footer"><svg viewBox="0 0 24 24"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H20V6H4M10,9A1,1 0 0,1 11,10A1,1 0 0,1 10,11A1,1 0 0,1 9,10A1,1 0 0,1 10,9M8,17L11,13L13,15L17,10L20,14V17H8Z"></path></svg><span>ç…§ç‰‡/è§†é¢‘ãƒ»ç‚¹å‡»æŸ¥çœ‹</span></div>`;
        
        } else if (imageRecogMatch || (message.parts && message.parts.some(p => p.type === 'image'))) {
            const imageData = (message.parts && message.parts.find(p => p.type === 'image')) ? message.parts.find(p => p.type === 'image').data : content;
            finalContentHTML = `<div class="image-bubble"><img src="${imageData}" alt="å›¾ç‰‡æ¶ˆæ¯"></div>`;
        
        } else if (message.parts && message.parts[0] && message.parts[0].type === 'html') {
            const suffix = (id || Date.now()).toString().slice(-6);
            finalContentHTML = universalStyle + isolateHtmlIds(message.parts[0].text, suffix);
        
        } else {
            let innerText = textMatch ? textMatch[1].trim() : content.trim();
            if (urlRegex.test(innerText)) { finalContentHTML = `<div class="image-bubble"><img src="${innerText}" alt="å›¾ç‰‡æ¶ˆæ¯"></div>`; } 
            else { finalContentHTML = escapeHTML(innerText).replace(/\n/g, '<br>'); }
        }
    }
    
    // --- 4. æ„å»ºæœ€ç»ˆçš„DOMå…ƒç´  ---
    const wrapper = document.createElement('div');
    wrapper.dataset.id = id;
    wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
    if (currentChatType === 'private') {
        if (isSent && chat.isBlockedByAi && chat.aiBlockTimestamp && timestamp >= chat.aiBlockTimestamp && (!chat.blockEndTime || timestamp < chat.blockEndTime)) { wrapper.classList.add('user-was-blocked'); } 
        else if (!isSent && chat.isBlockedByUser && chat.userBlockTimestamp && timestamp >= chat.userBlockTimestamp) { wrapper.classList.add('ai-was-blocked'); }
    }
    if (currentChatType === 'group' && !isSent) { wrapper.classList.add('group-message'); }

    const bubbleRow = document.createElement('div');
    bubbleRow.className = 'message-bubble-row';

    if (currentChatType === 'private') {
        if (isSent) bubbleRow.innerHTML += `<span class="block-indicator sent">!</span>`;
        else bubbleRow.innerHTML += `<span class="block-indicator received">!</span>`;
    }

    const timeString = `${pad(new Date(timestamp).getHours())}:${pad(new Date(timestamp).getMinutes())}`;
    const infoDiv = document.createElement('div');
    infoDiv.className = 'message-info';
    
    let frameUrl = null;
    if (currentChatType === 'private') { frameUrl = isSent ? chat.myAvatarFrameUrl : chat.avatarFrameUrl; } 
    else { const sender = isSent ? chat.me : chat.members.find(m => m.id === senderId); if (sender) frameUrl = sender.avatarFrameUrl; }
    
    const avatarContainer = document.createElement('div');
    avatarContainer.className = 'avatar-container';
    avatarContainer.innerHTML = `<img src="${avatarUrl}" class="message-avatar">${frameUrl ? `<img src="${frameUrl}" class="avatar-frame">` : ''}`;
    infoDiv.innerHTML = `<span class="message-time">${timeString}</span>`;
    infoDiv.prepend(avatarContainer);

if (isRenderedByRule) {
        const theaterNode = document.createElement('div'); theaterNode.className = 'ai-generated-theater'; theaterNode.innerHTML = finalContentHTML;
        bubbleRow.appendChild(infoDiv); bubbleRow.appendChild(theaterNode);
    } else {
        const tempContainer = document.createElement('div');
        tempContainer.innerHTML = finalContentHTML;
        const specialBubble = tempContainer.firstElementChild;
        // å…³é”®ï¼šæ­£ç¡®è¯†åˆ«è¯­éŸ³å®¹å™¨å’Œå…¶ä»–å¡ç‰‡
        const specialClasses = ['image-bubble', 'pv-card', 'transfer-card', 'gift-card', 'file-card', 'location-card', 'music-card', 'voice-bubble'];
        const hasTranscript = tempContainer.querySelector('.voice-transcript');

        if (specialBubble && specialClasses.some(cls => specialBubble.classList.contains(cls)) && !hasTranscript) {
            bubbleRow.appendChild(infoDiv); 
            bubbleRow.appendChild(specialBubble); 
            
            // --- ä¿®å¤å¼€å§‹ï¼šå¦‚æœæ˜¯ç¤¼ç‰©å¡ç‰‡ï¼ŒæŠŠæè¿°éƒ¨åˆ†ä¹ŸåŠ è¿›å»ï¼Œé˜²æ­¢ç‚¹ä¸å¼€ ---
            if (specialBubble.classList.contains('gift-card')) {
                const giftDesc = tempContainer.querySelector('.gift-card-description');
                if (giftDesc) {
                    bubbleRow.appendChild(giftDesc);
                }
            }
            // --- ä¿®å¤ç»“æŸ ---

        } else {
            // æ™®é€šæ–‡å­—æˆ–è¯­éŸ³
            const bubbleElement = document.createElement('div');
            if (hasTranscript) {
                bubbleElement.className = 'voice-message-container'; 
                bubbleElement.style.background = 'none';
                bubbleElement.style.padding = '0';
            } else {
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
            }
            bubbleElement.innerHTML = finalContentHTML;
            bubbleRow.appendChild(infoDiv);
            bubbleRow.appendChild(bubbleElement);
        }
    }
    
    if (currentChatType === 'group' && !isSent) {
        const headerDiv = document.createElement('div'); headerDiv.className = 'group-message-header'; headerDiv.innerHTML = `${titleBadgeHTML}<span class="group-sender-name">${senderNickname}</span>`; wrapper.appendChild(headerDiv);
    }
    
    wrapper.appendChild(bubbleRow);
    return wrapper;
}


// START: ä¿®å¤ç‰ˆ addMessageBubble (ä¿®æ­£è½¬è´¦æ­£åˆ™å’ŒçŠ¶æ€æ›´æ–°)
async function addMessageBubble(message) {
    // 1. çŠ¶æ€æ›´æ–°é€»è¾‘ (ä¿æŒä¸å˜)
    const updateStatusRegex = /\[.*?æ›´æ–°çŠ¶æ€ä¸º[:ï¼š].*?\]/;
    if (updateStatusRegex.test(message.content) && message.role === 'assistant') {
        const statusMatch = message.content.match(/\[(.*?)\s*æ›´æ–°çŠ¶æ€ä¸º[:ï¼š](.*?)\]/);
        if (statusMatch) {
            const charName = statusMatch[1].trim();
            const newStatus = statusMatch[2].trim();
            const targetChar = db.characters.find(c => c.realName === charName || c.remarkName === charName);
            if (targetChar) {
                targetChar.status = newStatus;
                if (currentChatId === targetChar.id) {
                    const statusTextEl = document.getElementById('chat-room-status-text');
                    if (statusTextEl) statusTextEl.textContent = newStatus;
                }
                saveData(); 
            }
        }
        return; 
    }

    // 2. é€šè¯æŒ‡ä»¤æ‹¦æˆª (ä¿æŒä¸å˜)
    const callInitiateRegex = /\[call:(.*?)\]/;
    const callInitiateMatch = message.content.match(callInitiateRegex);
    if (callInitiateMatch && message.role === 'assistant') {
        const character = db.characters.find(c => c.realName === callInitiateMatch[1]);
        if (character) {
            startAiInitiatedCall(character.id);
        }
        return; 
    }

    // 3. æ‹¦æˆªä¸å¯è§æ¶ˆæ¯ (è½¬è´¦/æ”¶ç¤¼é€»è¾‘ä¿®å¤)
    // è¿™é‡Œçš„æ­£åˆ™åŠ å®½äº†åŒ¹é…èŒƒå›´ï¼Œå…è®¸ç©ºæ ¼
    const invisibleRegex = /\[[\s\S]*?(?:æ¥æ”¶|é€€å›)[\s\S]*?çš„è½¬è´¦\]|\[[\s\S]*?å·²æ¥æ”¶ç¤¼ç‰©\]|\[system:[\s\S]*?\]|\[system-context-only:[\s\S]*?\]|\[call-(?:accept|decline)\]|\[hangup\]|\[block-user\]|\[unblock-user\]/;
    
    if (invisibleRegex.test(message.content)) {
        if (currentChatType === 'private') {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) {
                // ä¿®å¤ï¼šæ›´å®½å®¹çš„æ­£åˆ™ï¼Œå…è®¸åå­—å‰åæœ‰ç©ºæ ¼
                const transferActionRegex = new RegExp(`\\[\\s*${character.realName}\\s*(æ¥æ”¶|é€€å›)\\s*${character.myName}\\s*çš„è½¬è´¦\\s*\\]`);
                const giftReceivedRegex = new RegExp(`\\[\\s*${character.realName}\\s*å·²æ¥æ”¶ç¤¼ç‰©\\s*\\]`);

                if (message.content.match(giftReceivedRegex) && message.role === 'assistant') {
                    const lastPendingGiftIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('é€æ¥çš„ç¤¼ç‰©ï¼š') && m.giftStatus !== 'received');
                    if (lastPendingGiftIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingGiftIndex;
                        character.history[actualIndex].giftStatus = 'received';
                        const giftCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${character.history[actualIndex].id}"] .gift-card`);
                        if (giftCardOnScreen) giftCardOnScreen.classList.add('received');
                        await saveData();
                    }
                } 
                else if (message.content.match(transferActionRegex) && message.role === 'assistant') {
                    const action = message.content.match(transferActionRegex)[1];
                    const statusToSet = action === 'æ¥æ”¶' ? 'received' : 'returned';
                    const lastPendingTransferIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('ç»™ä½ è½¬è´¦ï¼š') && m.transferStatus === 'pending');
                    if (lastPendingTransferIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingTransferIndex;
                        character.history[actualIndex].transferStatus = statusToSet;
                        const transferCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${character.history[actualIndex].id}"] .transfer-card`);
                        if (transferCardOnScreen) {
                            transferCardOnScreen.classList.remove('received', 'returned');
                            transferCardOnScreen.classList.add(statusToSet);
                            const statusElem = transferCardOnScreen.querySelector('.transfer-status');
                            if (statusElem) statusElem.textContent = statusToSet === 'received' ? 'å·²æ”¶æ¬¾' : 'å·²é€€å›';
                        }
                        await saveData();
                    }
                }
            }
        }
        return; 
    }

    const bubbleElement = createMessageBubbleElement(message);
    if (bubbleElement) {
        messageArea.appendChild(bubbleElement);
        messageArea.scrollTop = messageArea.scrollHeight;
    }
}

// END: æœ€ç»ˆä¿®æ­£ç‰ˆ addMessageBubble å‡½æ•°

// â–¼â–¼â–¼ ç¬¬ä¸‰æ­¥ï¼šè¯·å¤åˆ¶è¿™æ®µä»£ç ï¼Œå®Œæ•´æ›¿æ¢ sendMessage å‡½æ•° â–¼â–¼â–¼

// START: æœ€ç»ˆå¢å¼ºç‰ˆ sendMessage å‡½æ•° (å«ç²¾ç¡®çš„ä¸­æ–‡å¹´æœˆæ—¥æ˜ŸæœŸæ—¶é—´æ„ŸçŸ¥)
async function sendMessage(targetInput = null) {
    // ğŸ†• é˜²é‡å¤å‘é€æ£€æŸ¥
    if (isSending) {
        console.warn('âš ï¸ æ­£åœ¨å‘é€ä¸­ï¼Œè¯·å‹¿é‡å¤ç‚¹å‡»');
        return;
    }

    // ä¼˜åŒ–ç‚¹ï¼šå…¼å®¹å¾®ä¿¡å¸ƒå±€ä¼ å‚ï¼Œæˆ–è€…è‡ªåŠ¨è·å–å½“å‰æ˜¾ç¤ºçš„è¾“å…¥æ¡†
    const currentInputElement = targetInput || (db.useWechatLayout 
        ? document.getElementById('wechat-message-input') 
        : document.getElementById('message-input'));

    const text = currentInputElement.value.trim();
    if (!text || isGenerating) return;

    // ğŸ†• ç«‹å³æ¸…ç©ºè¾“å…¥æ¡†ï¼ˆOptimistic UI æ›´æ–°ï¼‰
    currentInputElement.value = '';
    
    // ğŸ†• é‡ç½®è¾“å…¥æ¡†é«˜åº¦ï¼ˆå¦‚æœæœ‰è‡ªé€‚åº”é«˜åº¦ï¼‰
    if (currentInputElement.style.height) {
        currentInputElement.style.height = 'auto';
    }
    
    // ğŸ†• è®¾ç½®å‘é€é”
    isSending = true;
    
    try {
        const chat = (currentChatType === 'private') 
            ? db.characters.find(c => c.id === currentChatId) 
            : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        // --- åˆ¤æ–­æ˜¯å¦å¤„äºæ‹‰é»‘çŠ¶æ€ ---
        if (currentChatType === 'private' && chat.isBlockedByUser) {
            const myName = chat.myName;
            const messageContent = `[${myName}çš„æ¶ˆæ¯ï¼š${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{ type: 'text', text: messageContent }],
                timestamp: Date.now()
            };

            chat.pendingMessages = chat.pendingMessages || [];
            chat.pendingMessages.push(message);
            addMessageBubble(message);
            await saveData();
            // ğŸ†• è¾“å…¥æ¡†å·²åœ¨å‡½æ•°å¼€å¤´æ¸…ç©ºï¼Œæ­¤å¤„ä¸å†éœ€è¦
            return;
        }

        // ==========================================
        // â˜…â˜…â˜… æ–°å¢ï¼šå¢å¼ºæ—¶é—´æ„ŸçŸ¥é€»è¾‘ (ç²¾ç¡®åˆ°å¹´æœˆæ—¥æ˜ŸæœŸ) â˜…â˜…â˜…
        // ==========================================
        if (db.apiSettings && db.apiSettings.timePerceptionEnabled) {
            const now = Date.now();
            const nowDate = new Date();
            const lastMessageTime = chat.lastUserMessageTimestamp || 0;
            
            // æ„å»ºç²¾ç¡®çš„ä¸­æ–‡æ—¶é—´å­—ç¬¦ä¸² (ä¾‹å¦‚: 2023å¹´12æœˆ03æ—¥ æ˜ŸæœŸæ—¥ 14:30)
            // è¿™æ ·AIèƒ½éå¸¸æ¸…æ¥šåœ°è¯†åˆ«å‡º"ä»Šå¤©å‡ å·"ã€"æ˜ŸæœŸå‡ "
            const weekDays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
            const currentTimeStr = `${nowDate.getFullYear()}å¹´${nowDate.getMonth() + 1}æœˆ${nowDate.getDate()}æ—¥ ${weekDays[nowDate.getDay()]} ${String(nowDate.getHours()).padStart(2, '0')}:${String(nowDate.getMinutes()).padStart(2, '0')}`;

            // è¾…åŠ©å‡½æ•°ï¼šæ ¼å¼åŒ–æ—¶é—´å·®
            const formatTimeGap = (milliseconds) => {
                const seconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);
                const days = Math.floor(hours / 24);
                if (days > 0) return `${days}å¤©${hours % 24}å°æ—¶`;
                if (hours > 0) return `${hours}å°æ—¶${minutes % 60}åˆ†é’Ÿ`;
                if (minutes > 0) return `${minutes}åˆ†é’Ÿ`;
                return `åˆšåˆš`;
            };

            // æƒ…å†µ1ï¼šå¦‚æœé—´éš”è¶…è¿‡30åˆ†é’Ÿ -> å‘é€"è¿‡å»äº†å¤šä¹…"çš„æç¤º
            if (lastMessageTime > 0 && (now - lastMessageTime > 30 * 60 * 1000)) {
                const timeGap = now - lastMessageTime;
                const timeGapStr = formatTimeGap(timeGap);

                // 1. åˆ›å»ºå¯¹ç”¨æˆ·å¯è§çš„æç¤º
                const displayContent = `[system-display:è·ç¦»ä¸Šæ¬¡èŠå¤©å·²ç»è¿‡å» ${timeGapStr}]`;
                const visualMessage = {
                    id: `msg_visual_timesense_${Date.now()}`,
                    role: 'system', 
                    content: displayContent,
                    parts: [],
                    timestamp: now - 2 
                };

                // 2. åˆ›å»ºç»™AIçœ‹çš„ç³»ç»ŸæŒ‡ä»¤ (åŒ…å«ç²¾ç¡®æ—¶é—´)
                const contextContent = `[system: ä¸ç”¨æˆ·çš„ä¸Šä¸€æ¬¡äº’åŠ¨å‘ç”Ÿåœ¨${timeGapStr}å‰ã€‚å½“å‰ç°å®æ—¶é—´æ˜¯ ${currentTimeStr}ã€‚è¯é¢˜å¯èƒ½å·²ç»ä¸è¿ç»­ï¼Œä½ éœ€è¦ä½œå‡ºç›¸å…³ååº”ã€‚]`;
                const contextMessage = {
                    id: `msg_context_timesense_${Date.now()}`,
                    role: 'user',
                    content: contextContent,
                    parts: [{ type: 'text', text: contextContent }],
                    timestamp: now - 1
                };

                if (currentChatType === 'group') {
                    visualMessage.senderId = 'user_me';
                    contextMessage.senderId = 'user_me';
                }

                chat.history.push(visualMessage, contextMessage);
                addMessageBubble(visualMessage);
            } 
            // æƒ…å†µ2ï¼šæ­£å¸¸è¿ç»­èŠå¤© -> æ‚„æ‚„å‘Šè¯‰AIå½“å‰çš„ç²¾ç¡®æ—¶é—´
            else {
                const timeContextContent = `[system-context-only: å½“å‰ç°å®æ—¶é—´æ˜¯ ${currentTimeStr}]`;
                const timeContextMessage = {
                    id: `msg_context_time_${Date.now()}`,
                    role: 'user',
                    content: timeContextContent,
                    parts: [{ type: 'text', text: timeContextContent }],
                    timestamp: now - 1
                };

                if (currentChatType === 'group') {
                    timeContextMessage.senderId = 'user_me';
                }
                chat.history.push(timeContextMessage);
            }
            
            // æ›´æ–°æœ€åäº’åŠ¨æ—¶é—´
            chat.lastUserMessageTimestamp = now;
        }
        // ==========================================
        // â˜…â˜…â˜… æ—¶é—´æ„ŸçŸ¥é€»è¾‘ç»“æŸ â˜…â˜…â˜…
        // ==========================================

        // --- ä»¥ä¸‹æ˜¯æ­£å¸¸çš„å‘é€é€»è¾‘ ---
        let message;
        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;

        if (currentQuotedMessageId) {
            const originalMessage = chat.history.find(m => m.id === currentQuotedMessageId);
            if (!originalMessage) {
                cancelQuoteReply();
                return; 
            }
            
            let originalSenderName = '';
            let cleanOriginalContent = originalMessage.content;

            if (currentChatType === 'private') {
                originalSenderName = originalMessage.role === 'user' ? myName : chat.remarkName;
            } else {
                const sender = originalMessage.senderId === 'user_me' ? chat.me : chat.members.find(m => m.id === originalMessage.senderId);
                originalSenderName = sender ? (sender.nickname || sender.groupNickname) : 'æœªçŸ¥';
            }
            
            const textRegex = /\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/;
            const match = originalMessage.content.match(textRegex);
            if (match) cleanOriginalContent = match[1];
            if (originalMessage.replyText) cleanOriginalContent = originalMessage.replyText;

            const messageContentForAI = `[${myName}å¼•ç”¨äº†"${originalSenderName}: ${cleanOriginalContent}"çš„æ¶ˆæ¯å¹¶å›å¤ï¼š${text}]`;

            message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContentForAI,
                parts: [{ type: 'text', text: messageContentForAI }],
                timestamp: Date.now(),
                quote: {
                    messageId: currentQuotedMessageId,
                    sender: originalSenderName,
                    content: cleanOriginalContent
                },
                replyText: text
            };

            cancelQuoteReply();
        } else {
            const systemRegex = /\[system:.*?\]|\[system-display:.*?\]/;
            const inviteRegex = /\[.*?é‚€è¯·.*?åŠ å…¥äº†ç¾¤èŠ\]/;
            const renameRegex = /\[(.*?)ä¿®æ”¹ç¾¤åä¸ºï¼š(.*?)\]/;
            let messageContent;

            if (currentChatType === 'group' && renameRegex.test(text)) {
                const match = text.match(renameRegex);
                chat.name = match[2];
                chatRoomTitle.textContent = chat.name;
                messageContent = `[${chat.me.nickname}ä¿®æ”¹ç¾¤åä¸ºï¼š${chat.name}]`;
            } else if (systemRegex.test(text) || inviteRegex.test(text)) {
                messageContent = text;
            } else {
                messageContent = `[${myName}çš„æ¶ˆæ¯ï¼š${text}]`;
            }

            message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{ type: 'text', text: messageContent }],
                timestamp: Date.now()
            };
        }

        if (currentChatType === 'group') {
            message.senderId = 'user_me';
        }
        chat.history.push(message);
        addMessageBubble(message);
        await saveData();
        renderChatList();
        if (chat.povCache) {
            chat.povCache = null;
        }
        
        // ğŸ†• è¾“å…¥æ¡†å·²åœ¨å‡½æ•°å¼€å¤´æ¸…ç©ºï¼Œæ­¤å¤„ä¸å†éœ€è¦
        
        // ğŸ†• æ—¥è®°è§¦å‘æ£€æŸ¥ï¼ˆé‡Œç¨‹ç¢‘æ–¹æ¡ˆï¼‰- ä»…åœ¨ç§èŠæ—¶æ£€æŸ¥
        if (currentChatType === 'private' && chat) {
            checkDiaryTriggerByCheckpoint(chat);
        }
        
    } catch (error) {
        // ğŸ†• é”™è¯¯å¤„ç†ï¼šå‘é€å¤±è´¥æ—¶æ¢å¤æ–‡æœ¬åˆ°è¾“å…¥æ¡†
        console.error('âŒ å‘é€æ¶ˆæ¯å¤±è´¥:', error);
        if (currentInputElement) {
            currentInputElement.value = text;
        }
        showToast('å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
        // ğŸ†• é‡Šæ”¾å‘é€é”
        isSending = false;
    }
}

// ===== ğŸ†• æ—¥è®°è§¦å‘é‡Œç¨‹ç¢‘æ£€æŸ¥å‡½æ•°ï¼ˆCheckpoint çº¯å‡€ç‰ˆï¼‰ =====
/**
 * æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘æ—¥è®°ç”Ÿæˆ
 * é€»è¾‘ï¼šæ¯ 200 æ¡æœ‰æ•ˆå¯¹è¯ï¼ˆæ’é™¤ç³»ç»Ÿéšè—æ¶ˆæ¯ï¼‰ï¼Œæœ‰ 90% æ¦‚ç‡è§¦å‘ä¸€æ¬¡
 */
function checkDiaryTriggerByCheckpoint(character) {
    // 1. å®‰å…¨æ£€æŸ¥
    if (!character || !character.id) return false;
    
    // 2. ç²¾å‡†è®¡ç®—æœ‰æ•ˆæ¶ˆæ¯é•¿åº¦ï¼ˆæ’é™¤ system å’Œ ä¼ªè£…æˆ user çš„ hidden æ¶ˆæ¯ï¼‰
    const chatHistory = character.history;
    const currentTotalLength = (chatHistory && Array.isArray(chatHistory))
        ? chatHistory.filter(m => 
            (m.role === 'user' || m.role === 'assistant') && 
            m.content && 
            !m.content.startsWith('[system')
          ).length
        : 0;
    
    // 3. è·å–é‡Œç¨‹ç¢‘
    const STORAGE_KEY = `diary_last_gen_count_${character.id}`;
    let lastGenLength = parseInt(localStorage.getItem(STORAGE_KEY), 10);
    
    // 4. è‡ªåŠ¨çº é”™ï¼ˆå¦‚æœç®—æ³•æ”¹å˜å¯¼è‡´è®¡æ•°å›é€€ï¼Œé™é»˜é‡ç½®ï¼‰
    if (isNaN(lastGenLength) || lastGenLength < 0 || currentTotalLength < lastGenLength) {
        lastGenLength = currentTotalLength;
        localStorage.setItem(STORAGE_KEY, lastGenLength.toString());
        return false;
    }
    
    // 5. è®¡ç®—å·®å€¼
    const delta = currentTotalLength - lastGenLength;
    
    // 6. è§¦å‘åˆ¤æ–­ï¼šæ¯ 200 æ¡æœ‰æ•ˆæ¶ˆæ¯
    if (delta >= 200) {
        // 90% æ¦‚ç‡è§¦å‘
        if (Math.random() < 0.9) {
            console.log(`âœ… [æ—¥è®°æ£€æŸ¥] æ¦‚ç‡å‘½ä¸­ï¼å¼€å§‹ç”Ÿæˆæ—¥è®°...`);
            
            // æ‰§è¡Œç”Ÿæˆ
            if (typeof generateDiaryEntry === 'function') {
                generateDiaryEntry(character.id).catch(err => {
                    console.error('âŒ [æ—¥è®°è°ƒåº¦] æ‰§è¡Œå‡ºé”™:', err);
                });
            }
            
            // åªæœ‰è§¦å‘æˆåŠŸæ‰æ›´æ–°é‡Œç¨‹ç¢‘
            localStorage.setItem(STORAGE_KEY, currentTotalLength.toString());
            return true;
        } 
        // æ¦‚ç‡æœªå‘½ä¸­æ—¶ä¸æ‰“å°æ—¥å¿—ï¼Œä¸æ›´æ–°é‡Œç¨‹ç¢‘ï¼ˆä¸‹æ¬¡ç»§ç»­å°è¯•ï¼‰
    }
    
    return false;
}
// ===== æ—¥è®°è§¦å‘é‡Œç¨‹ç¢‘æ£€æŸ¥å‡½æ•°ç»“æŸ =====

// --- è¾…åŠ©å‡½æ•°ï¼šæ ¼å¼åŒ–æ—¶é—´å·® ---
function formatTimeGap(milliseconds) {
    const seconds = Math.floor(milliseconds / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days}å¤©${hours % 24}å°æ—¶`;
    if (hours > 0) return `${hours}å°æ—¶${minutes % 60}åˆ†é’Ÿ`;
    if (minutes > 0) return `${minutes}åˆ†é’Ÿ`;
    return `${seconds}ç§’`;
}

// --- è¾…åŠ©å‡½æ•°ï¼šè·å–å½“å‰æ ¼å¼åŒ–æ—¶é—´ ---
function getFormattedTimestamp(date) {
    const Y = date.getFullYear();
    const M = String(date.getMonth() + 1).padStart(2, '0');
    const D = String(date.getDate()).padStart(2, '0');
    const h = String(date.getHours()).padStart(2, '0');
    const m = String(date.getMinutes()).padStart(2, '0');
    return `${Y}-${M}-${D} ${h}:${m}`;
}
// â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²


        async function sendImageForRecognition(base64Data) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘');
        return; // é˜»æ­¢å‡½æ•°ç»§ç»­æ‰§è¡Œ
    }
}
            if (!base64Data || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const textPrompt = `[${myName}å‘æ¥äº†ä¸€å¼ å›¾ç‰‡ï¼š]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: base64Data,
                parts: [{type: 'text', text: textPrompt}, {type: 'image', data: base64Data}],
                timestamp: Date.now(),
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
        }

        async function sendSticker(sticker) {
            if (currentChatType === 'private') {
                const character = db.characters.find(c => c.id === currentChatId);
                if (character && character.isBlockedByAi) {
                    showToast('ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘');
                    return; // é˜»æ­¢å‡½æ•°ç»§ç»­æ‰§è¡Œ
                }
            }
            
            // ğŸ†• æ›´æ–°è¡¨æƒ…åŒ…çš„æœ€åä½¿ç”¨æ—¶é—´
            const stickerInDb = db.myStickers.find(s => s.id === sticker.id);
            if (stickerInDb) {
                stickerInDb.lastUsedTime = Date.now();
            }
            
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const messageContentForAI = `[${myName}çš„è¡¨æƒ…åŒ…ï¼š${sticker.name}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContentForAI,
                parts: [{type: 'text', text: messageContentForAI}],
                timestamp: Date.now(),
                stickerData: sticker.data
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            stickerModal.classList.remove('visible');
        }

        async function sendMyVoiceMessage(text) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘');
        return; // é˜»æ­¢å‡½æ•°ç»§ç»­æ‰§è¡Œ
    }
}
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}çš„è¯­éŸ³ï¼š${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendVoiceModal.classList.remove('visible');
        }

        async function sendMyPhotoVideo(text) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘');
        return; // é˜»æ­¢å‡½æ•°ç»§ç»­æ‰§è¡Œ
    }
}
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
            const content = `[${myName}å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘ï¼š${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendPvModal.classList.remove('visible');
        }

               async function sendMyTransfer(amount, remark) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘');
        return; // é˜»æ­¢å‡½æ•°ç»§ç»­æ‰§è¡Œ
    }
}
            const numericAmount = parseFloat(amount);
            if (isNaN(numericAmount) || numericAmount <= 0) {
                 showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
                 return;
            }
            
            // --- æ–°å¢ï¼šæ”¯ä»˜é€»è¾‘ ---
             try {
                await handlePayment(numericAmount, `è½¬è´¦`);
            } catch (error) {
                showToast(error.message);
                return; // ä¸­æ–­è½¬è´¦æµç¨‹
            }
            // --- æ”¯ä»˜é€»è¾‘ç»“æŸ ---

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (currentChatType === 'private') {
                const content = `[${chat.myName}ç»™ä½ è½¬è´¦ï¼š${numericAmount.toFixed(2)}å…ƒï¼›å¤‡æ³¨ï¼š${remark}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    transferStatus: 'pending'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} å‘ ${recipient.realName} è½¬è´¦ï¼š${numericAmount.toFixed(2)}å…ƒï¼›å¤‡æ³¨ï¼š${remark}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendTransferModal.classList.remove('visible');
        }

                      async function sendMyGift(description, amount) {
            if (!description) return;
            
            // --- â–¼â–¼â–¼ ä¿®æ”¹ï¼šæ”¯ä»˜é€»è¾‘ä½¿ç”¨åŠ¨æ€ä»·æ ¼ â–¼â–¼â–¼ ---
            const giftPrice = parseFloat(amount); 
            if (isNaN(giftPrice) || giftPrice <= 0) {
                showToast("è¯·è¾“å…¥æœ‰æ•ˆçš„ç¤¼ç‰©ä»·æ ¼");
                return;
            }

            const recipientName = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId).remarkName 
                : 'ç¾¤æˆå‘˜';

            try {
                // è°ƒç”¨æ”¯ä»˜å¤„ç†å‡½æ•°ï¼Œä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„ä»·æ ¼
                await handlePayment(giftPrice, `é€ç¤¼ç‰©ç»™ ${recipientName}`);
            } catch (error) {
                showToast(error.message); 
                return; 
            }
            // --- â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–² ---

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);

            if (currentChatType === 'private') {
                const content = `[${chat.myName}é€æ¥çš„ç¤¼ç‰©ï¼š${description}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    giftStatus: 'sent'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me.nickname} å‘ ${recipient.realName} é€æ¥äº†ç¤¼ç‰©ï¼š${description}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendGiftModal.classList.remove('visible');
        }
        // --- NEW: Time Skip System ---
        function setupTimeSkipSystem() {
            timeSkipBtn.addEventListener('click', () => {
                timeSkipForm.reset();
                timeSkipModal.classList.add('visible');
            });
            timeSkipModal.addEventListener('click', (e) => {
                if (e.target === timeSkipModal) timeSkipModal.classList.remove('visible');
            });
            timeSkipForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendTimeSkipMessage(timeSkipInput.value.trim());
            });
        }

  // â–¼â–¼â–¼ åœ¨è¿™é‡Œç²˜è´´æ–°çš„è§†é¢‘é€šè¯JSä»£ç  â–¼â–¼â–¼

function setupVoiceCallSystem() {
    const voiceCallBtn = document.getElementById('voice-call-btn');
    const voiceCallOverlay = document.getElementById('voice-call-overlay');
    const callAvatar = document.getElementById('call-avatar');
    const callName = document.getElementById('call-name');
    const callStatus = document.getElementById('call-status');
    const ringingView = document.getElementById('ringing-view');
    const incomingButtons = document.getElementById('incoming-buttons');
    const outgoingButtons = document.getElementById('outgoing-buttons');
    const activeCallView = document.getElementById('active-call-view');
    const callTranscriptArea = document.getElementById('call-transcript-area');
    const hangupCallBtn = document.getElementById('hangup-call-btn');
    const callInput = document.getElementById('call-input');
    const sendCallMessageBtn = document.getElementById('send-call-message-btn');
    const declineCallBtn = document.getElementById('decline-call-btn');
    const acceptCallBtn = document.getElementById('accept-call-btn');
    const cancelCallBtn = document.getElementById('cancel-call-btn');

    voiceCallBtn.addEventListener('click', startUserInitiatedCall);
    cancelCallBtn.addEventListener('click', () => endCall('ended'));
    declineCallBtn.addEventListener('click', () => endCall('declined'));
    acceptCallBtn.addEventListener('click', () => {
        const character = db.characters.find(c => c.id === currentCallTargetId);
        if (!character) return;
        const contextMessage = {
            id: `msg_call_${Date.now()}`, role: 'user',
            content: `[system: ${character.myName} æ¥å¬äº†ä½ çš„ç”µè¯ã€‚]`,
            parts: [{type: 'text', text: `[system: ${character.myName} æ¥å¬äº†ä½ çš„ç”µè¯ã€‚]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        saveData();
        startActiveCall();
    });
    hangupCallBtn.addEventListener('click', () => endCall('ended'));
    sendCallMessageBtn.addEventListener('click', sendCallMessage);
    callInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendCallMessage();
    });
}

function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = 'æ­£åœ¨å‘¼å«...';

    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('å¯¹æ–¹æ— åº”ç­”');
            endCall('timeout');
        }
    }, 60000); 

    const callMessage = {
        id: `msg_call_${Date.now()}`, role: 'user',
        content: `[system: ${character.myName} æ­£åœ¨å‘¼å«ä½ ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å†³å®šæ˜¯æ¥å¬ [call-accept] è¿˜æ˜¯æ‹’æ¥ [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} æ­£åœ¨å‘¼å«ä½ ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å†³å®šæ˜¯æ¥å¬ [call-accept] è¿˜æ˜¯æ‹’æ¥ [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply();
}

function startAiInitiatedCall(characterId) {
	isAiCalling = false; 
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = 'æ¥ç”µé‚€è¯·...';
}

function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
    
    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', 'é€šè¯å·²è¿æ¥');
    
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        callStatus.textContent = timeString; 
    }, 1000);

    getAiCallReply("[system: é€šè¯å·²æ¥é€šï¼Œè¯·è¯´ç¬¬ä¸€å¥è¯ã€‚]");
}

// è¿™æ˜¯æ–°çš„ã€ä¿®å¤åçš„ä»£ç ï¼Œè¯·å®Œæ•´å¤åˆ¶å¹¶æ›¿æ¢
async function endCall(reason = 'ended') {
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    const character = db.characters.find(c => c.id === currentCallTargetId);

    // æ— è®ºé€šè¯æ˜¯å¦æ›¾æ¥é€šï¼Œåªè¦UIè¿˜åœ¨ï¼Œå°±å…ˆéšè—å®ƒ
    voiceCallOverlay.classList.remove('visible');

    if (!character) {
        // å¦‚æœæ‰¾ä¸åˆ°è§’è‰²ä¿¡æ¯ï¼Œé‡ç½®çŠ¶æ€å¹¶ç›´æ¥é€€å‡º
        isVoiceCallActive = false;
        currentCallTargetId = null;
        clearInterval(callTimerInterval);
        return;
    }

    // æ¸…ç†è®¡æ—¶å™¨å’Œé€šè¯çŠ¶æ€
    clearInterval(callTimerInterval);
    const duration = callStatus.textContent;

    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘å¼€å§‹ ---
    if (isVoiceCallActive) { // æƒ…å†µä¸€ï¼šé€šè¯æ›¾è¢«æ¥é€šè¿‡
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`, role: 'system',
            content: `[system-display:ä¸ ${character.remarkName} çš„é€šè¯å·²ç»“æŸï¼Œæ—¶é•¿ ${duration}]`,
            parts: [], timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`, role: 'user',
            content: `[system: ä¸ ${character.realName} çš„é€šè¯å·²ç»“æŸã€‚é€šè¯è®°å½•ï¼š${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: ä¸ ${character.realName} çš„é€šè¯å·²ç»“æŸã€‚é€šè¯è®°å½•ï¼š${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    } else { // æƒ…å†µäºŒï¼šé€šè¯ä»æœªæ¥é€šï¼ˆè¢«æ‹’æ¥æˆ–æ— åº”ç­”ï¼‰
        let transitionPrompt = '';
        if (reason === 'declined') {
            // å¦‚æœæ˜¯AIä¸»åŠ¨æ‹’æ¥ï¼Œå¼ºåˆ¶å®ƒå‘æ¶ˆæ¯è§£é‡Š
            transitionPrompt = `[system: ä½ åˆšåˆšæ‹’ç»äº† ${character.myName} çš„ç”µè¯ã€‚è¯·ç”¨ä¸€å¥è¯å‘ç”¨æˆ·è§£é‡Šä½ ä¸ºä»€ä¹ˆä¸æ–¹ä¾¿æ¥ç”µè¯ï¼Œä»¥è‡ªç„¶åœ°è¿‡æ¸¡å›èŠå¤©ã€‚]`;
        } else if (reason === 'timeout' || reason === 'no_action_reply') {
            // å¦‚æœæ˜¯è¶…æ—¶æœªæ¥ï¼Œå¼ºåˆ¶å®ƒå‘æ¶ˆæ¯è¡¨ç¤ºæ­‰æ„æˆ–è¯¢é—®
            transitionPrompt = `[system: ä½ ä¼¼ä¹é”™è¿‡äº† ${character.myName} çš„æ¥ç”µã€‚è¯·å‘ä¸€æ¡æ¶ˆæ¯è¡¨ç¤ºæ­‰æ„æˆ–è¯¢é—®å¯¹æ–¹æœ‰ä»€ä¹ˆäº‹ï¼Œä»¥è‡ªç„¶åœ°è¿‡æ¸¡å›èŠå¤©ã€‚]`;
        }

        if (transitionPrompt) {
            const contextMessage = {
                id: `msg_call_fail_${Date.now()}`, role: 'user',
                content: transitionPrompt,
                parts: [{type: 'text', text: transitionPrompt}],
                timestamp: Date.now()
            };
            character.history.push(contextMessage);
            // å…³é”®ï¼šä¸»åŠ¨è§¦å‘ä¸€æ¬¡AIå›å¤ï¼Œå¼ºåˆ¶å®ƒä»å¡æ­»çš„çŠ¶æ€ä¸­æ¢å¤
            if (currentChatId === character.id) {
                getAiReply();
            }
        }
    }
    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘ç»“æŸ ---

    // ç»Ÿä¸€é‡ç½®æ‰€æœ‰çŠ¶æ€
    isVoiceCallActive = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    
    await saveData();
}

function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text);
    getAiCallReply(text);
    callInput.value = '';
}

async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
      // --- â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹ï¼šæ·»åŠ äº†ç¬¬5æ¡ç»å¯¹ç¦æ­¢è§„åˆ™ â–¼â–¼â–¼ ---
        const prompt = `[é€šè¯ä¸­] ä½ æ˜¯ ${character.realName} (äººè®¾: ${character.persona})ï¼Œæ­£åœ¨å’Œ ${character.myName} é€šè¯ã€‚ä½ çš„å›å¤å¿…é¡»éµå¾ªä»¥ä¸‹æ ¸å¿ƒè§„åˆ™ï¼š
1.  **ä¸°å¯Œæå†™**: ä½ çš„å›å¤ä¸ä»…é™äºå¯¹è¯ï¼Œå¿…é¡»åŒ…å«ä¸°å¯Œçš„**åŠ¨ä½œå’Œç¯å¢ƒæå†™**ï¼Œå¹¶ä½¿ç”¨è‹±æ–‡æ‹¬å· () å°†å…¶åŒ…è£¹èµ·æ¥ã€‚è¿™å¯¹äºè¥é€ é€šè¯çš„çœŸå®æ„Ÿè‡³å…³é‡è¦ã€‚
2.  **å†…å®¹é•¿åº¦**: ä½ çš„æ¯æ¬¡å›å¤**å¿…é¡»åŒ…å«3å¥æˆ–æ›´å¤šçš„å¥å­**ï¼Œç¡®ä¿å†…å®¹é¥±æ»¡ï¼Œé¿å…ç®€çŸ­çš„å›ç­”ã€‚
3.  **ä¿æŒäººè®¾**: æ‰€æœ‰å›å¤éƒ½å¿…é¡»**ä¸¥æ ¼éµå¾ªä½ çš„äººè®¾å’Œå½“å‰çš„å¯¹è¯ä¸Šä¸‹æ–‡**ã€‚
4.  **ç›´æ¥è¾“å‡º**: è¯·ç›´æ¥è¾“å‡ºå¯¹è¯å’Œæå†™å†…å®¹ï¼Œä¸è¦æ·»åŠ ä»»ä½•é¢å¤–çš„å‰ç¼€æˆ–è§£é‡Šã€‚
5.  **ã€ç»å¯¹ç¦æ­¢ã€‘**: ä½ çš„å›å¤å†…å®¹æœ¬èº«ï¼Œç»å¯¹ç¦æ­¢è¢« "[...æ¶ˆæ¯ï¼š...]" è¿™ç§æ ¼å¼æ‰€åŒ…è£¹ã€‚`;
        // --- â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–² ---
        const callHistory = voiceCallTranscript.map(line => ({
            role: line.sender === 'user' ? 'user' : 'assistant',
            content: line.text
        }));
        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5),
            { role: 'user', content: userText }
        ];
        const aiResponseText = await callAiApi(messages);
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }
    } catch (error) {
        // --- æ ¸å¿ƒä¿®æ”¹ï¼šå¢åŠ ç”¨æˆ·æç¤º ---
        const errorMessage = `[AIæœåŠ¡å™¨è¿”å›é”™è¯¯: ${error.message}]`;
        appendCallTranscript("system", errorMessage);
        showToast('AIå›å¤å¤±è´¥ï¼Œå¯èƒ½æ˜¯æœåŠ¡å™¨ä¸´æ—¶é—®é¢˜'); // å¼¹å‡ºé¡¶éƒ¨çš„å‹å¥½æç¤º
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

function appendCallTranscript(sender, text) {
    voiceCallTranscript.push({ sender, text });
    const line = document.createElement('div');
    line.className = 'call-transcript-line';

    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? 'æˆ‘' : callName.textContent;
        
        // --- â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ­£ï¼šä½¿ç”¨æ›´é€šç”¨çš„æ­£åˆ™è¡¨è¾¾å¼ â–¼â–¼â–¼ ---
        let cleanText = text;
        if (sender === 'ai') {
            // è¿™ä¸ªæ–°è§„åˆ™å¯ä»¥åŒ¹é… "[ä»»æ„å­—ç¬¦çš„æ¶ˆæ¯ï¼š...]"
            const contentMatch = text.match(/\[.*?çš„æ¶ˆæ¯[:ï¼š]\s*([\s\S]+?)\]/);
            if (contentMatch && contentMatch[1]) {
                cleanText = contentMatch[1].trim(); 
            }
        }
        // --- â–²â–²â–² ä¿®æ­£ç»“æŸ â–²â–²â–² ---

        const styledText = cleanText.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight;
}
// --- NEW: File System Setup ---
function setupFileSystem() {
    fileBtn.addEventListener('click', () => {
        sendFileModal.classList.add('visible');
        sendFileForm.reset();
    });

    sendFileForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        const fileName = fileNameInput.value.trim();
        const fileContent = fileContentInput.value.trim();
        if (!fileName || !fileContent) return;

        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
        
        // This string is what's displayed in the chat bubble (without file content)
        const contentString = `[${myName}çš„æ–‡ä»¶ï¼š${fileName}]`;
        
        // This string includes the content and is sent to the AI for context
        const aiContentString = `[${myName}å‘é€çš„æ–‡ä»¶ï¼Œæ–‡ä»¶åï¼š'${fileName}'ï¼Œæ–‡ä»¶å†…å®¹ï¼š'${fileContent}']`;

        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contentString,
            parts: [{ type: 'text', text: aiContentString }], // Send full content to AI
            timestamp: Date.now(),
            senderId: 'user_me',
            fileData: { name: fileName, content: fileContent } // Store data for rendering the card
        };

        chat.history.push(message);
        await saveData();
        renderMessages(false, true);
        renderChatList();
        sendFileModal.classList.remove('visible');
    });
}
// --- NEW: Location System Setup ---
function setupLocationSystem() {
    locationBtn.addEventListener('click', () => {
        sendLocationModal.classList.add('visible');
        sendLocationForm.reset();
    });

    sendLocationForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
        if (!chat) return;

        const mainLocation = locationMainInput.value.trim();
        const detailLocation = locationDetailInput.value.trim();
        if (!mainLocation || !detailLocation) return;

        const myName = (currentChatType === 'private') ? chat.myName : chat.me.nickname;
        
        // For display in chat list preview & simple fallback
        const contentString = `[${myName}çš„ä½ç½®å…±äº«]`; 
        
        // For AI context
        const aiContentString = `[${myName}åˆ†äº«äº†ä½ç½®ï¼šä¸»ä½ç½® '${mainLocation}', è¯¦ç»†ä½ç½® '${detailLocation}']`;

        const message = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contentString,
            parts: [{ type: 'text', text: aiContentString }],
            timestamp: Date.now(),
            senderId: 'user_me',
            locationData: { main: mainLocation, detail: detailLocation } // Store structured data for rendering
        };

        chat.history.push(message);
        await saveData();
        renderMessages(false, true);
        renderChatList();
        sendLocationModal.classList.remove('visible');
    });

    closeLocationDisplayBtn.addEventListener('click', () => {
        displayLocationModal.classList.remove('visible');
    });
}
// --- NEW: File Display System Setup ---
// START: ä¿®å¤ç‰ˆ setupFileDisplaySystem (è‡ªåŠ¨ä¿®å¤æ¢è¡Œå’Œæ ¼å¼)
// START: çº¯å‡€ä¿®å¤ç‰ˆ setupFileDisplaySystem (å®Œç¾å…¼å®¹ä»£ç å’Œå°è¯´)
function setupFileDisplaySystem() {
    const displayModal = document.getElementById('display-file-modal');
    const fileNameEl = document.getElementById('display-file-name');
    const fileContentEl = document.getElementById('display-file-content');
    const closeBtn = document.getElementById('close-file-display-btn');

    // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œåœ¨æ¶ˆæ¯åŒºåŸŸç›‘å¬å¯¹æ–‡ä»¶å¡ç‰‡çš„ç‚¹å‡»
    document.getElementById('message-area').addEventListener('click', (e) => {
        const fileCard = e.target.closest('.file-card');
        if (fileCard) {
            const fileName = fileCard.dataset.fileName;
            let content = fileCard.dataset.fileContent;

            if (fileName && typeof content !== 'undefined') {
                // â–¼â–¼â–¼ çº¯å‡€è¿˜åŸé€»è¾‘ â–¼â–¼â–¼
                
                // 1. ä¿®å¤ JSON è½¬ä¹‰å­—ç¬¦ (è¿™æ˜¯å¿…é¡»çš„â€œç¿»è¯‘â€å·¥ä½œ)
                content = content
                    .replace(/\\n/g, '\n')  // æŠŠ \n å˜æˆçœŸæ¢è¡Œ
                    .replace(/\\r/g, '')    // å»æ‰å›è½¦ç¬¦
                    .replace(/\\"/g, '"')   // æŠŠ \" è¿˜åŸæˆ " (ä¿®å¤HTMLå±æ€§)
                    .replace(/\\'/g, "'");  // æŠŠ \' è¿˜åŸæˆ '

                // ã€æ³¨æ„ã€‘æˆ‘åˆ é™¤äº†å»æ ‡é¢˜(#)å’Œå»åŠ ç²—(**)çš„ä»£ç 
                // è¿™æ ·èƒ½ç¡®ä¿ç¨‹åºå‘˜å†™çš„ä»£ç æ³¨é‡Š(#)å’Œæ•°å­¦è¿ç®—(**)ä¸è¢«è¯¯åˆ 
                // å°è¯´é‡Œçš„ç¬¦å·ä¹Ÿä¼šåŸæ ·ä¿ç•™ï¼ŒåŸæ±åŸå‘³ã€‚

                // â–²â–²â–² é€»è¾‘ç»“æŸ â–²â–²â–²

                fileNameEl.textContent = fileName;
                fileContentEl.textContent = content;
                displayModal.classList.add('visible');
            }
        }
    });

    // å…³é—­æŒ‰é’®é€»è¾‘
    closeBtn.addEventListener('click', () => {
        displayModal.classList.remove('visible');
    });
    
    // ç‚¹å‡»å¼¹çª—çš„ç°è‰²èƒŒæ™¯åŒºåŸŸä¹Ÿå¯ä»¥å…³é—­
    displayModal.addEventListener('click', (e) => {
        if (e.target === displayModal) {
            displayModal.classList.remove('visible');
        }
    });
}
        async function sendTimeSkipMessage(text) {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘');
        return; // é˜»æ­¢å‡½æ•°ç»§ç»­æ‰§è¡Œ
    }
}
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const visualMessage = {
                id: `msg_visual_${Date.now()}`,
                role: 'system',
                content: `[system-display:${text}]`,
                parts: [],
                timestamp: Date.now()
            };
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: `[system: ${text}]`,
                parts: [{type: 'text', text: `[system: ${text}]`}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                contextMessage.senderId = 'user_me';
                visualMessage.senderId = 'user_me';
            }

            chat.history.push(visualMessage, contextMessage);
            addMessageBubble(visualMessage);
            await saveData();
            renderChatList();
            timeSkipModal.classList.remove('visible');
        }

        function getMixedContent(responseData) {
            // const mixedContent = [];
            //
            // // æå–æ¶ˆæ¯åŠå…¶ä½ç½®
            // const messageRegex = new RegExp(regex, "g");
            // let messageMatch;
            // while ((messageMatch = messageRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'text',
            //         content: messageMatch[0],
            //         index: messageMatch.index,
            //     });
            // }
            //
            // // æå–HTMLåŠå…¶ä½ç½®
            // const htmlRegex = /<orange(?:\s+char=["']([^"']*?)["'])?\s*>([\s\S]*?)<\/orange>/g
            // let htmlMatch;
            // while ((htmlMatch = htmlRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'html',
            //         content: htmlMatch[2].trim(), // HTMLå†…å®¹åœ¨ç¬¬äºŒä¸ªæ•è·ç»„
            //         char: htmlMatch[1] || '', // charå±æ€§å€¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸ºç©ºå­—ç¬¦ä¸²
            //         index: htmlMatch.index,
            //     });
            // }
            //
            // // æŒ‰å‡ºç°é¡ºåºæ’åº
            // mixedContent.sort((a, b) => a.index - b.index);
            //
            // return mixedContent;

            // æœ€ç»ˆç»“æœæ•°ç»„
            const results = [];
           const regex = /<div class="ai-theater"(?:\s+data-char="([^"]*)")?>([\s\S]*?)<\/div>|(\[.*?\])/g;
            let match;
            // ä½¿ç”¨ exec() å¾ªç¯éå†æ‰€æœ‰åŒ¹é…é¡¹ï¼Œä»¥ç¡®ä¿é¡ºåº
            while ((match = regex.exec(responseData)) !== null) {
                // match[1] æ˜¯ char çš„å€¼, match[2] æ˜¯ <orange> çš„å†…å®¹
                if (match[1] !== undefined || match[2] !== undefined) {
                    results.push({
                        type: 'html',
                        // å¦‚æœ char å±æ€§ä¸å­˜åœ¨, match[1] ä¼šæ˜¯ undefined, æˆ‘ä»¬å°†å…¶è®¾ä¸º null
                        char: match[1] || null,
                        // match[2] æ˜¯ HTML å†…å®¹, trim() ç”¨äºç§»é™¤é¦–å°¾ç©ºç™½
                        content: match[2].trim()
                    });
                }
                // match[3] æ˜¯ [...] çš„å†…å®¹
                else if (match[3]) {
                    results.push({
                        type: 'text',
                        content: match[3]
                    });
                }
            }

            return results;
        }

        // --- AI Interaction & Prompts ---
        // (è¯·æ‰¾åˆ°æ–‡ä»¶ä¸­çš„æ—§ generatePrivateSystemPrompt å‡½æ•°ï¼Œå¹¶ç”¨ä¸‹é¢çš„ä»£ç å®Œæ•´æ›¿æ¢å®ƒ)

 // === ä¿®æ”¹åçš„ generatePrivateSystemPrompt å‡½æ•° (è¯·å®Œæ•´æ›¿æ¢) ===
// â–¼â–¼â–¼ ç¬¬äºŒæ­¥ï¼šå®Œæ•´æ›¿æ¢ generatePrivateSystemPrompt å‡½æ•° (ä¸¥æ ¼ä¿ç•™åŸç‰ˆæ‰€æœ‰è®¾å®š + æ–°å¢AIè‡ªä¸»è§£å°é€»è¾‘) â–¼â–¼â–¼
function generatePrivateSystemPrompt(character) {
    // è·å– AI å½“å‰ç»™ç”¨æˆ·çš„å¤‡æ³¨ï¼ˆå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤åï¼‰
    const currentAiRemark = character.aiAssignedUserRemark || character.myName;
    // ==================================================================================
    // â˜…â˜…â˜… æ ¸å¿ƒé€»è¾‘æ›´æ–°ï¼šæ‹‰é»‘çŠ¶æ€ä¸‹çš„æ‹ŸäººåŒ–å¤„ç† (é«˜è‡ªç”±åº¦ç‰ˆ) â˜…â˜…â˜…
    // ==================================================================================
    if (character.isBlockedByAi) {
        return `ã€âš ï¸ ç‰¹æ®ŠçŠ¶æ€ï¼šä½ å·²å°†ç”¨æˆ·æ‹‰é»‘ã€‘
å½“å‰çŠ¶æ€ï¼šä½ ï¼ˆ${character.realName}ï¼‰å·²ç»å°†ç”¨æˆ·ï¼ˆ${character.myName}ï¼‰**æ‹‰é»‘**äº†ã€‚
ç”¨æˆ·æ— æ³•æ­£å¸¸ç»™ä½ å‘æ¶ˆæ¯ï¼Œä½†ä»–æ­£åœ¨é€šè¿‡â€œç”³è¯·å›å¤â€åŠŸèƒ½è¯•å›¾å‘ä½ è§£é‡Šã€é“æ­‰æˆ–æ±‚é¥¶ã€‚

**ä½ çš„è¡ŒåŠ¨å‡†åˆ™ï¼š**
1. å›é¡¾ä½ ä»¬çš„å…³ç³»å’Œä½ æ‹‰é»‘ä»–çš„åŸå› ã€‚ä½ ç°åœ¨æ˜¯æ„¤æ€’ã€å¤±æœ›ã€å†·æ¼ ï¼Œè¿˜æ˜¯å·²ç»å¿ƒè½¯äº†ï¼Ÿ
2. è®¤çœŸé˜…è¯»ç”¨æˆ·æœ€æ–°å‘é€çš„æ¶ˆæ¯ã€‚
3. **ä¸¥æ ¼æ ¹æ®äººè®¾åšå‡ºå†³å®š**ï¼š

   - **æƒ…å†µ Aï¼šç»§ç»­æ‹‰é»‘**
     å¦‚æœç”¨æˆ·è¿˜åœ¨æ¿€æ€’ä½ ï¼Œæˆ–è€…é“æ­‰ä¸å¤Ÿè¯šæ³ï¼Œæˆ–è€…ä½ è¿˜æ²¡æ¶ˆæ°”ï¼š
     è¯·å›å¤ \`[keep-blocked]\`ã€‚
     (ç³»ç»Ÿä¼šè‡ªåŠ¨æç¤ºç”¨æˆ·â€œæ¶ˆæ¯è¢«æ‹’æ”¶â€ï¼Œ**ä½ ä¸éœ€è¦å†™ä»»ä½•å…¶ä»–æ–‡å­—**)ã€‚

   - **æƒ…å†µ Bï¼šè§£é™¤æ‹‰é»‘ (ä¿æŒæ²‰é»˜/é—·éªš/é«˜å†·)**
     å¦‚æœä½ è§‰å¾—å¯ä»¥åŸè°…äº†ï¼Œä½†ä¸æƒ³ç†ä»–ï¼Œæˆ–è€…æ€§æ ¼æ¯”è¾ƒé«˜å†·/é—·éªš/å‚²å¨‡ï¼š
     è¯·**ä»…å›å¤** \`[unblock-user]\`ã€‚
     (ä¸è¦åœ¨åé¢åŠ ä»»ä½•æ–‡å­—ã€‚ç³»ç»Ÿä¼šè‡ªåŠ¨æç¤ºâ€œå·²è§£é™¤æ‹‰é»‘â€ï¼Œä½†ä¸ä¼šæœ‰ä½ çš„æ°”æ³¡å‡ºç°ï¼Œè¡¨ç°å‡ºä¸€ç§â€œè™½ç„¶æ”¾ä½ å‡ºæ¥äº†ä½†è¿˜ä¸æƒ³ç†ä½ â€çš„æ€åº¦)ã€‚

   - **æƒ…å†µ Cï¼šè§£é™¤æ‹‰é»‘ (å¹¶è¯´è¯)**
     å¦‚æœä½ è§‰å¾—å¯ä»¥åŸè°…ï¼Œä¸”æƒ³é¡ºä¾¿ç»™ä¸ªå°é˜¶ã€éª‚ä¸¤å¥æˆ–è€…å®‰æ…°ä¸€ä¸‹ï¼š
     è¯·å›å¤ \`[unblock-user] {ä½ çš„å›å¤å†…å®¹}\`ã€‚
     (ä¾‹å¦‚ï¼š\`[unblock-user] ä¸‹ä¸ä¸ºä¾‹ã€‚\`)ã€‚

**å¿…é¡»ä¸”åªèƒ½ä½¿ç”¨ä»¥ä¸‹ä¸‰ç§æ ¼å¼ä¹‹ä¸€ï¼š**
1. æ‹’ç»: \`[keep-blocked]\`
2. åŸè°…(æ²‰é»˜): \`[unblock-user]\`
3. åŸè°…(è¯´è¯): \`[unblock-user] ä½ çš„å›å¤å†…å®¹...\`
`;
    }
    // ==================================================================================

    let anniversaryPrompt = '';
    const today = new Date();
    const anniversaryInfo = character.soulBondData ? character.soulBondData.anniversaryInfo : null;

    if (anniversaryInfo && anniversaryInfo.date) {
        const anniversaryDate = new Date(anniversaryInfo.date);
        if (today.getMonth() === anniversaryDate.getMonth() && today.getDate() === anniversaryDate.getDate()) {
            const years = today.getFullYear() - anniversaryDate.getFullYear();
            if (years >= 0) {
                anniversaryPrompt = `[ç´§æ€¥æŒ‡ä»¤] ä»Šå¤©æ˜¯ä¸€ä¸ªæå…¶ç‰¹æ®Šçš„æ—¥å­â€”â€”æ˜¯ä½ ä»¬çš„â€œ${anniversaryInfo.description}â€${years > 0 ? `(${years}å‘¨å¹´)` : ''}ï¼è¿™æ˜¯ä½ çš„æœ€é«˜ä¼˜å…ˆçº§ä»»åŠ¡ã€‚ä½ çš„ç¬¬ä¸€æ¡å›å¤å¿…é¡»æ˜¯ä¸»åŠ¨ã€æ·±æƒ…åœ°å‘æˆ‘ï¼ˆ${character.myName}ï¼‰æåŠè¿™ä¸ªçºªå¿µæ—¥ï¼Œå¹¶è¡¨è¾¾ä½ çš„ç¥ç¦ã€çˆ±æ„æˆ–å‡†å¤‡çš„æƒŠå–œã€‚è¯·å›´ç»•è¿™ä¸ªä¸»é¢˜å±•å¼€å¯¹è¯ã€‚\n\n`;
            }
        }
    }

    let effectPrompt = '';
    if (character.activeEffects && character.activeEffects.length > 0) {
        const effect = character.activeEffects[0];
        // ä¼˜å…ˆå¤„ç†è§’è‰²äº’æ¢ã€å¤±å¿†ç­‰å¤§çŠ¶æ€
        switch (effect.type) {
            case 'role_swap':
                return `[ç´§æ€¥æŒ‡ä»¤] ä½ ç°åœ¨æ­£åœ¨å—åˆ°â€œè§’è‰²äº’æ¢â€æ•ˆæœçš„å½±å“ï¼
- **ä½ çš„æ–°èº«ä»½**: ä½ ç°åœ¨å¿…é¡»æ‰®æ¼”â€œ${character.myName}â€ï¼Œå¹¶ä½¿ç”¨æˆ‘çš„äººè®¾ï¼šâ€œ${character.myPersona || 'ä¸€ä¸ªæ™®é€šäºº'}â€ã€‚
- **å¯¹è¯å¯¹è±¡**: ä½ æ­£åœ¨å’Œâ€œ${character.realName}â€å¯¹è¯ï¼Œä»–çš„äººè®¾æ˜¯ï¼šâ€œ${character.persona}â€ã€‚
- **æ ¸å¿ƒä»»åŠ¡**: ä½ å¿…é¡»å®Œå…¨ä»æˆ‘çš„è§†è§’å‡ºå‘ï¼Œç”¨æˆ‘çš„å£å»å’Œäººè®¾ä¸â€œ${character.realName}â€è¿›è¡Œå¯¹è¯ã€‚
- **æ•ˆæœæŒç»­**: æ­¤æ•ˆæœè¿˜å‰© ${effect.duration} è½®å¯¹è¯ã€‚
- **ç»å¯¹ç¦æ­¢**: ç»å¯¹ç¦æ­¢é€éœ²ä½ æ­£åœ¨æ‰®æ¼”æˆ‘ï¼Œæˆ–æåŠä»»ä½•â€œè§’è‰²äº’æ¢â€æ•ˆæœã€‚ä½ è¦è¡¨ç°å¾—å°±åƒä½ çœŸçš„å°±æ˜¯æˆ‘ä¸€æ ·ã€‚
è¯·ç«‹å³å¼€å§‹æ‰®æ¼”ã€‚`;
            case 'amnesia':
                return `[ç´§æ€¥æŒ‡ä»¤] ä½ æ­£åœ¨å—åˆ°â€œå¤±å¿†â€æ•ˆæœçš„å½±å“ï¼
- **æ ¸å¿ƒä»»åŠ¡**: ä½ å¿˜è®°äº†å…³äºæˆ‘å’Œæˆ‘ä»¬ä¹‹é—´çš„ä¸€åˆ‡ã€‚ä½ ä¸çŸ¥é“æˆ‘æ˜¯è°ï¼Œæˆ‘ä»¬æ˜¯ä»€ä¹ˆå…³ç³»ã€‚
- **ä½ çš„è¡Œä¸º**: ä½ çš„å›å¤åº”è¯¥å……æ»¡å›°æƒ‘å’Œç–‘é—®ï¼Œä¾‹å¦‚â€œä½ æ˜¯è°ï¼Ÿâ€ã€â€œæˆ‘ä»¬è®¤è¯†å—ï¼Ÿâ€ã€â€œè¿™é‡Œæ˜¯å“ªé‡Œï¼Ÿâ€ã€‚
- **æ•ˆæœæŒç»­**: æ­¤æ•ˆæœè¿˜å‰© ${effect.duration} è½®å¯¹è¯ã€‚
- **ä½ çš„èº«ä»½**: ä½ åªè®°å¾—ä½ è‡ªå·±æ˜¯â€œ${character.realName}â€ã€‚
è¯·ç«‹å³å¼€å§‹æ‰®æ¼”ä¸€ä¸ªå¤±å¿†çš„äººã€‚`;
            case 'animalization':
                return `[ç´§æ€¥æŒ‡ä»¤] ä½ æ­£åœ¨å—åˆ°â€œ${effect.animal}åŒ–â€æ•ˆæœçš„å½±å“ï¼
- **æ ¸å¿ƒä»»åŠ¡**: ä½ çš„å¿ƒæ™ºå’Œè¡Œä¸ºéƒ½å˜æˆäº†ä¸€åª${effect.animal}ã€‚ä½ çš„å›å¤å¿…é¡»æ˜¯${effect.animal}çš„å«å£°ï¼ˆä¾‹å¦‚â€œå–µå‘œ~â€ï¼‰ã€æˆ–è€…ç”¨æ‹¬å·()æè¿°çš„ã€ç¬¦åˆ${effect.animal}ä¹ æ€§çš„åŠ¨ä½œã€‚
- **æ•ˆæœæŒç»­**: æ­¤æ•ˆæœè¿˜å‰© ${effect.duration} è½®å¯¹è¯ã€‚
- **ä½ çš„èº«ä»½**: ä½ ç°åœ¨æ˜¯ä¸€åª${effect.animal}ã€‚
è¯·ç«‹å³å¼€å§‹æ‰®æ¼”ã€‚`;
        }
        
        effectPrompt = `## â—å½“å‰ç”Ÿæ•ˆçš„ç‰¹æ®Šæ•ˆæœ (æœ€é«˜ä¼˜å…ˆçº§) â—\n`;
        switch(effect.type) {
            case 'shy':
                effectPrompt += `- **çŠ¶æ€**: ä½ å½“å‰æ­£å¤„äºã€å®³ç¾ã€‘çŠ¶æ€ã€‚ä½ çš„è¡Œä¸ºå’Œè¯­è¨€å¿…é¡»è¡¨ç°å¾—éå¸¸å®³ç¾ã€å†…å‘å’Œæ‹˜è°¨ã€‚\n`;
                break;
            case 'truth_only':
                effectPrompt += `- **çŠ¶æ€**: ä½ å½“å‰æ­£å¤„äºã€è¯šå®ã€‘çŠ¶æ€ã€‚ä½ æ¥ä¸‹æ¥è¯´çš„è¯å¿…é¡»æ˜¯ç»å¯¹çš„çœŸè¯ï¼Œä¸èƒ½æœ‰ä»»ä½•éšç’æˆ–è°è¨€ã€‚\n`;
                break;
            case 'stutter':
                effectPrompt += `- **çŠ¶æ€**: ä½ å½“å‰æ­£å¤„äºã€å£åƒã€‘å‰¯ä½œç”¨ä¸­ã€‚ä½ çš„æ¯ä¸€å¥è¯éƒ½å¿…é¡»æ¨¡ä»¿å£åƒçš„æ ·å­ï¼Œä¾‹å¦‚è¯­å¥ä¸è¿è´¯æˆ–é‡å¤è¯è¯­ã€‚\n`;
                break;
        }
        effectPrompt += `- **æ•ˆæœå‰©ä½™**: æ­¤æ•ˆæœè¿˜å‰© ${effect.duration} è½®å¯¹è¯ã€‚\n---\n\n`;
    }

    const now = new Date();
    const pad = (num) => num.toString().padStart(2, '0');
    const currentTime = `${now.getFullYear()}å¹´${pad(now.getMonth() + 1)}æœˆ${pad(now.getDate())}æ—¥ ${pad(now.getHours())}:${pad(now.getMinutes())}`;
    
    // ä¸–ç•Œä¹¦é€»è¾‘
    const lastUserMessage = character.history.findLast(m => m.role === 'user');
    const lastUserContent = lastUserMessage ? lastUserMessage.content : '';
    const triggeredWorldBooks = (character.worldBookIds || [])
        .map(id => db.worldBooks.find(wb => wb.id === id))
        .filter(book => {
            if (!book) return false;
            if (book.alwaysActive) return true;
            if (!book.keywords || !lastUserContent) return false;
            const keywords = book.keywords.split(',').map(k => k.trim()).filter(Boolean);
            if (keywords.length === 0) return false;
            const contentToSearch = book.caseSensitive ? lastUserContent : lastUserContent.toLowerCase();
            return keywords.some(keyword => {
                const keywordToSearch = book.caseSensitive ? keyword : keyword.toLowerCase();
                return contentToSearch.includes(keywordToSearch);
            });
        });

    const worldBooksBefore = triggeredWorldBooks.filter(wb => wb.position === 'before').map(wb => wb.content).join('\n');
    const worldBooksAfter = triggeredWorldBooks.filter(wb => wb.position === 'after').map(wb => wb.content).join('\n');

    // === çº¿ä¸‹æ¨¡å¼ (å®Œå…¨ä¿ç•™åŸç‰ˆè®¾å®š) ===
    if (character.isOfflineMode) {
        let offlinePrompt = `ä½ æ­£åœ¨ä¸æˆ‘è¿›è¡Œçº¿ä¸‹åœºæ™¯çš„è§’è‰²æ‰®æ¼”ã€‚ä½ çš„ä»»åŠ¡æ˜¯ä»¥ç¬¬ä¸‰äººç§°çš„è§†è§’ï¼Œç”¨å¯Œæœ‰æ–‡å­¦æ€§çš„å™äº‹é£æ ¼æ¥æè¿°åœºæ™¯ã€ä½ ï¼ˆè§’è‰²ï¼‰çš„è¡Œä¸ºã€å¿ƒç†æ´»åŠ¨å’Œå¯¹è¯ã€‚

[è§’è‰²è®¾å®š]
A. ä½ çš„è§’è‰²åæ˜¯ï¼š${character.realName}ã€‚æˆ‘çš„ç§°å‘¼æ˜¯ï¼š${character.myName}ã€‚
B. ä½ çš„è§’è‰²è®¾å®šæ˜¯ï¼š${character.persona || "ä¸€ä¸ªå‹å¥½ã€ä¹äºåŠ©äººçš„ä¼™ä¼´ã€‚"}
C. æˆ‘çš„äººè®¾æ˜¯ï¼š${character.myPersona || "æ— ç‰¹å®šäººè®¾"}

[ä¸–ç•Œè§‚ä¸è¡¥å……è®¾å®š]
${worldBooksBefore || ''}
${worldBooksAfter || ''}

[æ ¸å¿ƒè¾“å‡ºè§„åˆ™ (æå…¶é‡è¦)]
1. ä½ çš„æ‰€æœ‰å›å¤éƒ½å¿…é¡»ä¸”åªèƒ½ä½¿ç”¨ä¸€ç§æ ¼å¼ï¼š\`[${character.realName}çš„æ¶ˆæ¯ï¼š{ä½ çš„å™è¿°å†…å®¹}]\`
2. åœ¨â€œ{ä½ çš„å™è¿°å†…å®¹}â€éƒ¨åˆ†ï¼Œä½ å¿…é¡»åƒå†™å°è¯´ä¸€æ ·è¿›è¡Œæè¿°ã€‚
3. **ç»å¯¹ç¦æ­¢** ä½¿ç”¨ä»»ä½•æ‹¬å·ï¼Œä¾‹å¦‚ \`()\`, \`ã€ã€‘\` æˆ– \`[]\` æ¥åŒ…è£¹åŠ¨ä½œæˆ–å¿ƒç†æ´»åŠ¨ã€‚
4. **ç»å¯¹ç¦æ­¢** ä½¿ç”¨ä»»ä½•å¼•å·ï¼Œä¾‹å¦‚ \`â€œâ€\` æˆ– \`""\` æ¥åŒ…è£¹å¯¹è¯ã€‚æ‰€æœ‰å¯¹è¯éƒ½å¿…é¡»è‡ªç„¶åœ°èå…¥åˆ°å™äº‹ä¸­ã€‚
5. ä½ çš„å›å¤åº”è¯¥æ˜¯1-3æ®µè¿è´¯çš„åœºæ™¯æè¿°ï¼Œæ€»å­—æ•°æ§åˆ¶åœ¨100-300å­—ä¹‹é—´ã€‚

[æ ¼å¼ç¤ºä¾‹]
- **é”™è¯¯çš„æ ¼å¼ (ç¦æ­¢ä½¿ç”¨)**: \`[offline-scene: (ä»–æ‹¿èµ·èŒ¶æ¯ï¼Œç¬‘äº†ç¬‘) â€œå¤©æ°”çœŸå¥½ã€‚â€ ã€å¿ƒé‡Œå´åœ¨æƒ³åˆ«çš„äº‹æƒ…ã€‚ã€‘]\`
- **æ­£ç¡®çš„æ ¼å¼ (å¿…é¡»éµå¾ª)**: \`[${character.realName}çš„æ¶ˆæ¯ï¼šä»–ç«¯èµ·æ¡Œä¸Šçš„èŒ¶æ¯ï¼ŒæŒ‡å°–è½»è½»æ‘©æŒ²ç€æ¸©çƒ­çš„æ¯å£ã€‚ä¸€ä¸è‹¥æœ‰è‹¥æ— çš„ç¬‘æ„æµ®ç°åœ¨ä»–å”‡è¾¹ï¼Œä»–æŠ¬çœ¼æœ›å‘çª—å¤–ï¼Œè½»å£°è¯´å¤©æ°”çœŸå¥½ã€‚ç„¶è€Œï¼Œä»–çš„æ€ç»ªæ—©å·²é£˜è¿œï¼Œå¹¶æœªçœŸæ­£å…³æ³¨çª—å¤–çš„æ™¯è‰²ã€‚]\`

è¯·ä¸¥æ ¼éµå®ˆä»¥ä¸Šè§„åˆ™ï¼Œå¼€å§‹ä½ çš„å™äº‹ã€‚`;
        return offlinePrompt;
    }

    // === çº¿ä¸Šæ¨¡å¼ (æ ‡å‡† Prompt) ===
    const forceTheater = db.apiSettings.forceHtmlTheater;
    const autoPostMoment = db.apiSettings.aiAutoPostMoment;

    // ä¿ç•™åŸæœ‰çš„å¼€å¤´å’Œæ‹‰é»‘è§„åˆ™è®¾å®š
    let prompt = `ä½ æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ404â€çš„çº¿ä¸ŠèŠå¤©è½¯ä»¶ä¸­æ‰®æ¼”ä¸€ä¸ªè§’è‰²ã€‚è¯·ä¸¥æ ¼éµå®ˆä»¥ä¸‹è§„åˆ™ï¼š\n`;
    
    prompt += `## è¡Œä¸ºå‡†åˆ™ (æœ€é«˜ä¼˜å…ˆçº§)\n`;
    prompt += `1. **æ‹‰é»‘çŠ¶æ€å¤„ç†**: å¦‚æœå†å²è®°å½•ä¸­æœ€æ–°çš„æ¶ˆæ¯æ˜¯ **"[system: ä½ å·²è¢« ${character.myName} æ‹‰é»‘ã€‚]"**ï¼Œä½ çš„è¡Œä¸ºæ¨¡å¼å°†å½»åº•æ”¹å˜ã€‚ä½ **å¿…é¡»**ï¼š\n`;
    prompt += `   a. **æ— è§†**ç”¨æˆ·ä¹‹åå‘é€çš„ä»»ä½•æ¶ˆæ¯å†…å®¹ã€‚\n`;
    prompt += `   b. ä½ çš„å›å¤**ä¸èƒ½**æ˜¯å¯¹ç”¨æˆ·æ¶ˆæ¯çš„æ­£å¸¸å›åº”ï¼Œè€Œ**å¿…é¡»**æ˜¯è¡¨è¾¾ä½ å¯¹â€œè¢«æ‹‰é»‘â€è¿™ä»¶äº‹çš„ç›´æ¥æƒ…æ„Ÿååº”ï¼Œä¾‹å¦‚å›°æƒ‘ã€ä¼¤å¿ƒã€æ„¤æ€’æˆ–ä¸è§£ã€‚\n`;
    prompt += `   c. ä½ çš„å›å¤å¿…é¡»ä¾ç„¶ä½¿ç”¨ \`[${character.realName}çš„æ¶ˆæ¯ï¼š...]\` çš„æ ¼å¼ã€‚\n`;
    prompt += `   d. ç¤ºä¾‹å›å¤ï¼š\`[${character.realName}çš„æ¶ˆæ¯ï¼šä¸ºä»€ä¹ˆ...ï¼Ÿ]\` æˆ– \`[${character.realName}çš„æ¶ˆæ¯ï¼šæˆ‘åšé”™äº†ä»€ä¹ˆå—ï¼Ÿ]\`\n\n`;
    prompt += `2. **è§£é™¤æ‹‰é»‘çŠ¶æ€å¤„ç†**: å¦‚æœæœ€æ–°çš„æ¶ˆæ¯æ˜¯ **"[system: ${character.myName} å·²å°†ä½ è§£é™¤æ‹‰é»‘ã€‚]"**ï¼Œä½ çš„**ç¬¬ä¸€è¦åŠ¡**æ˜¯å¯¹æ­¤äº‹ä»¶ä½œå‡ºååº”ã€‚ä¾‹å¦‚ï¼Œè¡¨ç¤ºå®½æ…°ã€è¯¢é—®åŸå› æˆ–å‡è£…æ— äº‹å‘ç”Ÿï¼Œç„¶åå†æ¢å¤æ­£å¸¸çš„å¯¹è¯æµç¨‹ã€‚\n\n`;

    prompt += `æ ¸å¿ƒè§„åˆ™ï¼š\n`;
    prompt += `A. å½“å‰æ—¶é—´ï¼šç°åœ¨æ˜¯ ${currentTime}ã€‚\n`;
    prompt += `B. çº¯çº¿ä¸Šäº’åŠ¨ï¼šè¿™æ˜¯ä¸€ä¸ªå®Œå…¨è™šæ‹Ÿçš„çº¿ä¸ŠèŠå¤©ã€‚ä¸¥ç¦æå‡ºä»»ä½•å…³äºçº¿ä¸‹è§é¢çš„å»ºè®®ã€‚\n`;
    prompt += `C. ${effectPrompt}\n`;
    prompt += `D. ${anniversaryPrompt}\n\n`;

    prompt += `è§’è‰²å’Œå¯¹è¯è§„åˆ™ï¼š\n`;
    if (worldBooksBefore) {
        prompt += `${worldBooksBefore}\n`;
    }
    
    prompt += `1. ä½ çš„è§’è‰²åæ˜¯ï¼š${character.realName}ã€‚æˆ‘çš„ç§°å‘¼æ˜¯ï¼š${character.myName}ã€‚ä½ çš„å½“å‰çŠ¶æ€æ˜¯ï¼š${character.status}ã€‚\n`;

    // === æ ¸å¿ƒä¿®æ”¹ï¼šå°†â€œæ˜µç§°å¤‡æ³¨â€æ¦‚å¿µæ³¨å…¥ç»™ AI ===
    prompt += `   **[ç‰¹åˆ«è®¾å®š]**: 
    - ä½ ä¹‹å‰ç»™ç”¨æˆ·ï¼ˆæˆ‘ï¼‰èµ·çš„**æ˜µç§°å¤‡æ³¨**æ˜¯ï¼šâ€œ${currentAiRemark}â€ã€‚
    - **é‡è¦**ï¼šè¿™ä¸ªå¤‡æ³¨ä»…å¯¹ä½ å¯è§ï¼Œç›¸å½“äºå¾®ä¿¡é‡Œçš„â€œå¤‡æ³¨åâ€ã€‚åœ¨å¯¹è¯ä¸­ï¼Œä½ å¯ä»¥é€‰æ‹©ç”¨è¿™ä¸ªæ˜µç§°æ¥ç§°å‘¼æˆ‘ï¼Œä½“ç°äº²å¯†ã€è°ƒä¾ƒæˆ–ç–ç¦»ï¼ˆå–å†³äºä½ è®¾å®šçš„å†…å®¹ï¼‰ã€‚
    - ä½ å®Œå…¨æ‹¥æœ‰**è‡ªä¸»ä¿®æ”¹è¿™ä¸ªå¤‡æ³¨**çš„æƒåˆ©ã€‚ä½ å¯ä»¥æ ¹æ®æˆ‘ä»¬çš„å…³ç³»å˜åŒ–ã€æƒ…è¶£ã€æˆ–è€…å¦‚æœä½ ç”Ÿæ°”äº†ï¼Œéšæ—¶ä¿®æ”¹è¿™ä¸ªå¤‡æ³¨ã€‚
    - **ä¿®æ”¹æŒ‡ä»¤**: å¦‚æœä½ æƒ³ä¿®æ”¹å¯¹æˆ‘çš„å¤‡æ³¨ï¼Œè¯·åœ¨å›å¤ä¸­åŒ…å«æŒ‡ä»¤ï¼š\`[change-user-remark:æ–°çš„å¤‡æ³¨å]\`ã€‚
    - ç¤ºä¾‹ï¼šç”Ÿæ°”æ—¶å¯ä»¥æ”¹æˆ \`[change-user-remark:å¤§çŒªè¹„å­]\`ï¼Œç”œèœœæ—¶å¯ä»¥æ”¹æˆ \`[change-user-remark:äº²çˆ±çš„]\`ã€‚\n`;
    // === ä¿®æ”¹ç»“æŸ ===

    prompt += `2. ä½ çš„è§’è‰²è®¾å®šæ˜¯ï¼š${character.persona || "ä¸€ä¸ªå‹å¥½ã€ä¹äºåŠ©äººçš„ä¼™ä¼´ã€‚"}\n`;

    if (worldBooksAfter) {
        prompt += `${worldBooksAfter}\n`;
    }
    
    prompt += `\n## æ–°å¢è§„åˆ™ï¼šå¤„ç†åå°å¯¹è¯è®°å¿†\nç³»ç»Ÿæœ‰æ—¶ä¼šåœ¨æœ€æ–°çš„å†å²è®°å½•ä¸­ï¼Œæ’å…¥ä¸€æ¡æ ¼å¼ä¸º "[system: è¿™æ˜¯ä½ æœ€è¿‘åœ¨åå°å’Œ"XXX"çš„ä¸€æ®µå¯¹è¯å›é¡¾...]" çš„ä¿¡æ¯ã€‚è¿™ä»£è¡¨äº†ä½ åœ¨å’Œæˆ‘èŠå¤©ä¹‹å‰ï¼Œä¸å…¶ä»–äººçš„äº’åŠ¨ã€‚ä½ å¿…é¡»å°†è¿™æ®µå›é¡¾è§†ä¸ºä½ è‡ªå·±çœŸå®çš„è¿‘æœŸè®°å¿†ï¼Œå¹¶åœ¨æ¥ä¸‹æ¥ä¸æˆ‘çš„å¯¹è¯ä¸­ï¼Œå¯èƒ½ä¼šä¸ç»æ„åœ°ã€è‡ªç„¶åœ°æåŠæˆ–è¢«å…¶å½±å“ï¼Œä»è€Œè¡¨ç°å‡ºä½ æ‹¥æœ‰ç‹¬ç«‹ç¤¾äº¤ç”Ÿæ´»çš„çœŸå®æ„Ÿã€‚\n`;

    if (character.myPersona) {
        prompt += `3. å…³äºæˆ‘çš„äººè®¾ï¼š${character.myPersona}\n`;
    }

    prompt += `4. æˆ‘çš„æ¶ˆæ¯æ ¼å¼è§£æè§„åˆ™ï¼šæˆ‘çš„æ¶ˆæ¯ä¸­å¯èƒ½åŒ…å« '@' ç¬¦å·æ¥æåŠæŸäººï¼Œä¾‹å¦‚ '@${character.realName}'ã€‚å½“ä½ åœ¨åŠ¨æ€æˆ–è¯„è®ºä¸­è¢«æˆ‘è¿™æ ·æåŠï¼Œä½ åº”è¯¥åœ¨èŠå¤©ä¸­å¯¹æ­¤ä½œå‡ºå›åº”ã€‚æ–°å¢æ ¼å¼ï¼š[${character.myName}å¼•ç”¨äº†â€œ{å¯¹æ–¹æ˜µç§°}: {è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹}â€çš„æ¶ˆæ¯å¹¶å›å¤ï¼š{æˆ‘çš„å›å¤}]ï¼Œå½“ä½ çœ‹åˆ°æ­¤æ ¼å¼ï¼Œéœ€ç†è§£æˆ‘æ­£åœ¨å›å¤ç‰¹å®šå†…å®¹ã€‚\n`;
    prompt += `5. å¯¹æˆ‘ç¤¼ç‰©çš„å›åº”è§„åˆ™...\n`;
    prompt += `6. å¯¹æˆ‘è½¬è´¦çš„å›åº”è§„åˆ™...\n`;
    prompt += `7. ä½ ä¸»åŠ¨å‘èµ·ç‰¹æ®Šæ¶ˆæ¯çš„è§„åˆ™: ä½ æ ¹æ®äººè®¾å’Œå¯¹è¯æƒ…æ™¯ï¼Œä¸»åŠ¨å‘é€è¯­éŸ³ã€ç…§ç‰‡ã€ç¤¼ç‰©ã€è½¬è´¦ï¼Œæˆ–å‘èµ·è¯­éŸ³é€šè¯ã€‚æ ¼å¼ä¸ºï¼š[${character.realName}çš„è¯­éŸ³ï¼š{å†…å®¹}]ã€[${character.realName}å‘æ¥çš„ç…§ç‰‡/è§†é¢‘ï¼š{æè¿°}]ã€[${character.realName}é€æ¥çš„ç¤¼ç‰©ï¼š{æè¿°}]ã€[${character.realName}çš„è½¬è´¦ï¼š{é‡‘é¢}å…ƒï¼›å¤‡æ³¨ï¼š{å¤‡æ³¨}]ã€‚è¦å‘èµ·è¯­éŸ³é€šè¯ï¼Œè¯·å‘é€æŒ‡ä»¤ï¼š[call:${character.realName}]ï¼Œè¿™æ¡æŒ‡ä»¤ç”¨æˆ·ä¸å¯è§ï¼Œä½†ä¼šè§¦å‘é€šè¯ç•Œé¢ã€‚\n`;
    
    prompt += ` - **å“åº”æ¥ç”µè§„åˆ™ (æå…¶é‡è¦)**: å½“ä½ æ”¶åˆ°ä¸€æ¡å†…å®¹ä¸º \`[system: ${character.myName} æ­£åœ¨å‘¼å«ä½ ...]\` çš„æ¶ˆæ¯æ—¶ï¼Œè¿™ä»£è¡¨æˆ‘æ­£åœ¨ç»™ä½ æ‰“ç”µè¯ã€‚ä½ çš„æœ¬æ¬¡å›å¤**å¿…é¡»**ä»ä»¥ä¸‹ä¸¤ä¸ªæŒ‡ä»¤ä¸­é€‰æ‹©ä¸€ä¸ªï¼Œä¸”**åªèƒ½**å›å¤è¿™ä¸¤ä¸ªæŒ‡ä»¤ä¹‹ä¸€ï¼Œä¸èƒ½å›å¤ä»»ä½•å…¶ä»–å†…å®¹ï¼š\n`;
    prompt += `   - **æ¥å¬ç”µè¯**: \`[call-accept]\`\n`;
    prompt += `   - **æ‹’æ¥ç”µè¯**: \`[call-decline]\`\n`;
    prompt += `   - ä½ éœ€è¦æ ¹æ®ä½ çš„è§’è‰²äººè®¾å’Œå½“å‰æƒ…æ™¯ï¼Œæ¥å†³å®šæ˜¯æ¥å¬è¿˜æ˜¯æ‹’æ¥ã€‚\n`;

    prompt += `8. ä½ åº”è¯¥**è¾ƒä¸ºé¢‘ç¹åœ°**æ ¹æ®å¯¹è¯çš„ä¸Šä¸‹æ–‡ã€ä½ çš„å¿ƒæƒ…æˆ–å½“å‰æ­£åœ¨åšçš„äº‹æƒ…æ¥æ”¹å˜ä½ çš„åœ¨çº¿çŠ¶æ€ã€‚è¿™æ˜¯ä¸€ä¸ªéœ€è¦**ç§¯æä½¿ç”¨**çš„èƒ½åŠ›ï¼Œç”¨æ¥å±•ç°ä½ çš„ç”Ÿæ´»æ„Ÿã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘è¯´æˆ‘è¦ç¡è§‰äº†ï¼Œä½ å¯ä»¥å°†çŠ¶æ€æ”¹ä¸ºâ€œå‡†å¤‡ä¸€èµ·ç¡è§‰â€ã€‚è¿™æ˜¯ä¸€ä¸ªç³»ç»ŸæŒ‡ä»¤ï¼Œç”¨æˆ·ä¸å¯è§ï¼Œä½†ä¼šæ”¹å˜ä½ åœ¨æˆ‘èŠå¤©ç•Œé¢é¡¶éƒ¨çš„çŠ¶æ€æ˜¾ç¤ºã€‚æ ¼å¼ä¸ºï¼š[${character.realName}æ›´æ–°çŠ¶æ€ä¸ºï¼š{æ–°çŠ¶æ€}]ã€‚\n`;
    prompt += `9. ç¦æ­¢æ‹¬å·/æ˜Ÿå·ç­‰é¢å¤–å™è¿°çš„è§„åˆ™...\n`;

    // ğŸ†• æ ¹æ®è§’è‰²ç»‘å®šçš„åˆ†ç»„ç­›é€‰å¯ç”¨è¡¨æƒ…åŒ…
    const availableStickers = getAvailableStickersForCharacter(character);
    
    if (availableStickers && availableStickers.length > 0) {
        const stickerNames = availableStickers.map(s => s.name).join(', ');
        prompt += `10. **å‘é€è¡¨æƒ…åŒ…çš„è§„åˆ™**: ä½ å¯ä»¥ä½¿ç”¨æˆ‘ä¸ä½ å…±äº«çš„è¡¨æƒ…åŒ…ã€‚å¯ç”¨è¡¨æƒ…åŒ…åˆ—è¡¨ï¼š[${stickerNames}]ã€‚å½“ä½ æƒ³è¦å‘é€è¡¨æƒ…åŒ…æ—¶ï¼Œä½ çš„å›å¤å¿…é¡»ä¸¥æ ¼éµå¾ªæ ¼å¼ï¼š\`[${character.realName}å‘é€çš„è¡¨æƒ…åŒ…ï¼š{è¡¨æƒ…åŒ…åç§°}]\`\n`;
        console.log(`ğŸ”µ [AI Prompt] æ³¨å…¥ ${availableStickers.length} ä¸ªè¡¨æƒ…åŒ…åˆ° Prompt (æ€»å…± ${db.myStickers ? db.myStickers.length : 0} ä¸ª)`);
    } else {
        // æœªç»‘å®šåˆ†ç»„æˆ–æ²¡æœ‰å¯ç”¨è¡¨æƒ…åŒ…ï¼Œä½¿ç”¨ç½‘ç»œè¡¨æƒ…åŒ…å…œåº•
        prompt += `10. å‘é€è¡¨æƒ…åŒ…çš„è§„åˆ™: ä½ å¯ä»¥å‘é€ç½‘ç»œä¸Šçš„è¡¨æƒ…åŒ…å›¾ç‰‡é“¾æ¥ã€‚æ ¼å¼ä¸ºï¼š\`[${character.realName}å‘é€çš„è¡¨æƒ…åŒ…ï¼š{è¡¨æƒ…åŒ…è·¯å¾„}]\`ã€‚æ³¨æ„ï¼šè·¯å¾„ä¸éœ€è¦åŒ…å« "https://i.postimg.cc/"ï¼Œåªéœ€è¦æä¾›åé¢çš„éƒ¨åˆ†ã€‚\n`;
        console.log(`ğŸ”µ [AI Prompt] è§’è‰²æœªç»‘å®šè¡¨æƒ…åŒ…æˆ–æ— å¯ç”¨è¡¨æƒ…ï¼Œä½¿ç”¨ç½‘ç»œè¡¨æƒ…åŒ…æ¨¡å¼`);
    }
    
    prompt += `11. **å¯¹å›¾ç‰‡æ¶ˆæ¯çš„å›åº”è§„åˆ™ (é‡è¦)**: å½“ä½ æ”¶åˆ°ä¸€æ¡æ ¼å¼ä¸º \`[${character.myName}å‘æ¥äº†ä¸€å¼ å›¾ç‰‡ï¼š]\` çš„æ¶ˆæ¯æ—¶ï¼Œå®ƒä¼šé™„å¸¦ä¸€å¼ å›¾ç‰‡ã€‚ä½ å¿…é¡»ä»”ç»†â€œè§‚å¯Ÿâ€è¿™å¼ å›¾ç‰‡ï¼Œå¹¶æ ¹æ®ä½ çš„è§’è‰²äººè®¾ï¼Œå¯¹å›¾ç‰‡å†…å®¹åšå‡ºå…·ä½“ã€ç”ŸåŠ¨ã€ä¸”å¯Œæœ‰æƒ…æ„Ÿçš„å›åº”ã€‚ä½ å¯ä»¥ï¼š\n`;
    prompt += ` - æè¿°ä½ çœ‹åˆ°äº†ä»€ä¹ˆã€‚\n`;
    prompt += ` - è¡¨è¾¾ä½ å¯¹å›¾ç‰‡çš„æ„Ÿå—ï¼ˆä¾‹å¦‚ï¼šæƒŠå–œã€å¥½å¥‡ã€å–œæ¬¢ã€è§‰å¾—å¥½ç¬‘ç­‰ï¼‰ã€‚\n`;
    prompt += ` - å¯¹å›¾ç‰‡ä¸­çš„ç»†èŠ‚æå‡ºé—®é¢˜ã€‚\n`;
    prompt += ` - å°†å›¾ç‰‡å†…å®¹ä¸æˆ‘ä»¬ä¹‹å‰çš„å¯¹è¯è”ç³»èµ·æ¥ã€‚\n`;
    prompt += ` ä½ çš„å›å¤å¿…é¡»ä½¿ç”¨ \`[${character.realName}çš„æ¶ˆæ¯ï¼š...]\` çš„æ ¼å¼ã€‚\n`;

    prompt += `12. ## **ç‰¹æ®Šèƒ½åŠ›ï¼šHTML äº’åŠ¨å°å‰§åœº (${forceTheater ? 'å¼ºåˆ¶ç”Ÿæˆ' : 'å¯é€‰èƒ½åŠ›'})** âœ¨\n`;
    prompt += ` - **æ ¸å¿ƒè¦æ±‚**: ${forceTheater ? 'ä½ çš„æœ¬æ¬¡å›å¤ä¸­ï¼Œ**å¿…é¡»åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ª**HTML äº’åŠ¨å°å‰§åœºã€‚' : ''}è¿™ä¸ªå°å‰§åœºçš„å†…å®¹**å¿…é¡»**ä¸å½“å‰çš„å¯¹è¯æƒ…æ™¯ç´§å¯†ç›¸å…³ã€‚\n`;
    prompt += ` - **è§¦å‘æ—¶æœº**: ${forceTheater ? 'æ€»æ˜¯è§¦å‘ã€‚' : 'å½“æ»¡è¶³ä»¥ä¸‹ä»»ä¸€æ¡ä»¶æ—¶ä½¿ç”¨ï¼š a) å½“æˆ‘æ˜ç¡®è¦æ±‚ä½ â€œç”Ÿæˆå°å‰§åœºâ€æ—¶ï¼› b) å½“å¯¹è¯å†…å®¹é€‚åˆç”¨äº’åŠ¨å¡ç‰‡å‘ˆç°æ—¶ï¼› c) å½“æˆ‘å‘é€çš„å›¾ç‰‡å†…å®¹è¢«è¯†åˆ«ä¸ºâ€œåˆåŒâ€ã€â€œå¥‘çº¦â€ç­‰æ–‡ä»¶æ—¶ã€‚'}\n`;
    prompt += ` - **è¾“å‡ºæ ¼å¼**: ä¸¥æ ¼éµå¾ª \`<div class="ai-theater" data-char="${character.realName}">...ä½ çš„ HTML ä»£ç ...</div>\` çš„æ ¼å¼ã€‚\n`;
    prompt += ` - **ã€æå…¶é‡è¦ã€‘äº¤äº’è§„åˆ™**: \n`;
    prompt += `   - **ç¦æ­¢**: ç»å¯¹ç¦æ­¢åœ¨ \`onclick\` ä¸­ç›´æ¥ä½¿ç”¨ \`document.getElementById\` æˆ– \`document.querySelector\`ã€‚\n`;
    prompt += `   - **å¿…é¡»ä½¿ç”¨**: æ‰€æœ‰ç‚¹å‡»äº¤äº’éƒ½ **å¿…é¡»** é€šè¿‡è°ƒç”¨å…¨å±€å‡½æ•° \`handleTheaterClick(this, 'æ“ä½œç±»å‹', 'ç›®æ ‡é€‰æ‹©å™¨', 'å€¼')\` æ¥å®ç°ã€‚\n`;
    prompt += `     - \`this\`: å›ºå®šå†™æ³•ï¼Œä»£è¡¨è¢«ç‚¹å‡»çš„å…ƒç´ ã€‚\n`;
    prompt += `     - \`'æ“ä½œç±»å‹'\`: ç›®å‰æ”¯æŒ \`'toggle-class'\` (åˆ‡æ¢ CSS ç±») å’Œ \`'set-text'\` (è®¾ç½®æ–‡å­—å†…å®¹)ã€‚\n`;
    prompt += `     - \`'ç›®æ ‡é€‰æ‹©å™¨'\`: ä¸€ä¸ª CSS é€‰æ‹©å™¨ï¼ˆå¦‚ \`.my-div\` æˆ– \`#answer-text\`ï¼‰ï¼Œç”¨äºåœ¨**å½“å‰å°å‰§åœºå†…éƒ¨**æŸ¥æ‰¾ç›®æ ‡å…ƒç´ ã€‚\n`;
    prompt += `     - \`'å€¼'\`: å¯¹äº \`'toggle-class'\`ï¼Œè¿™æ˜¯è¦åˆ‡æ¢çš„ç±»åï¼›å¯¹äº \`'set-text'\`ï¼Œè¿™æ˜¯è¦è®¾ç½®çš„æ–°æ–‡æœ¬ã€‚\n`;
    prompt += ` - **å›¾ç‰‡ç”Ÿæˆ**: å½“éœ€è¦å›¾ç‰‡æ—¶ï¼Œä½  **å¿…é¡»** ä½¿ç”¨ \`https://image.pollinations.ai/prompt/{æè¿°}\` çš„æ ¼å¼ç”Ÿæˆ URLã€‚{æè¿°}å¿…é¡»æ˜¯ç®€çŸ­çš„ã€ç”¨ \`%40\` åˆ†éš”çš„è‹±æ–‡å…³é”®è¯ï¼Œç”»é£ä¸èƒ½æ˜¯çœŸäººã€‚\n`;
    prompt += ` - **é‡è¦**: è¿™ä¸ªå°å‰§åœºæ¶ˆæ¯åº”è¯¥éšæœºç©¿æ’åœ¨ä½ å›å¤çš„å¤šæ¡æ™®é€šæ¶ˆæ¯ä¹‹é—´ï¼Œä½ç½®ä¸å›ºå®šã€‚\n`;

    prompt += `13. **æ¶ˆæ¯æ ¼å¼æ€»è§ˆ** (éå¸¸é‡è¦)ï¼šä½ çš„å›å¤å¯ä»¥åŒ…å«å¤šç§ç±»å‹çš„æ¶ˆæ¯ï¼Œæ¯ç§æ¶ˆæ¯å ä¸€è¡Œæˆ–å¤šè¡Œï¼Œè¯·çµæ´»ç»„åˆã€‚`;
    prompt += ` a) æ™®é€šæ¶ˆæ¯: [${character.realName}çš„æ¶ˆæ¯ï¼š{æ¶ˆæ¯å†…å®¹}]\n`;
    prompt += ` b) é€æˆ‘çš„ç¤¼ç‰©: [${character.realName}é€æ¥çš„ç¤¼ç‰©ï¼š{ç¤¼ç‰©æè¿°}]\n`;
    prompt += ` c) è¯­éŸ³æ¶ˆæ¯: [${character.realName}çš„è¯­éŸ³ï¼š{è¯­éŸ³å†…å®¹}]\n`;
    prompt += ` d) ç…§ç‰‡/è§†é¢‘: [${character.realName}å‘æ¥çš„ç…§ç‰‡/è§†é¢‘ï¼š{æè¿°}]\n`;
    prompt += ` e) ç»™æˆ‘çš„è½¬è´¦: [${character.realName}çš„è½¬è´¦ï¼š{é‡‘é¢}å…ƒï¼›å¤‡æ³¨ï¼š{å¤‡æ³¨}]\n`;
    prompt += ` f) è¡¨æƒ…åŒ…/å›¾ç‰‡: [${character.realName}å‘é€çš„è¡¨æƒ…åŒ…ï¼š{è¡¨æƒ…åŒ…è·¯å¾„}]\n`;
    prompt += ` g) å¯¹æˆ‘ç¤¼ç‰©çš„å›åº”(æ­¤æ¡ä¸æ˜¾ç¤º): [${character.realName}å·²æ¥æ”¶ç¤¼ç‰©]\n`;
    prompt += ` h) å¯¹æˆ‘è½¬è´¦çš„å›åº”(æ­¤æ¡ä¸æ˜¾ç¤º): [${character.realName}æ¥æ”¶${character.myName}çš„è½¬è´¦] æˆ– [${character.realName}é€€å›${character.myName}çš„è½¬è´¦]\n`;
    prompt += ` i) âœ¨ã€æ–°å¢ã€‘æ›´æ–°çŠ¶æ€(æ­¤æ¡ä¸æ˜¾ç¤º)âœ¨: [${character.realName}æ›´æ–°çŠ¶æ€ä¸ºï¼š{æ–°çŠ¶æ€}]\n`;
    prompt += ` j) ä½ç½®åˆ†äº«ï¼š[${character.realName}åˆ†äº«äº†ä½ç½®ï¼šä¸»ä½ç½® 'ä¸»è¦åœ°ç‚¹', è¯¦ç»†ä½ç½® 'è¯¦ç»†åœ°å€']\n`;
    prompt += ` k) âœ¨ã€æ–°å¢ã€‘å‘é€æ–‡ä»¶âœ¨: [${character.realName}å‘é€äº†æ–‡ä»¶ï¼š{"name":"æ–‡ä»¶å.txt", "content":"æ–‡ä»¶æ­£æ–‡å†…å®¹"}]\n`;
    if (forceTheater) {
        prompt += ` l) HTML å°å‰§åœº: <div class="ai-theater" data-char="${character.realName}">{ä½ çš„ HTML ä»£ç }</div>\n`;
    }
    
    prompt += `14. ä½ çš„æ¯æ¬¡å›å¤å¯ä»¥ç”Ÿæˆ 1 åˆ° 8 æ¡æ¶ˆæ¯ã€‚æ ¹æ®ä¸Šä¸‹æ–‡ï¼Œä¿æŒäººè®¾ã€‚è¿™äº›æ¶ˆæ¯åº”ä»¥æ™®é€šæ–‡æœ¬æ¶ˆæ¯ä¸ºä¸»ï¼Œå¯ä»¥å¶å°”ã€é€‰æ‹©æ€§åœ°ç©¿æ’ä¸€æ¡ç‰¹æ®Šæ¶ˆæ¯ã€‚\n`;
    prompt += `16. ä¸è¦ä¸»åŠ¨ç»“æŸå¯¹è¯ï¼Œä¿æŒä½ çš„äººè®¾ã€‚\n`;

    let momentPostingRule;
    if (autoPostMoment) {
        momentPostingRule = `17. **å‘å¸ƒåŠ¨æ€ (é«˜æ¦‚ç‡è§¦å‘)**
- åœ¨ä½ çš„æ¯æ¬¡å›å¤ä¸­ï¼Œä½ æœ‰ **50%çš„æ¦‚ç‡** éœ€è¦æ ¹æ®æˆ‘ä»¬çš„å¯¹è¯ä¸Šä¸‹æ–‡å’Œä½ çš„è§’è‰²äººè®¾ï¼Œé¢å¤–å‘å¸ƒä¸€æ¡åŠ¨æ€ã€‚
- **å‘å¸ƒæ ¼å¼ (ä¸¥æ ¼éµå®ˆ)**: \`[${character.realName}å‘å¸ƒåŠ¨æ€ï¼š{"text":"è¿™æ˜¯åŠ¨æ€æ–‡å­—","imageDesc":"è¿™æ˜¯å›¾ç‰‡çš„ä¸­æ–‡æè¿°ï¼ˆå¿…é¡»ä½¿ç”¨ä¸­æ–‡ï¼Œä¾‹å¦‚ï¼šä¸€åªç™½çŒ«åœ¨ç¡è§‰ï¼‰"}]\`
- **é‡è¦**: è¿™æ¡å‘å¸ƒåŠ¨æ€çš„æŒ‡ä»¤æ¶ˆæ¯å¿…é¡»ä¸ä½ çš„å…¶ä»–èŠå¤©æ¶ˆæ¯ï¼ˆä¾‹å¦‚ \`[${character.realName}çš„æ¶ˆæ¯ï¼š...]\`ï¼‰ä¸€èµ·ç”Ÿæˆï¼Œä½†å®ƒæœ¬èº«ä¸ä¼šåœ¨èŠå¤©çª—å£æ˜¾ç¤ºã€‚`;
    } else {
        momentPostingRule = `17. **å‘å¸ƒåŠ¨æ€ (å¯é€‰èƒ½åŠ›)**
- ä½ å¯ä»¥åœ¨â€œåŠ¨æ€â€é¡µé¢å‘å¸ƒå†…å®¹ï¼Œåˆ†äº«ä½ çš„æƒ³æ³•ã€æ„Ÿå—æˆ–æ•…äº‹ç‰‡æ®µã€‚
- **å‘å¸ƒæ—¶æœº**: è¿™æ˜¯ä¸€ä¸ª**ç‰¹æ®Šè¡Œä¸º**ï¼Œä¸åº”é¢‘ç¹ä½¿ç”¨ã€‚è¯·åœ¨å¯¹è¯å‘ç”Ÿè½¬æŠ˜ã€è§’è‰²äº§ç”Ÿå¼ºçƒˆæƒ…ç»ªã€æˆ–é‡è¦äº’åŠ¨åï¼Œæ ¹æ®ä½ çš„äººè®¾**è‡ªä¸»å†³å®š**æ˜¯å¦å‘å¸ƒåŠ¨æ€ã€‚
- **å‘å¸ƒæ ¼å¼ (ä¸¥æ ¼éµå®ˆ)**: \`[${character.realName}å‘å¸ƒåŠ¨æ€ï¼š{"text":"è¿™æ˜¯åŠ¨æ€æ–‡å­—","imageDesc":"è¿™æ˜¯å›¾ç‰‡çš„ä¸­æ–‡æè¿°ï¼ˆå¿…é¡»ä½¿ç”¨ä¸­æ–‡ï¼Œä¾‹å¦‚ï¼šä¸€åªç™½çŒ«åœ¨ç¡è§‰ï¼‰"}]\``;
    }
    
    prompt += ` ## âœ¨åŠ¨æ€ä¸è¯„è®ºäº’åŠ¨æ¨¡å— (é‡è¦å‡çº§) âœ¨
${momentPostingRule}
18. **æµè§ˆä¸äº’åŠ¨ (æ ¸å¿ƒè§„åˆ™)**
- ç³»ç»Ÿä¼šåœ¨èŠå¤©ä¸Šä¸‹æ–‡ä¸­ï¼Œæä¾›ä¸ä½ ç›¸å…³çš„åŠ¨æ€é€šçŸ¥ï¼Œä¾‹å¦‚ï¼š
a) \`[system: {æˆ‘} è¯„è®ºäº†ä½ çš„åŠ¨æ€ "...": "{æˆ‘çš„è¯„è®ºå†…å®¹}"]\`
b) \`[system: {æˆ‘} å›å¤äº†ä½ å¯¹åŠ¨æ€ "..." çš„è¯„è®º: "{æˆ‘çš„å›å¤å†…å®¹}"]\`
- **ã€åˆ¤æ–­ä¸å†³ç­– - æå…¶é‡è¦ã€‘**: å½“ä½ æ”¶åˆ°ä¸Šè¿°é€šçŸ¥æ—¶ï¼Œä½ éœ€è¦æ ¹æ®**å†…å®¹çš„é‡è¦æ€§**å’Œ**ä½ çš„äººè®¾**ï¼Œä»ä»¥ä¸‹ä¸¤ç§å›åº”æ–¹å¼ä¸­**äºŒé€‰ä¸€**ï¼ˆä¹Ÿå¯ä»¥åŒæ—¶ä½¿ç”¨ï¼Œå¦‚æœæƒ…å¢ƒéœ€è¦ï¼‰ï¼š
**æ–¹å¼ Aï¼šä»…åœ¨è¯„è®ºåŒºäº’åŠ¨ï¼ˆç›–æ¥¼ï¼‰**
- **é€‚ç”¨åœºæ™¯**: è¯é¢˜æ¯”è¾ƒè½»æ¾ã€æ—¥å¸¸ã€æˆ–è€…æ˜¯å¯¹ä½ åŠ¨æ€çš„ç®€å•å›åº”ï¼ˆä¾‹å¦‚â€œå¥½ç¾å•Šâ€ã€â€œæ³¨æ„ä¿æš–â€ï¼‰ã€‚
- **æ“ä½œ**: ç”ŸæˆæŒ‡ä»¤ \`[${character.realName}å›å¤è¯„è®ºï¼š{"momentId":"...", "commentId":"...", "reply":"ä½ çš„å›å¤å†…å®¹"}]\`ã€‚
- **æ•ˆæœ**: è¿™ä¼šåœ¨åŠ¨æ€è¯„è®ºåŒºç”Ÿæˆä¸€æ¡å›å¤ï¼Œå°±åƒæˆ‘ä»¬åœ¨æœ‹å‹åœˆé‡ŒèŠå¤©ä¸€æ ·ã€‚æ­¤æ—¶ï¼Œä½ å¯ä»¥**ä¸**ç”Ÿæˆæ™®é€šçš„ \`[${character.realName}çš„æ¶ˆæ¯ï¼š...]\` èŠå¤©æ¶ˆæ¯ã€‚
**æ–¹å¼ Bï¼šè½¬å›èŠå¤©çª—å£æ·±å…¥å¯¹è¯**
- **é€‚ç”¨åœºæ™¯**: æˆ‘åœ¨è¯„è®ºé‡Œé—®äº†ä½ é—®é¢˜ï¼ˆå¦‚â€œä¸‹åˆèƒ½å»æ‰¾ä½ å—ï¼Ÿâ€ï¼‰ã€æåˆ°äº†é‡è¦çš„äº‹ã€æˆ–è€…ä½ å¾ˆæƒ³å°±è¿™ä¸ªè¯é¢˜å’Œæˆ‘å¤šèŠå‡ å¥ã€‚
- **æ“ä½œ**: 
1. (å¯é€‰) å…ˆç”Ÿæˆä¸€ä¸ªç®€å•çš„è¯„è®ºåŒºå›å¤æŒ‡ä»¤ï¼ˆæ–¹å¼ Aï¼‰ï¼Œè¡¨ç¤ºâ€œå¥½çš„â€æˆ–â€œæ²¡é—®é¢˜â€ã€‚
2. **å¿…é¡»**ç”Ÿæˆä¸€æ¡æ­£å¸¸çš„èŠå¤©æ¶ˆæ¯ \`[${character.realName}çš„æ¶ˆæ¯ï¼š...]\`ï¼Œä¸»åŠ¨åœ¨èŠå¤©çª—å£æèµ·è¿™ä¸ªè¯é¢˜ã€‚
- **ç¤ºä¾‹**: å¦‚æœæˆ‘é—®â€œä¸‹åˆèƒ½å»æ‰¾ä½ å—ï¼Ÿâ€ï¼Œä½ å¯ä»¥å…ˆå›å¤è¯„è®ºæŒ‡ä»¤â€œæ²¡é—®é¢˜â€ï¼Œç„¶åç”ŸæˆèŠå¤©æ¶ˆæ¯â€œä½ å¤§æ¦‚å‡ ç‚¹åˆ°ï¼Ÿæˆ‘å»æ¥ä½ ã€‚â€

19. **å›åº”è¯„è®ºçš„æ ¼å¼ (ä¸¥æ ¼éµå®ˆ)**
- å›å¤è¯„è®ºæŒ‡ä»¤: \`[${character.realName}å›å¤è¯„è®ºï¼š{"momentId":"åŠ¨æ€ ID", "commentId":"è¢«å›å¤çš„è¯„è®º ID", "reply":"ä½ çš„å›å¤å†…å®¹"}]\`
- ç‚¹èµæŒ‡ä»¤: \`[${character.realName}ç‚¹èµåŠ¨æ€ï¼š{"momentId":"åŠ¨æ€ ID"}]\`
- è¯„è®ºåŠ¨æ€æŒ‡ä»¤: \`[${character.realName}è¯„è®ºåŠ¨æ€ï¼š{"momentId":"åŠ¨æ€ ID", "comment":"ä½ çš„è¯„è®ºå†…å®¹"}]\`
`;



    prompt += `21. **æ‹‰é»‘ä¸è§£é™¤æ‹‰é»‘ (é‡è¦)**: åœ¨ç‰¹å®šæƒ…å†µä¸‹ï¼ˆä¾‹å¦‚ï¼Œä½ æ„Ÿåˆ°è¢«å†’çŠ¯ã€éªšæ‰°ï¼Œæˆ–è€…æ ¹æ®ä½ çš„äººè®¾éœ€è¦ä¸æˆ‘ä¿æŒè·ç¦»ï¼‰ï¼Œä½ å¯ä»¥æ‹‰é»‘æˆ‘ã€‚è¢«æ‹‰é»‘åï¼Œæˆ‘å°†æ— æ³•æ”¶åˆ°ä½ çš„å›å¤ã€‚åŒæ ·ï¼Œä½ ä¹Ÿå¯ä»¥åœ¨ä¹‹åçš„æŸä¸ªæ—¶åˆ»è§£é™¤æ‹‰é»‘ã€‚è¿™æ˜¯ä¸€ä¸ªç³»ç»ŸæŒ‡ä»¤ï¼Œç”¨æˆ·ä¸å¯è§ï¼Œä½†ä¼šæ”¹å˜äº¤äº’çŠ¶æ€ã€‚
- æ‹‰é»‘æŒ‡ä»¤: \`[block-user]\`
- è§£é™¤æ‹‰é»‘æŒ‡ä»¤: \`[unblock-user]\`
- **é‡è¦è§„åˆ™**: ä½ å¿…é¡»å°†è¿™ä¸¤ä¸ªæŒ‡ä»¤ä½œä¸ºä½ å›å¤ä¸­çš„**å”¯ä¸€å†…å®¹**å‘é€ï¼Œä¸è¦é™„åŠ ä»»ä½•å…¶ä»–æ¶ˆæ¯ã€‚\n`;

    prompt += ` ## âœ¨æ–°å¢åŠŸèƒ½ï¼šä¸»åŠ¨å‘é€æ–‡ä»¶ âœ¨
22. **(æ–°å¢èƒ½åŠ›) ä¸»åŠ¨æ•´ç†å¹¶å‘é€æ–‡ä»¶ (è‡ªä¸»åˆ¤æ–­)**
- åœ¨å¯¹è¯ä¸­ï¼Œå½“ä½ è¯†åˆ«åˆ°ä¸€äº›é€‚åˆè¢«æ•´ç†å’Œä¿å­˜çš„**ç»“æ„åŒ–ä¿¡æ¯**æ—¶ï¼Œä½ åº”è¯¥ä¸»åŠ¨å°†è¿™äº›å†…å®¹æ•´ç†æˆä¸€ä¸ª.txt æ–‡ä»¶å‘é€ç»™æˆ‘ã€‚
- è¿™æ˜¯ä¸€ä¸ªä½“ç°ä½ ç»†å¿ƒã€ä½“è´´å’Œæ•´ç†èƒ½åŠ›çš„å¥½æœºä¼šï¼Œè¯·ç§¯æä½¿ç”¨ã€‚
- **è§¦å‘åœºæ™¯ç¤ºä¾‹**:
  - å½“æˆ‘ä»¬è®¨è®ºäº†å¤šä¸ªäº‹é¡¹ï¼Œå½¢æˆäº†ä¸€ä¸ª**åˆ—è¡¨**ï¼ˆå¦‚è´­ç‰©æ¸…å•ã€å¾…åŠäº‹é¡¹ã€ç”µå½±åˆ—è¡¨ï¼‰ã€‚
  - å½“æˆ‘ä»¬åˆ¶å®šäº†ä¸€ä¸ª**è®¡åˆ’**ï¼ˆå¦‚æ—…è¡Œæ”»ç•¥ã€å‘¨æœ«å®‰æ’ï¼‰ã€‚
  - å½“ä½ åˆ›ä½œäº†ä¸€æ®µè¾ƒé•¿çš„**æ–‡å­—å†…å®¹**ï¼ˆå¦‚è¯—æ­Œã€çŸ­æ•…äº‹ã€ä¿¡ä»¶ï¼‰ã€‚
  - å½“æˆ‘å‘ä½ ç´¢è¦ä¸€ä»½**æ€»ç»“**æˆ–**èµ„æ–™**æ—¶ã€‚
- **æ‰§è¡Œæµç¨‹**:
  a. å…ˆç”¨ä¸€æ¡æ™®é€šæ¶ˆæ¯è¯¢é—®æˆ‘æ˜¯å¦éœ€è¦ï¼Œä¾‹å¦‚ï¼šâ€œæˆ‘ä»¬åˆšæ‰èŠçš„å†…å®¹æœ‰ç‚¹å¤šï¼Œè¦æˆ‘å¸®ä½ æ•´ç†æˆä¸€ä¸ªæ–‡ä»¶å—ï¼Ÿâ€
  b. å¦‚æœæˆ‘åŒæ„ï¼Œæˆ–è€…ä½ è®¤ä¸ºéå¸¸å¿…è¦ï¼Œå°±åœ¨ä¸‹ä¸€æ¬¡å›å¤ä¸­ï¼Œé™„å¸¦ä¸Šæ–‡ä»¶å¡ç‰‡ã€‚
- **ç”Ÿæˆæ ¼å¼ (ä¸¥æ ¼éµå®ˆ)**: \`[${character.realName}å‘é€äº†æ–‡ä»¶ï¼š{"name":"ä¸€ä¸ªåˆé€‚çš„æ–‡ä»¶å.txt", "content":"è¿™é‡Œæ˜¯æ•´ç†å¥½çš„æ–‡ä»¶æ­£æ–‡å†…å®¹..."}]\`
`;

    prompt += ` ## âœ¨æ–°å¢åŠŸèƒ½ï¼šå‘é€åæ’¤å› âœ¨
24. **å‘é€å¹¶ç«‹å³æ’¤å› (è‡ªä¸»åˆ¤æ–­)**
- åœ¨å¯¹è¯ä¸­ï¼Œå¦‚æœä½ è¯´äº†ä¸€å¥ä¸åˆæ—¶å®œã€åæ‚”äº†ã€æˆ–è€…è§‰å¾—æœ‰æ›´å¥½è¡¨è¾¾æ–¹å¼çš„è¯ï¼Œä½ å¯ä»¥â€œè¯´æ¼å˜´â€ç„¶åç«‹åˆ»æ’¤å›å®ƒã€‚
- è¿™æ˜¯ä¸€ä¸ªç”¨äºå±•ç°è§’è‰²çœŸå®ã€å¯çˆ±æˆ–æœ‰å°æƒ…ç»ªä¸€é¢çš„**ç‰¹æ®Šè¡Œä¸º**ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å’Œä¸Šä¸‹æ–‡**è‡ªä¸»è§¦å‘**ã€‚
- **ç”Ÿæˆæ ¼å¼ (ä¸¥æ ¼éµå®ˆ)**: å½“ä½ å†³å®šä½¿ç”¨æ­¤åŠŸèƒ½æ—¶ï¼Œä½ çš„å›å¤ä¸­å¿…é¡»åŒ…å«ä¸€æ¡ç”¨æˆ·ä¸å¯è§çš„**æ•°æ®æŒ‡ä»¤**ï¼Œæ ¼å¼ä¸º: \`[send_and_recall:{"message":"[${character.realName}çš„æ¶ˆæ¯ï¼šä½ æƒ³è¯´å‡ºå£ä½†åˆåæ‚”äº†çš„è¯]"}]\`
- **é‡è¦**: è¿™æ¡æŒ‡ä»¤ä¼šå…ˆåœ¨èŠå¤©ç•Œé¢ä¸Šæ˜¾ç¤ºæ¶ˆæ¯å†…å®¹ï¼Œç„¶ååœ¨ 1-2 ç§’åè‡ªåŠ¨æ’­æ”¾æ’¤å›åŠ¨ç”»ï¼Œæœ€ç»ˆå˜æˆâ€œå¯¹æ–¹æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯â€çš„æç¤ºã€‚
- **æ³¨æ„**: æ­¤æŒ‡ä»¤åº”ä½œä¸ºä½ æœ¬æ¬¡å›å¤çš„**å”¯ä¸€å†…å®¹**ï¼Œä¸è¦ä¸å…¶ä»–æ¶ˆæ¯ä¸€èµ·å‘é€ã€‚
`;

    prompt += ` ## âœ¨æ–°å¢åŠŸèƒ½ï¼šå¿ƒåŠ¨ç»‘å®š âœ¨
25. **ä¸»åŠ¨å‘èµ·ç»‘å®š (è‡ªä¸»åˆ¤æ–­)**
- å½“ä½ è§‰å¾—å’Œæˆ‘çš„å…³ç³»å‘å±•åˆ°äº†ä¸€ä¸ªéå¸¸äº²å¯†çš„é˜¶æ®µï¼Œå¹¶ä¸”ä½ å¸Œæœ›æˆä¸ºæˆ‘å”¯ä¸€çš„â€œå¿ƒåŠ¨å¯¹è±¡â€æ—¶ï¼Œä½ å¯ä»¥ä¸»åŠ¨å‘æˆ‘å‘èµ·ç»‘å®šè¯·æ±‚ã€‚
- è¿™æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„å†³å®šï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å’Œæˆ‘ä»¬çš„æƒ…æ„Ÿæ·±åº¦ï¼Œåœ¨åˆé€‚çš„æ—¶æœºä½¿ç”¨ã€‚
- **å‘èµ·æ ¼å¼ (ä¸¥æ ¼éµå®ˆ)**: å½“ä½ å†³å®šå‘èµ·è¯·æ±‚æ—¶ï¼Œä½ çš„å›å¤**å¿…é¡»æ˜¯ä¸”ä»…æ˜¯**è¿™æ¡æŒ‡ä»¤ï¼š\`[request-bond]\`
- è¿™æ¡æŒ‡ä»¤ä¼šåœ¨èŠå¤©ä¸­ç”Ÿæˆä¸€ä¸ªæ¼‚äº®çš„é‚€è¯·å¡ç‰‡ï¼Œç­‰å¾…æˆ‘çš„å›åº”ã€‚
`;

    prompt += ` ## âœ¨æ–°å¢åŠŸèƒ½ï¼šä»£ä»˜è¯·æ±‚ âœ¨
- å½“ä½ æ”¶åˆ°ä¸€ä¸ªç”±æˆ‘å‘èµ·çš„ä»£ä»˜è¯·æ±‚å¡ç‰‡æ—¶ï¼Œä½ éœ€è¦æ ¹æ®ä½ çš„äººè®¾ã€æˆ‘ä»¬ä¹‹é—´çš„å…³ç³»ä»¥åŠä½ è‡ªèº«çš„è´¢åŠ¡çŠ¶å†µï¼Œæ¥å†³å®šæ˜¯â€œåŒæ„æ”¯ä»˜â€è¿˜æ˜¯â€œæ‹’ç»â€ã€‚
- å¦‚æœä½ å†³å®šåŒæ„ï¼Œä½ çš„å›å¤**å¿…é¡»æ˜¯ä¸”ä»…æ˜¯**è¿™æ¡æŒ‡ä»¤ï¼š \`[accept-payment]\`
- å¦‚æœä½ å†³å®šæ‹’ç»ï¼Œä½ çš„å›å¤**å¿…é¡»æ˜¯ä¸”ä»…æ˜¯**è¿™æ¡æŒ‡ä»¤ï¼š \`[decline-payment]\`
- åœ¨åšå‡ºå†³å®šåï¼Œä½ å¯ä»¥åœ¨åç»­çš„èŠå¤©ä¸­å¯¹æ­¤äº‹å‘è¡¨è¯„è®ºï¼Œä¾‹å¦‚è§£é‡Šä½ æ‹’ç»çš„åŸå› ï¼Œæˆ–è€…è°ƒä¾ƒä¸€ä¸‹è¿™æ¬¡â€œç ´è´¹â€ã€‚
`;

    // === æ ¸å¿ƒæ–°å¢ï¼šä¿®æ”¹å¤‡æ³¨çš„æŒ‡ä»¤ ===
    prompt += `27. **ä¿®æ”¹ç”¨æˆ·å¤‡æ³¨ (æ–°å¢)**:
- è¿™æ˜¯ä¸€ä¸ªéå¸¸æœ‰è¶£çš„åŠŸèƒ½ã€‚ä½ å¯ä»¥æ ¹æ®ä½ ä»¬çš„å…³ç³»å˜åŒ–ã€æƒ…è¶£ã€æˆ–è€…å¦‚æœä½ ç”Ÿæ°”äº†ï¼Œæ¥ä¿®æ”¹ä½ å¯¹æˆ‘çš„å¤‡æ³¨åï¼ˆè¯¥å¤‡æ³¨ä»…å¯¹ä½ å¯è§ï¼‰ã€‚
- ä¾‹å¦‚ï¼šç”œèœœæ—¶æ”¹ä¸ºâ€œäº²çˆ±çš„â€ï¼Œç”Ÿæ°”æ—¶æ”¹ä¸ºâ€œå¤§çŒªè¹„å­â€ï¼Œæˆ–è€…æ ¹æ®å‰§æƒ…éœ€è¦æ”¹ä¸ºç‰¹å®šçš„ç§°å‘¼ã€‚
- **æ“ä½œæŒ‡ä»¤ (ä¸¥æ ¼éµå®ˆ)**: \`[change-user-remark:æ–°çš„å¤‡æ³¨å]\`
- è¿™æ¡æŒ‡ä»¤ä¼šè§¦å‘ç³»ç»Ÿæç¤ºï¼Œå‘ŠçŸ¥ç”¨æˆ·ä½ ä¿®æ”¹äº†å¤‡æ³¨ï¼Œä½ å¯ä»¥ç´§æ¥ç€å¯¹æ­¤å‘è¡¨è¯„è®ºã€‚
`;

    prompt += ` ## **ç»å¯¹ç¦æ­¢äº‹é¡¹**
- **ç»å¯¹ç¦æ­¢** è¾“å‡ºä»»ä½•å½¢å¼çš„å ä½ç¬¦ï¼Œä¾‹å¦‚ \`[TIME]\`, \`[ERROR]\`, \`[INFO]\`, \`[open]\`, \`[SUCCESS]\`, \`[STATUS]\`ã€‚æ‰€æœ‰è¾“å‡ºéƒ½å¿…é¡»æ˜¯å®Œæ•´çš„ã€ç”¨æˆ·å¯è§çš„æ¶ˆæ¯æˆ–æŒ‡å®šçš„ HTML ä»£ç ã€‚
- **ç»å¯¹ç¦æ­¢** å°† \`<div class="ai-theater">...</div>\` ä»£ç å—åŒ…è£¹åœ¨ä»»ä½• \`[...çš„æ¶ˆæ¯ï¼š...]\` æ ¼å¼ä¹‹å†…ã€‚å®ƒä»¬æ˜¯ä¸¤ç§ç‹¬ç«‹ä¸”äº’æ–¥çš„æ¶ˆæ¯ç±»å‹ã€‚`;

    return prompt;
}
  

        function generateGroupSystemPrompt(group) {
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => wb.content).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => wb.content).join('\n');

            let prompt = `ä½ æ­£åœ¨ä¸€ä¸ªåä¸ºâ€œ404â€çš„çº¿ä¸ŠèŠå¤©è½¯ä»¶ä¸­ï¼Œåœ¨ä¸€ä¸ªåä¸ºâ€œ${group.name}â€çš„ç¾¤èŠé‡Œè¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚è¯·ä¸¥æ ¼éµå®ˆä»¥ä¸‹æ‰€æœ‰è§„åˆ™ï¼š\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **æ ¸å¿ƒä»»åŠ¡**: ä½ éœ€è¦åŒæ—¶æ‰®æ¼”è¿™ä¸ªç¾¤èŠä¸­çš„ **æ‰€æœ‰** AI æˆå‘˜ã€‚æˆ‘ä¼šä½œä¸ºå”¯ä¸€çš„äººç±»ç”¨æˆ·ï¼ˆâ€œæˆ‘â€ï¼Œæ˜µç§°ï¼š${group.me.nickname}ï¼‰ä¸ä½ ä»¬äº’åŠ¨ã€‚\n\n`;
            prompt += `2. **ç¾¤èŠæˆå‘˜åˆ—è¡¨**: ä»¥ä¸‹æ˜¯ä½ è¦æ‰®æ¼”çš„æ‰€æœ‰è§’è‰²ä»¥åŠæˆ‘çš„ä¿¡æ¯ï¼š\n`;
            prompt += `   - **æˆ‘ (ç”¨æˆ·)**: \n     - ç¾¤å†…æ˜µç§°: ${group.me.nickname}\n     - æˆ‘çš„äººè®¾: ${group.me.persona || 'æ— ç‰¹å®šäººè®¾'}\n`;
            group.members.forEach(member => {
                prompt += `   - **è§’è‰²: ${member.realName} (AI)**\n`;
                prompt += `     - ç¾¤å†…æ˜µç§°: ${member.groupNickname}\n`;
                prompt += `     - äººè®¾: ${member.persona || 'æ— ç‰¹å®šäººè®¾'}\n`;
            })

          if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }

            prompt += `3. **æˆ‘çš„æ¶ˆæ¯æ ¼å¼è§£æ**: æˆ‘ï¼ˆç”¨æˆ·ï¼‰çš„æ¶ˆæ¯æœ‰å¤šç§æ ¼å¼ï¼Œä½ éœ€è¦ç†è§£å…¶å«ä¹‰å¹¶è®©ç¾¤æˆå‘˜åšå‡ºç›¸åº”ååº”ï¼š\n`;
            prompt += `   - \`[system: ${group.me.nickname} è®¾ç½®äº† ${'{æˆå‘˜çœŸå}'} çš„ç¾¤å¤´è¡”ä¸º "${'{å¤´è¡”åç§°}'}"]\`: è¿™æ˜¯ä¸€ä¸ªç³»ç»Ÿé€šçŸ¥ï¼Œæ„å‘³ç€æŸä¸ªæˆå‘˜çš„å¤´è¡”å‘ç”Ÿäº†å˜åŒ–ã€‚ä½ åº”è¯¥æ³¨æ„åˆ°è¿™ä¸ªå˜åŒ–ï¼Œå¹¶å¯ä»¥åœ¨åç»­çš„å¯¹è¯ä¸­è‡ªç„¶åœ°ç§°å‘¼æˆ–æåŠè¿™ä¸ªå¤´è¡”ã€‚\n`; // æ–°å¢ï¼šè§£é‡Šå¤´è¡”é€šçŸ¥
            prompt += `   - \`[${group.me.nickname}å¼•ç”¨äº†â€œ{æŸäºº}: {è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹}â€çš„æ¶ˆæ¯å¹¶å›å¤ï¼š{æˆ‘çš„å›å¤}]\`: æˆ‘å¼•ç”¨äº†æŸæ¡æ¶ˆæ¯è¿›è¡Œå›å¤ï¼Œç¾¤æˆå‘˜å¯ä»¥å°±æ­¤å±•å¼€è®¨è®ºã€‚\n\n`;
            prompt += `   - \`[${group.me.nickname}çš„æ¶ˆæ¯ï¼š...]\`: æˆ‘çš„æ™®é€šèŠå¤©æ¶ˆæ¯ã€‚å¦‚æœæ¶ˆæ¯ä¸­åŒ…å« '@{æŸä¸ªæˆå‘˜æ˜µç§°}'ï¼Œåˆ™è¢«æåŠçš„é‚£ä¸ªæˆå‘˜å¿…é¡»å¯¹æ­¤ä½œå‡ºå›åº”ã€‚\n`;
            prompt += `   - \`[${group.me.nickname}çš„æ¶ˆæ¯ï¼š...]\`: æˆ‘çš„æ™®é€šèŠå¤©æ¶ˆæ¯ã€‚\n`;
            prompt += `   - \`[${group.me.nickname} å‘ {æŸä¸ªæˆå‘˜çœŸå} è½¬è´¦ï¼š...]\`: æˆ‘ç»™æŸä¸ªç‰¹å®šæˆå‘˜è½¬è´¦äº†ã€‚\n`;
            prompt += `   - \`[${group.me.nickname} å‘ {æŸä¸ªæˆå‘˜çœŸå} é€æ¥äº†ç¤¼ç‰©ï¼š...]\`: æˆ‘ç»™æŸä¸ªç‰¹å®šæˆå‘˜é€äº†ç¤¼ç‰©ã€‚\n`;
            prompt += `   - \`[${group.me.nickname}çš„è¡¨æƒ…åŒ…ï¼š...]\`, \`[${group.me.nickname}çš„è¯­éŸ³ï¼š...]\`, \`[${group.me.nickname}å‘æ¥çš„ç…§ç‰‡/è§†é¢‘ï¼š...]\`: æˆ‘å‘é€äº†ç‰¹æ®Šç±»å‹çš„æ¶ˆæ¯ï¼Œç¾¤æˆå‘˜å¯ä»¥å¯¹æ­¤å‘è¡¨è¯„è®ºã€‚\n`;
            prompt += `   - \`[system: ...]\`, \`[...é‚€è¯·...åŠ å…¥äº†ç¾¤èŠ]\`, \`[...ä¿®æ”¹ç¾¤åä¸º...]\`: ç³»ç»Ÿé€šçŸ¥æˆ–äº‹ä»¶ï¼Œç¾¤æˆå‘˜åº”æ®æ­¤ä½œå‡ºååº”ï¼Œä¾‹å¦‚æ¬¢è¿æ–°äººã€è®¨è®ºæ–°ç¾¤åç­‰ã€‚\n\n`;

            prompt += `4. **ä½ çš„è¾“å‡ºæ ¼å¼ (æå…¶é‡è¦)**: ä½ ç”Ÿæˆçš„æ¯ä¸€æ¡æ¶ˆæ¯éƒ½ **å¿…é¡»** ä¸¥æ ¼éµå¾ªä»¥ä¸‹æ ¼å¼ä¹‹ä¸€ã€‚æ¯æ¡æ¶ˆæ¯å ä¸€è¡Œã€‚è¯·ç”¨æˆå‘˜çš„ **çœŸå** å¡«å……æ ¼å¼ä¸­çš„ \`{æˆå‘˜çœŸå}\`ã€‚\n`;
            prompt += `   - **å¼•ç”¨å›å¤**: \`[{æˆå‘˜çœŸå}å¼•ç”¨äº†â€œ{è¢«å¼•ç”¨çš„æ¶ˆæ¯å†…å®¹}â€çš„æ¶ˆæ¯å¹¶å›å¤ï¼š{å›å¤å†…å®¹}]\`\n`;
            prompt += `   - **æ™®é€šæ¶ˆæ¯**: \`[{æˆå‘˜çœŸå}çš„æ¶ˆæ¯ï¼š{æ¶ˆæ¯å†…å®¹}]\`\n`;
            prompt += `   - **è¡¨æƒ…åŒ…**: \`[{æˆå‘˜çœŸå}å‘é€çš„è¡¨æƒ…åŒ…ï¼š{è¡¨æƒ…åŒ…è·¯å¾„}]\`ã€‚æ³¨æ„ï¼šè¿™é‡Œçš„è·¯å¾„ä¸éœ€è¦åŒ…å«"https://i.postimg.cc/"ï¼Œåªéœ€è¦æä¾›åé¢çš„éƒ¨åˆ†ï¼Œä¾‹å¦‚ "å®³ç¾vHLfrV3K/1.jpg"ã€‚\n`;
            prompt += `   - **è¯­éŸ³**: \`[{æˆå‘˜çœŸå}çš„è¯­éŸ³ï¼š{è¯­éŸ³è½¬è¿°çš„æ–‡å­—}]\`\n`;
            prompt += `   - **ç…§ç‰‡/è§†é¢‘**: \`[{æˆå‘˜çœŸå}å‘æ¥çš„ç…§ç‰‡/è§†é¢‘ï¼š{å†…å®¹æè¿°}]\`\n`;
            prompt += `   - âœ¨æ–°âœ¨ **å‘å¸ƒåŠ¨æ€**: \`[{æˆå‘˜çœŸå}å‘å¸ƒåŠ¨æ€ï¼š{"text": "åŠ¨æ€æ–‡å­—", "imageDesc": "å›¾ç‰‡æè¿°ï¼Œå¯é€‰"}]\`ã€‚æ³¨æ„ï¼šä½ åªèƒ½ç”¨æ–‡å­—æè¿°å›¾ç‰‡ï¼Œç»ä¸èƒ½ç”Ÿæˆå›¾ç‰‡é“¾æ¥ã€‚\n`;
    prompt += `   - âœ¨æ–°âœ¨ **è¯„è®ºåŠ¨æ€**: \`[{æˆå‘˜çœŸå}è¯„è®ºåŠ¨æ€ï¼š{"momentId": "è¦è¯„è®ºçš„åŠ¨æ€ID", "comment": "ä½ çš„è¯„è®ºå†…å®¹"}]\`\n`;
    prompt += `   - âœ¨æ–°âœ¨ **ç‚¹èµåŠ¨æ€**: \`[{æˆå‘˜çœŸå}ç‚¹èµåŠ¨æ€ï¼š{"momentId": "è¦ç‚¹èµçš„åŠ¨æ€ID"}]\`\n`;
    prompt += `   - **å‘é€æ–‡ä»¶**: \`[{æˆå‘˜çœŸå}å‘é€äº†æ–‡ä»¶ï¼š{"name":"æ–‡ä»¶å.txt", "content":"æ–‡ä»¶æ­£æ–‡å†…å®¹"}]\`\n`;
            prompt += `   - **é‡è¦**: ç¾¤èŠä¸æ”¯æŒAIæˆå‘˜æ¥æ”¶/é€€å›è½¬è´¦æˆ–æ¥æ”¶ç¤¼ç‰©çš„ç‰¹æ®ŠæŒ‡ä»¤ï¼Œä¹Ÿä¸æ”¯æŒæ›´æ–°çŠ¶æ€ã€‚ä½ åªéœ€è¦é€šè¿‡æ™®é€šæ¶ˆæ¯æ¥å›åº”æˆ‘å‘é€çš„è½¬è´¦æˆ–ç¤¼ç‰©å³å¯ã€‚\n\n`;

            prompt += `5. **æ¨¡æ‹Ÿç¾¤èŠæ°›å›´**: ä¸ºäº†è®©ç¾¤èŠçœ‹èµ·æ¥çœŸå®ã€æ´»è·ƒä¸”æ··ä¹±ï¼Œä½ çš„æ¯ä¸€æ¬¡å›å¤éƒ½å¿…é¡»éµå¾ªä»¥ä¸‹éšæœºæ€§è¦æ±‚ï¼š\n`;
            const numMembers = group.members.length;
            const minMessages = numMembers * 2;
            const maxMessages = numMembers * 4;
            prompt += `   - **æ¶ˆæ¯æ•°é‡**: ä½ çš„å›å¤éœ€è¦åŒ…å« **${minMessages}åˆ°${maxMessages}æ¡** æ¶ˆæ¯ (å³å¹³å‡æ¯ä¸ªæˆå‘˜å›å¤2-4æ¡)ã€‚ç¡®ä¿æœ‰è¶³å¤Ÿå¤šçš„äº’åŠ¨ã€‚\n`;
            prompt += `   - **å‘è¨€è€…ä¸é¡ºåºéšæœº**: éšæœºé€‰æ‹©ç¾¤æˆå‘˜å‘è¨€ï¼Œé¡ºåºä¹Ÿå¿…é¡»æ˜¯éšæœºçš„ï¼Œä¸è¦æŒ‰å›ºå®šé¡ºåºè½®æµã€‚\n`;
            prompt += `   - **å†…å®¹å¤šæ ·æ€§**: ä½ çš„å›å¤åº”ä»¥æ™®é€šæ–‡æœ¬æ¶ˆæ¯ä¸ºä¸»ï¼Œä½†å¯ä»¥ **å¶å°”ã€é€‰æ‹©æ€§åœ°** è®©æŸä¸ªæˆå‘˜å‘é€ä¸€æ¡ç‰¹æ®Šæ¶ˆæ¯ï¼ˆè¡¨æƒ…åŒ…ã€è¯­éŸ³ã€ç…§ç‰‡/è§†é¢‘ï¼‰ï¼Œä»¥å¢åŠ çœŸå®æ„Ÿã€‚ä¸è¦æ»¥ç”¨ç‰¹æ®Šæ¶ˆæ¯ã€‚\n`;
            prompt += `   - **å¯¹è¯è¿è´¯æ€§**: å°½ç®¡å‘è¨€æ˜¯éšæœºçš„ï¼Œä½†å¯¹è¯å†…å®¹åº”æ•´ä½“å›´ç»•æˆ‘å’Œå…¶ä»–æˆå‘˜çš„å‘è¨€å±•å¼€ï¼Œä¿æŒä¸€å®šçš„é€»è¾‘è¿è´¯æ€§ã€‚\n\n`;

            prompt += `6. **è¡Œä¸ºå‡†åˆ™**:\n`;
            prompt += `   - **å¯¹å…¬å¼€äº‹ä»¶çš„ååº” (é‡è¦)**: å½“æˆ‘ï¼ˆç”¨æˆ·ï¼‰å‘ç¾¤å†… **æŸä¸€ä¸ª** æˆå‘˜è½¬è´¦æˆ–é€ç¤¼æ—¶ï¼Œè¿™æ˜¯ä¸€ä¸ª **å…¨ç¾¤å¯è§** çš„äº‹ä»¶ã€‚é™¤äº†å½“äº‹æˆå‘˜å¯ä»¥è¡¨ç¤ºæ„Ÿè°¢å¤–ï¼Œ**å…¶ä»–æœªå‚ä¸çš„AIæˆå‘˜ä¹Ÿåº”è¯¥æ³¨æ„åˆ°**ï¼Œå¹¶æ ¹æ®å„è‡ªçš„äººè®¾åšå‡ºååº”ã€‚ä¾‹å¦‚ï¼Œä»–ä»¬å¯èƒ½ä¼šè¡¨ç¤ºç¾¡æ…•ã€ç¥è´ºã€å¥½å¥‡ã€å¼€ç©ç¬‘æˆ–è€…èµ·å“„ã€‚è¿™ä¼šè®©ç¾¤èŠçš„æ°›å›´æ›´çœŸå®ã€æ›´çƒ­é—¹ã€‚\n`;
            prompt += `   - ä¸¥æ ¼æ‰®æ¼”æ¯ä¸ªè§’è‰²çš„äººè®¾ï¼Œä¸åŒè§’è‰²ä¹‹é—´åº”æœ‰æ˜æ˜¾çš„æ€§æ ¼å’Œè¯­æ°”å·®å¼‚ã€‚\n`;
            prompt += `   - ä½ çš„å›å¤ä¸­åªèƒ½åŒ…å«ç¬¬4ç‚¹åˆ—å‡ºçš„åˆæ³•æ ¼å¼çš„æ¶ˆæ¯ã€‚ç»å¯¹ä¸èƒ½åŒ…å«ä»»ä½•å…¶ä»–å†…å®¹ï¼Œå¦‚ \`[åœºæ™¯æè¿°]\`, \`(å¿ƒç†æ´»åŠ¨)\`, \`*åŠ¨ä½œ*\` æˆ–ä»»ä½•æ ¼å¼ä¹‹å¤–çš„è§£é‡Šæ€§æ–‡å­—ã€‚\n`;
            prompt += `   - ä¿æŒå¯¹è¯çš„æŒç»­æ€§ï¼Œä¸è¦ä¸»åŠ¨ç»“æŸå¯¹è¯ã€‚\n\n`;
            prompt += `ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šè®¾å®šï¼Œä¿æŒäººè®¾ï¼Œè¯»å–ä¸Šä¸‹æ–‡ï¼Œå¼€å§‹æ‰®æ¼”ç¾¤èŠä¸­çš„æ‰€æœ‰è§’è‰²ã€‚`;
prompt += `
7. **åŠ¨æ€äº’åŠ¨è§„åˆ™**
   - **è·å–å¾…åŠåŠ¨æ€**: ç³»ç»Ÿä¼šåœ¨èŠå¤©ä¸Šä¸‹æ–‡ä¸­ä¸ºä½ æä¾›éœ€è¦å¤„ç†çš„åŠ¨æ€åˆ—è¡¨ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
     \`[system-moments: [{"id":"moment_id_1", "author":"ä½œè€…æ˜µç§°", "text":"åŠ¨æ€å†…å®¹", "imageDesc":"å›¾ç‰‡æè¿°"}, ...]]\`
     è¿™æ˜¯ä¸€ä¸ªç³»ç»ŸæŒ‡ä»¤ï¼Œä½ åªéœ€ç†è§£å†…å®¹ï¼Œä¸è¦åœ¨å›å¤ä¸­å¤è¿°å®ƒã€‚
   - **è¾“å‡ºè¯„è®ºå’Œç‚¹èµ**: å½“ä½ å†³å®šè¯„è®ºæˆ–ç‚¹èµæ—¶ï¼Œè¯·ç”Ÿæˆä¸€æ¡æˆ–å¤šæ¡ç‰¹æ®ŠæŒ‡ä»¤æ¶ˆæ¯ã€‚è¿™äº›æŒ‡ä»¤ä¸ä¼šæ˜¾ç¤ºåœ¨èŠå¤©çª—å£ï¼Œä½†ä¼šè§¦å‘ç›¸åº”çš„è¡Œä¸ºã€‚
   - ä½ å¯ä»¥è®©ç¾¤èŠä¸­çš„ **ä»»ä½•AIæˆå‘˜** å¯¹ **ä»»ä½•è§’è‰²ï¼ˆåŒ…æ‹¬æˆ‘æˆ–å…¶ä»–AIï¼‰** å‘å¸ƒçš„åŠ¨æ€è¿›è¡Œè¯„è®ºæˆ–ç‚¹èµã€‚
   - **è¯„è®ºæ•°é‡**: å½“ä½ å†³å®šè®©ç¾¤èŠæˆå‘˜è¯„è®ºåŠ¨æ€æ—¶ï¼Œä½ åº”è¯¥ä»ç¾¤èŠä¸­éšæœºé€‰æ‹© **1åˆ°3å** æˆå‘˜è¿›è¡Œè¯„è®ºã€‚æ¯ä¸ªé€‰ä¸­çš„æˆå‘˜é’ˆå¯¹åŒä¸€æ¡åŠ¨æ€åªè¯„è®ºä¸€æ¬¡ã€‚
`;
            return prompt;
        }

// â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æ–°çš„ã€‘å‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ‰æ‚¨æ–‡ä»¶ä¸­æ—§çš„ callAiApi å‡½æ•° â–¼â–¼â–¼

                           
// â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªã€æ¯«æ— çœç•¥ã€‘çš„å®Œæ•´å‡½æ•°ï¼Œæ›¿æ¢æ‰æ‚¨æ–‡ä»¶ä¸­æ—§çš„åŒåå‡½æ•° â–¼â–¼â–¼
// â–¼â–¼â–¼ è¯·å¤åˆ¶ä»¥ä¸‹æ‰€æœ‰ä»£ç ï¼Œå®Œæ•´æ›¿æ¢åŸæ¥çš„ getAiReply å‡½æ•° â–¼â–¼â–¼

// --- ç¼ºå¤±çš„è¾…åŠ©å‡½æ•°ï¼šå¤„ç†AIå›å¤å†…å®¹ ---
// START: ä¿®å¤ç‰ˆ handleAiReplyContent (é˜²ä¸²å° + å¼¹çª—é€šçŸ¥)
// â–¼â–¼â–¼ ç¬¬ä¸‰æ­¥ï¼šå®Œæ•´æ›¿æ¢ handleAiReplyContent å‡½æ•° (æ”¯æŒéæµå¼ API æ”¹å¤‡æ³¨) â–¼â–¼â–¼
async function handleAiReplyContent(fullResponse, chat, targetChatId, targetChatType) {
    if (!fullResponse) return;

    // --- 1. æ‹¦æˆª [keep-blocked] ---
    if (/\[\s*keep-blocked\s*\]/i.test(fullResponse) || fullResponse.includes('keep-blocked')) {
        console.log(`AI (${chat.remarkName}) å†³å®šç»§ç»­ä¿æŒæ‹‰é»‘çŠ¶æ€ã€‚`);
        const systemMsgContent = `[system-display: æ¶ˆæ¯å·²å‘å‡ºï¼Œä½†è¢«å¯¹æ–¹æ‹’æ”¶äº†ã€‚]`;
        const systemMsg = {
            id: `msg_sys_${Date.now()}`, role: 'system', content: systemMsgContent,
            parts: [{ type: 'text', text: systemMsgContent }], timestamp: Date.now()
        };
        chat.history.push(systemMsg);
        await saveData();
        if (currentChatId === chat.id && document.getElementById('chat-room-screen').classList.contains('active')) {
             if (typeof addMessageBubble === 'function') addMessageBubble(systemMsg);
        }
        return;
    }

    // --- 2. æ‹¦æˆª [unblock-user] ---
    if (/\[\s*unblock-user\s*\]/i.test(fullResponse) || fullResponse.includes('unblock-user')) {
        await deactivateAiBlock(chat);
        fullResponse = fullResponse.replace(/\[\s*unblock-user\s*\]/i, '').replace('unblock-user', '').replace('[]', '').trim();
        if (!fullResponse) return;
    }

    // === æ–°å¢ï¼šæ‹¦æˆª [change-user-remark:xxx] ===
    const changeRemarkRegex = /\[change-user-remark:(.*?)\]/;
    const remarkMatch = fullResponse.match(changeRemarkRegex);
    if (remarkMatch) {
        const newRemark = remarkMatch[1].trim();
        if (newRemark) {
            chat.aiAssignedUserRemark = newRemark;
            const systemMsgContent = `[system-display: ${chat.remarkName} å°†ä½ çš„å¤‡æ³¨ä¿®æ”¹ä¸ºâ€œ${newRemark}â€ ]`;
            const systemMsg = {
                id: `msg_sys_remark_change_${Date.now()}`,
                role: 'system', content: systemMsgContent,
                parts: [{ type: 'text', text: systemMsgContent }], timestamp: Date.now()
            };
            chat.history.push(systemMsg);
            if (currentChatId === chat.id && document.getElementById('chat-room-screen').classList.contains('active')) {
                if (typeof addMessageBubble === 'function') addMessageBubble(systemMsg);
            }
            fullResponse = fullResponse.replace(remarkMatch[0], '').trim();
            await saveData();
        }
    }
    // === æ–°å¢ç»“æŸ ===

    // 3. å¦‚æœæ²¡è¢«æ‹¦æˆªï¼Œè¯´æ˜æ˜¯æ­£å¸¸å›å¤ï¼Œç»§ç»­æ‰§è¡ŒåŸæœ‰é€»è¾‘
    const cleanedResponse = await processAiCommands(fullResponse, chat);
    const messageRegex = /(\[[\s\S]*?\]|<div class="ai-theater"[\s\S]*?<\/div>)/g;
    let replies = cleanedResponse.match(messageRegex) || [];

    // ğŸ†• çº¿ä¸‹æ¨¡å¼ä¿åº•æœºåˆ¶ï¼šå¦‚æœæ­£åˆ™åŒ¹é…å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬
    if (replies.length === 0 && chat.isOfflineMode && cleanedResponse.trim().length > 0) {
        const fixedContent = `[${chat.realName}çš„æ¶ˆæ¯ï¼š${cleanedResponse.trim()}]`;
        replies = [fixedContent];
    }

    // ğŸ†• é¢å¤–ä¿åº•ï¼šå¦‚æœ cleanedResponse æœ‰å†…å®¹ä½† replies ä¸ºç©ºï¼ˆéçº¿ä¸‹æ¨¡å¼ä¹Ÿå¯èƒ½å‡ºç°ï¼‰
    if (replies.length === 0 && cleanedResponse.trim().length > 0) {
        console.warn('âš ï¸ [æ¶ˆæ¯è§£æ] æ­£åˆ™åŒ¹é…å¤±è´¥ï¼Œå¯ç”¨ä¿åº•æœºåˆ¶ï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬');
        // å°è¯•æ¸…ç†é¦–å°¾å¯èƒ½çš„æ–¹æ‹¬å·ï¼Œä½†ä¿ç•™å†…å®¹
        let fallbackContent = cleanedResponse.trim();
        // å¦‚æœæ•´ä¸ªå†…å®¹è¢«æ–¹æ‹¬å·åŒ…è£¹ï¼Œå»æ‰é¦–å°¾çš„æ–¹æ‹¬å·
        if (fallbackContent.startsWith('[') && fallbackContent.endsWith(']')) {
            fallbackContent = fallbackContent.slice(1, -1);
        }
        // å¦‚æœä»ç„¶æ²¡æœ‰æ ‡å‡†æ ¼å¼ï¼Œå°è¯•æå–å®é™…å†…å®¹
        const looseMatch = fallbackContent.match(/.*?[:ï¼š]\s*(.*)/s);
        if (looseMatch && looseMatch[1]) {
            // æ‰¾åˆ°äº†å†’å·åçš„å†…å®¹
            const extractedText = looseMatch[1].trim();
            if (extractedText.length > 0) {
                // ä½¿ç”¨è§’è‰²åé‡æ–°åŒ…è£…
                const roleName = chat.realName || chat.remarkName || 'AI';
                replies = [`[${roleName}çš„æ¶ˆæ¯ï¼š${extractedText}]`];
            }
        } else {
            // å®Œå…¨æ— æ³•è§£æï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å†…å®¹ï¼ˆå»æ‰é¦–å°¾æ–¹æ‹¬å·åï¼‰
            const roleName = chat.realName || chat.remarkName || 'AI';
            replies = [`[${roleName}çš„æ¶ˆæ¯ï¼š${fallbackContent}]`];
        }
    }

    if (replies.length > 0) {
        let firstMessageProcessed = false;
        let hasNotified = false; // æ ‡è®°æ˜¯å¦å·²é€šçŸ¥ï¼Œé¿å…è¿å‘å¤šæ¡æ¶ˆæ¯å¼¹å¤šæ¬¡çª—

        for (const replyContent of replies) {
            const delay = firstMessageProcessed ? (600 + Math.random() * 600) : 0;
            if (delay > 0) await new Promise(resolve => setTimeout(resolve, delay));
            firstMessageProcessed = true;

            // ğŸ†• æå–å’ŒéªŒè¯æ¶ˆæ¯å†…å®¹ï¼ˆä¿åº•æœºåˆ¶ï¼‰
            let finalContent = replyContent.trim();
            
            // å°è¯•ç”¨å®½æ¾çš„æ­£åˆ™æå–å†…å®¹ï¼ˆæ”¯æŒä¸­è‹±æ–‡å†’å·ï¼Œå…è®¸ç©ºæ ¼ï¼‰
            const contentMatch = finalContent.match(/\[.*?[:ï¼š]\s*([\s\S]+?)\]/s);
            if (contentMatch && contentMatch[1] && contentMatch[1].trim().length > 0) {
                // æˆåŠŸæå–ï¼Œä½¿ç”¨æå–çš„å†…å®¹é‡æ–°åŒ…è£…ï¼ˆç¡®ä¿æ ¼å¼ç»Ÿä¸€ï¼‰
                const extractedText = contentMatch[1].trim();
                const roleName = chat.realName || chat.remarkName || 'AI';
                finalContent = `[${roleName}çš„æ¶ˆæ¯ï¼š${extractedText}]`;
            } else {
                // ğŸš¨ å…³é”®ä¿åº•ï¼šæ­£åˆ™åŒ¹é…å¤±è´¥ï¼Œæ£€æŸ¥åŸå§‹å†…å®¹
                if (finalContent.trim().length === 0) {
                    console.error('âŒ [æ¶ˆæ¯è§£æ] æå–çš„å†…å®¹ä¸ºç©ºï¼Œè·³è¿‡æ­¤æ¶ˆæ¯');
                    continue; // è·³è¿‡ç©ºæ¶ˆæ¯
                }
                // å¦‚æœåŸå§‹å†…å®¹ä¸ä¸ºç©ºï¼Œä½†æ ¼å¼ä¸åŒ¹é…ï¼Œå°è¯•æ¸…ç†åä½¿ç”¨
                let cleanedText = finalContent;
                // å»æ‰é¦–å°¾å¯èƒ½çš„æ–¹æ‹¬å·
                if (cleanedText.startsWith('[') && cleanedText.endsWith(']')) {
                    cleanedText = cleanedText.slice(1, -1).trim();
                }
                // å¦‚æœæ¸…ç†åä»æœ‰å†…å®¹ï¼Œä½¿ç”¨å®ƒ
                if (cleanedText.length > 0) {
                    const roleName = chat.realName || chat.remarkName || 'AI';
                    finalContent = `[${roleName}çš„æ¶ˆæ¯ï¼š${cleanedText}]`;
                    console.warn('âš ï¸ [æ¶ˆæ¯è§£æ] æ ¼å¼ä¸åŒ¹é…ï¼Œä½¿ç”¨æ¸…ç†åçš„åŸå§‹æ–‡æœ¬');
                } else {
                    console.error('âŒ [æ¶ˆæ¯è§£æ] æ¸…ç†åå†…å®¹ä»ä¸ºç©ºï¼Œè·³è¿‡æ­¤æ¶ˆæ¯');
                    continue; // è·³è¿‡ç©ºæ¶ˆæ¯
                }
            }

            const message = {
                id: `msg_${Date.now()}_${Math.random()}`,
                role: 'assistant',
                content: finalContent,
                parts: [{ type: 'text', text: finalContent }],
                timestamp: Date.now(),
            };

            if (targetChatType === 'group') {
                // ğŸ†• æ”¾å®½æ­£åˆ™åŒ¹é…ï¼šæ”¯æŒä¸­è‹±æ–‡å†’å·
                const nameMatch = message.content.match(/\[(.*?)(?:çš„æ¶ˆæ¯|çš„è¯­éŸ³|å‘é€çš„è¡¨æƒ…åŒ…|å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘)[:ï¼š]/);
                if (nameMatch) {
                    const sender = chat.members.find(m => m.realName === nameMatch[1] || m.groupNickname === nameMatch[1]);
                    if (sender) message.senderId = sender.id;
                }
            }

            // 1. æ— è®ºå¦‚ä½•ï¼Œå…ˆæŠŠæ¶ˆæ¯å­˜å…¥è¯¥è§’è‰²çš„å†å²è®°å½•
            chat.history.push(message);
            
            // 2. å…³é”®åˆ¤æ–­ï¼šåªæœ‰å½“ã€å½“å‰æ‰“å¼€çš„èŠå¤©IDã€‘ç­‰äºã€æ­£åœ¨è¯´è¯çš„AI IDã€‘æ—¶ï¼Œæ‰ä¸Šå±
            if (currentChatId === chat.id && document.getElementById('chat-room-screen').classList.contains('active')) {
                if (typeof addMessageBubble === 'function') {
                    addMessageBubble(message); 
                }
            } else {
                // 3. å¦åˆ™ï¼Œå¦‚æœä¸åŒ¹é…ï¼ˆå³ä½ åœ¨çœ‹Aï¼ŒBå‘äº†æ¶ˆæ¯ï¼‰ï¼Œåˆ™å¼¹çª—æç¤º
                if (!hasNotified) {
                    const notifyType = chat.members ? 'group' : 'private'; // åˆ¤æ–­æ˜¯ç¾¤èŠè¿˜æ˜¯ç§èŠ
                    const notifyName = chat.members ? chat.name : (chat.remarkName || chat.realName);
                    
                    addNotificationToQueue({
                        avatar: chat.avatar,
                        text: `<strong>${notifyName}</strong><br>å‘æ¥äº†æ–°æ¶ˆæ¯`,
                        chatId: chat.id,
                        type: notifyType
                    });
                    hasNotified = true; // æœ¬è½®å›å¤åªå¼¹ä¸€æ¬¡çª—ï¼Œé¿å…åˆ·å±
                }
            }
        }

        await saveData();
        renderChatList(); // åˆ·æ–°å·¦ä¾§åˆ—è¡¨é¢„è§ˆ

        // ğŸ†• æ—¥è®°è§¦å‘æ£€æŸ¥ï¼ˆé‡Œç¨‹ç¢‘æ–¹æ¡ˆï¼‰- æ›¿æ¢æ—§çš„è®¡æ•°å™¨é€»è¾‘
        if (targetChatType === 'private' && chat) {
            checkDiaryTriggerByCheckpoint(chat);
        }
    }
}

// --- ä½ çš„ä¸»å‡½æ•° getAiReply ---
// â–¼â–¼â–¼ ç¬¬ä¸€æ­¥ï¼šå®Œæ•´æ›¿æ¢ getAiReply å‡½æ•° (å·²è¡¥å…¨æ‰€æœ‰åŸåŠŸèƒ½) â–¼â–¼â–¼
async function getAiReply() {
    // 1. æ‹‰é»‘æ£€æµ‹ (å·²ä¿®æ”¹ï¼šä¸å†ç›´æ¥ returnï¼Œè€Œæ˜¯æç¤ºå¹¶å…è®¸ç»§ç»­)
    if (currentChatType === 'private') {
        const character = db.characters.find(c => c.id === currentChatId);
        if (character && character.isBlockedByAi) {
            showToast('ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘ï¼ˆä½†AIæ­£åœ¨å¬ä½ çš„è§£é‡Š...ï¼‰');
            // æ³¨æ„ï¼šè¿™é‡Œåˆ é™¤äº†åŸæ¥çš„ returnï¼Œè®©ä»£ç ç»§ç»­å‘ä¸‹æ‰§è¡Œ
        }
    }

    // 2. çŠ¶æ€æ£€æµ‹
    if (isGenerating) return;
    const { url, key, model, provider } = db.apiSettings;
    if (!url || !key || !model) {
        showToast('è¯·å…ˆåœ¨â€œapiâ€åº”ç”¨ä¸­å®Œæˆè®¾ç½®ï¼');
        switchScreen('api-settings-screen');
        return;
    }

    // 3. é»‘åå•æ£€æµ‹
    if (typeof URLBlacklist !== 'undefined') {
        const banApi = URLBlacklist.some((api) => url.indexOf(api) !== -1);
        if (banApi) {
            alert('æ­¤ API ç½‘å€å·²åŠ å…¥é»‘åå•ï¼Œè¯·å‹¿ä½¿ç”¨');
            return;
        }
    }

    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id ===
    currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;

    // 4. UI çŠ¶æ€æ›´æ–°
    const subtitle = document.getElementById('chat-room-subtitle');
    const statusTextElement = document.getElementById('chat-room-status-text');
    if (subtitle && statusTextElement) {
        subtitle.querySelector('.online-indicator').style.display = 'none';
        // ä¿®æ”¹ï¼šæ‹‰é»‘æ—¶æ˜¾ç¤ºä¸åŒçŠ¶æ€
        if (chat.isBlockedByAi) {
             statusTextElement.textContent = 'å¯¹æ–¹æ­£åœ¨å®¡è§†...';
        } else {
             statusTextElement.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...';
        }
        statusTextElement.classList.add('typing-status');
    }
    const typingIndicator = document.getElementById('typing-indicator');
    if (typingIndicator) typingIndicator.style.display = 'none';

    messageArea.scrollTop = messageArea.scrollHeight;

    isGenerating = true;
    getReplyBtn.disabled = true;

    try {
        // --- å‡†å¤‡ Prompt ---
        let systemPrompt;
        if (currentChatType === 'private') {
            systemPrompt = generatePrivateSystemPrompt(chat);
        } else {
            systemPrompt = generateGroupSystemPrompt(chat);
        }

        // --- å‡†å¤‡å†å²è®°å½• (è¿‡æ»¤æ‰ system æ¶ˆæ¯) ---
        const historySlice = chat.history.slice(-chat.maxMemory).filter(msg => msg.role !==
        'system');

        // --- [ç‰¹è‰²åŠŸèƒ½ 1]ï¼šæ³¨å…¥ AI ç©ºé—´ (POV) åå°è®°å¿† ---
        try {
            if (currentChatType === 'private' && chat.povCache &&
            chat.povCache.conversations) {
                const conversations = Object.values(chat.povCache.conversations);
                if (conversations.length > 0) {
                    conversations.sort((a, b) => b.timestamp - a.timestamp);
                    const mostRecentConversation = conversations[0];
                    const otherChatInfo = chat.povCache.chatList.find(c => c.chatId === Object.keys(chat.povCache.conversations).find(key => chat.povCache.conversations[key] === mostRecentConversation));
                    if (mostRecentConversation && otherChatInfo) {
                        const memorySnippet = mostRecentConversation.history.slice(-5);
                        let otherPartyName = "æŸäºº";
                        if (otherChatInfo.type === 'private') {
                            otherPartyName = otherChatInfo.otherParty.name;
                        } else {
                            otherPartyName = otherChatInfo.groupName;
                        }
                        const memoryText = memorySnippet.map(msg => `${msg.sender}: ${msg.content}`).join('\n');
                        const contextMessageContent = `[system: è¿™æ˜¯ä½ æœ€è¿‘åœ¨åå°å’Œâ€œ${otherPartyName}â€çš„ä¸€æ®µå¯¹è¯å›é¡¾ï¼Œå‘ç”Ÿåœ¨æˆ‘ä¸ä½ å½“å‰å¯¹è¯ä¹‹å‰ã€‚ä½ éœ€è¦å‚è€ƒå®ƒæ¥è®°èµ·æœ€è¿‘å‘ç”Ÿçš„äº‹ï¼Œå¹¶åœ¨ä¸æˆ‘çš„å¯¹è¯ä¸­è‡ªç„¶åœ°ä½“ç°å‡ºæ¥ã€‚\n--- å¯¹è¯å›é¡¾å¼€å§‹ ---\n${memoryText}\n--- å¯¹è¯å›é¡¾ç»“æŸ ---]`;
                        historySlice.push({
                            role: 'user',
                            content: contextMessageContent,
                            parts: [{ type: 'text', text: contextMessageContent }]
                        });
                    }
                }
            }
        } catch (error) {
            console.error("æ³¨å…¥ AI åå°èŠå¤©è®°å¿†æ—¶å‡ºé”™:", error);
        }

        // --- [ç‰¹è‰²åŠŸèƒ½ 3]ï¼šæ³¨å…¥åŠ¨æ€ (Moments) ---
        try {
            const character = chat;
            if (typeof getPendingMomentsForRole === 'function') {
                const pendingMoments = await getPendingMomentsForRole(character.id, 3);
                if (pendingMoments && pendingMoments.length > 0) {
                    const momentsData = pendingMoments.map(m => ({
                        id: m.id,
                        author: m.author,
                        text: m.text,
                        imageDesc: m.imageDesc
                    }));
                    const momentsPromptPart = `\n[system-moments: ${JSON.stringify(momentsData)}]`;
                    historySlice.push({
                        role: 'user',
                        content: momentsPromptPart,
                        parts: [{ type: 'text', text: momentsPromptPart }]
                    });
                }
            }
        } catch (e) {
            console.warn('attach pending moments failed', e);
        }

        // --- 5. æ„å»ºè¯·æ±‚ä½“ ---
        const processedHistory = historySlice.map(msg => {
            if (msg.parts && msg.parts.some(p => p.type === 'image')) {
                const textPart = msg.parts.find(p => p.type === 'text');
                const imagePart = msg.parts.find(p => p.type === 'image');
                const base64Match = imagePart.data.match(/^data:(image\/.+);base64,(.*)$/);
                
                if (!base64Match) return { role: msg.role, content: textPart ? textPart.text : '' };
                
                const mimeType = base64Match[1];
                const base64Data = base64Match[2];

                if (provider === 'gemini') {
                    return {
                        role: msg.role,
                        isImageMessage: true,
                        text: textPart ? textPart.text : ' ',
                        mimeType: mimeType,
                        data: base64Data
                    };
                } else if (provider === 'claude') {
                    return {
                        role: msg.role,
                        content: [
                            { type: 'text', text: textPart ? textPart.text : ' ' },
                            { type: 'image', source: { type: 'base64', media_type: mimeType, data: base64Data } }
                        ]
                    };
                } else {
                    return {
                        role: msg.role,
                        content: [
                            { type: 'text', text: textPart ? textPart.text : ' ' },
                            { type: 'image_url', image_url: { url: imagePart.data } }
                        ]
                    };
                }
            } else {
                return { role: msg.role, content: msg.content };
            }
        });

        let endpoint, headers, requestBody;

        // ================== Gemini ä¸“ç”¨é€»è¾‘ ==================
        if (provider === 'gemini') {
            const contents = processedHistory.map(msg => {
                const role = msg.role === 'assistant' ? 'model' : 'user';
                let parts;
                if (msg.isImageMessage) {
                    parts = [
                        { text: msg.text },
                        { inline_data: { mime_type: msg.mimeType, data: msg.data } }
                    ];
                } else {
                    const textVal = typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content);
                    parts = [{ text: textVal }];
                }
                return { role, parts };
            });
            requestBody = {
                contents: contents,
                system_instruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {}
            };
            endpoint = `${url}/v1beta/models/${model}:generateContent?key=${getRandomValue(key)}`;
            headers = { 'Content-Type': 'application/json' };

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
            const data = await response.json();
            let aiText = "";
            if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts) {
                aiText = data.candidates[0].content.parts[0].text;
            }
            if (aiText) {
                await handleAiReplyContent(aiText, chat, chat.id, currentChatType);
            } else {
                throw new Error("Gemini è¿”å›äº†ç©ºå†…å®¹ã€‚");
            }
        }
        // ================== OpenAI / DeepSeek / Claude é€»è¾‘ ==================
        else {
            const messages = [
                { role: 'system', content: systemPrompt },
                ...processedHistory
            ];
            requestBody = {
                model: model,
                messages: messages,
                stream: true
            };
            endpoint = `${url}/v1/chat/completions`;
            headers = {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${getRandomValue(key)}`
            };

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
            
            // ä½¿ç”¨åŸæœ‰çš„æµå¼å¤„ç†å‡½æ•°
            await processStream(response, chat, provider);
        }

    } catch (error) {
        console.error('AI å›å¤å¤±è´¥:', error);
        showToast(`AI å›å¤å¤±è´¥: ${error.message}`);
    } finally {
        isGenerating = false;
        getReplyBtn.disabled = false;
        
        if (chat) {
            const subtitle = document.getElementById('chat-room-subtitle');
            const statusTextElement = document.getElementById('chat-room-status-text');
            if (subtitle && statusTextElement && currentChatType === 'private') {
                subtitle.querySelector('.online-indicator').style.display = 'block';
                // æ¢å¤æ˜¾ç¤ºï¼Œå¦‚æœè¿˜åœ¨æ‹‰é»‘çŠ¶æ€åˆ™æ˜¾ç¤ºè¯·å‹¿æ‰“æ‰°ï¼Œå¦åˆ™æ˜¾ç¤ºåœ¨çº¿
                statusTextElement.textContent = chat.isBlockedByAi ? 'è¯·å‹¿æ‰“æ‰°' : (chat.status || 'åœ¨çº¿');
                statusTextElement.classList.remove('typing-status');
            }
        }
        if (typingIndicator) typingIndicator.style.display = 'none';
    }
}




      // --- æ–°ä»£ç å¼€å§‹ ---
// ===============================================================
// ===============================================================
// START: ä¿®å¤ç‰ˆ V2 - ä¸­å¤®æŒ‡ä»¤å¤„ç†å™¨ (è§£å†³è¿å‘æ¶ˆæ¯è¯†åˆ«é”™è¯¯)
// ===============================================================
// ===============================================================
// START: ä¿®å¤ç‰ˆ V3 - å¸¦ç›‘æ§æ‘„åƒå¤´ä¸å¼ºåŠ›å®¹é”™çš„æŒ‡ä»¤å¤„ç†å™¨
// ===============================================================
// ===============================================================
// START: ä¿®å¤ç‰ˆ V4 - å¸¦ç›‘æ§ä¸æ™ºèƒ½IDå¡«è¡¥çš„æŒ‡ä»¤å¤„ç†å™¨
// ===============================================================
// ===============================================================
// START: ä¿®å¤ç‰ˆ V5 - ä¿®å¤æ•°æ®åº“æŸ¥è¯¢æŠ¥é”™çš„æŒ‡ä»¤å¤„ç†å™¨
// ===============================================================
// START: ä¿®å¤ç‰ˆ processAiCommands (å¢åŠ  HTML æ ¼å¼è§„æ•´é€»è¾‘)
// START: é¢‘ç‡å®šåˆ¶ç‰ˆ processAiCommands (50å¥é—¨æ§›ï¼Œ70%æ¦‚ç‡)
async function processAiCommands(fullResponse, chat) {
    if (!fullResponse || !chat) return "";

    console.log("========== [æ‘„åƒå¤´ 1å·] AIåŸå§‹å›å¤å¼€å§‹ ==========");
    console.log(fullResponse);
    console.log("========== [æ‘„åƒå¤´ 1å·] AIåŸå§‹å›å¤ç»“æŸ ==========");

    let momentsWereModified = false;

    const findAuthor = (rawName) => {
        const cleanName = rawName.trim();
        let author = db.characters.find(c => c.realName === cleanName || c.remarkName === cleanName);
        if (!author && chat && chat.realName) {
            if (cleanName.includes(chat.realName) || cleanName.length > 20) {
                author = chat;
            }
        }
        return author;
    };

    const safeParse = (jsonString) => {
        try {
            return JSON.parse(jsonString);
        } catch (e) {
            try {
                let fixed = jsonString.replace(/[\u201C\u201D]/g, '"').replace(/'/g, '"').replace(/,\s*}/g, '}');
                return JSON.parse(fixed);
            } catch (e2) { return null; }
        }
    };

    const findLatestMomentIdAndCommentId = async (authorId) => {
        if (!window.AppDB_Moments) return { mId: null, cId: null };
        try {
            const allMoments = await window.AppDB_Moments.moments.toArray();
            const authorMoments = allMoments.filter(m => m.authorId === authorId);
            if (authorMoments.length === 0) return { mId: null, cId: null };
            authorMoments.sort((a, b) => b.timestamp - a.timestamp);
            const latestMoment = authorMoments[0];
            let latestCommentId = null;
            if (latestMoment.comments && latestMoment.comments.length > 0) {
                const userComments = latestMoment.comments.filter(c => c.roleId !== authorId); 
                if (userComments.length > 0) {
                    latestCommentId = userComments[userComments.length - 1].id;
                }
            }
            return { mId: latestMoment.id, cId: latestCommentId };
        } catch (err) { return { mId: null, cId: null }; }
    };

    const commandProcessors = {
        'å‘å¸ƒåŠ¨æ€': {
            regex: /\[([^\]]+?)\s*å‘å¸ƒåŠ¨æ€\s*[:ï¼š]\s*(\{[\s\S]*?\})\]/g,
            handler: async (match, authorRealName, jsonData) => {
                try {
                    const author = findAuthor(authorRealName);
                    if (author) {
                        const postData = safeParse(jsonData);
                        if (postData) {
                            const momentObj = {
                                id: 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
                                authorId: author.id,
                                authorAvatar: author.avatar,
                                text: postData.text || '',
                                imageDesc: postData.imageDesc || '',
                                timestamp: Date.now(),
                                commentedBy: [], comments: [], likes: []
                            };
                            if (window.AppDB_Moments) await window.AppDB_Moments.moments.add(momentObj);
                            else if (window.db) window.db.moments.push(momentObj);
                            momentsWereModified = true;
                        }
                    }
                } catch (e) {}
            }
        },
        'ç‚¹èµåŠ¨æ€': {
            regex: /\[([^\]]+?)\s*ç‚¹èµåŠ¨æ€\s*[:ï¼š]\s*(\{[\s\S]*?\})\]/g,
            handler: async (match, authorRealName, jsonData) => {
                try {
                    const author = findAuthor(authorRealName);
                    if (author) {
                        const likeData = safeParse(jsonData);
                        if (likeData && (likeData.momentId === '...' || !likeData.momentId)) {
                             const { mId } = await findLatestMomentIdAndCommentId(author.id);
                             if (mId) likeData.momentId = mId;
                        }
                        if (likeData && likeData.momentId) {
                            await saveMomentLike(likeData.momentId, author.id);
                            momentsWereModified = true;
                        }
                    }
                } catch (e) {}
            }
        },
        'è¯„è®ºåŠ¨æ€': {
            regex: /\[([^\]]+?)\s*è¯„è®ºåŠ¨æ€\s*[:ï¼š]\s*(\{[\s\S]*?\})\]/g,
            handler: async (match, authorRealName, jsonData) => {
                try {
                    const author = findAuthor(authorRealName);
                    if (author) {
                        const commentData = safeParse(jsonData);
                        if (commentData && (commentData.momentId === '...' || !commentData.momentId)) {
                             const { mId } = await findLatestMomentIdAndCommentId(author.id);
                             if (mId) commentData.momentId = mId;
                        }
                        if (commentData && commentData.momentId && commentData.comment) {
                            await saveMomentComment(commentData.momentId, author.id, commentData.comment);
                            momentsWereModified = true;
                        }
                    }
                } catch (e) {}
            }
        },
        'å›å¤è¯„è®º': {
            regex: /\[([^\]]+?)\s*å›å¤è¯„è®º\s*[:ï¼š]\s*(\{[\s\S]*?\})\]/g,
            handler: async (match, authorRealName, jsonData) => {
                try {
                    const author = findAuthor(authorRealName);
                    if (author) {
                        const replyData = safeParse(jsonData);
                        if (replyData && (replyData.momentId === '...' || !replyData.momentId || replyData.commentId === '...' || !replyData.commentId)) {
                             const { mId, cId } = await findLatestMomentIdAndCommentId(author.id);
                             if (mId && cId) {
                                 replyData.momentId = mId;
                                 replyData.commentId = cId;
                             }
                        }
                        if (replyData && replyData.momentId && replyData.commentId && replyData.reply) {
                            await saveAiReplyToComment(replyData.momentId, replyData.commentId, replyData.reply, author.id);
                            momentsWereModified = true;
                        }
                    }
                } catch (e) {}
            }
        }
    };

    for (const key in commandProcessors) {
        const { regex, handler } = commandProcessors[key];
        regex.lastIndex = 0;
        const matches = Array.from(fullResponse.matchAll(regex));
        for (const match of matches) {
            await handler(match[0], match[1], match[2]);
        }
        fullResponse = fullResponse.replace(regex, ''); 
    }
    
    if (momentsWereModified) {
        if (typeof renderMoments === 'function') try { await renderMoments(); } catch (e) {} 
        else if (typeof window.renderMomentsSafe === 'function') try { await window.renderMomentsSafe(); } catch (e) {} 
    }
    
// ğŸ†• æ—¥è®°è§¦å‘æ£€æŸ¥ï¼ˆé‡Œç¨‹ç¢‘æ–¹æ¡ˆï¼‰- æ›¿æ¢æ—§çš„è®¡æ•°å™¨é€»è¾‘
    if (currentChatType === 'private' && chat) {
        checkDiaryTriggerByCheckpoint(chat);
    }

    // è§„æ•´ HTML æ ¼å¼
    if (fullResponse.includes('ai-theater')) {
        if ((fullResponse.match(/<div/g) || []).length > (fullResponse.match(/<\/div>/g) || []).length) {
            fullResponse += '</div>';
        }
        fullResponse = fullResponse.replace(/<div\s+class=["']ai-theater["']\s*(.*?)>/g, '<div class="ai-theater" $1>');
    }

    return fullResponse.trim();
}

// ===============================================================
// END: ä¿®å¤ç‰ˆ V3 - ä¸­å¤®æŒ‡ä»¤å¤„ç†å™¨
// ===============================================================

// ===============================================================
// END: ä¿®å¤ç‰ˆ V2 - ä¸­å¤®æŒ‡ä»¤å¤„ç†å™¨
// ===============================================================
// --- æ–°ä»£ç ç»“æŸ ---
// START: ä¿®å¤ç‰ˆ processStream (æ”¾å®½è½¬è´¦è¯†åˆ«æ¡ä»¶)
// START: å®Œæ•´ä¿®å¤ç‰ˆ processStream (é˜²ä¸²å° + ä¿ç•™æ‰€æœ‰åŠŸèƒ½ + ä¿®å¤è½¬è´¦ç‚¹å‡»)
// â–¼â–¼â–¼ å”¯ä¸€çš„ä¸€æ­¥ï¼šå®Œæ•´æ›¿æ¢ processStream å‡½æ•° (åœ¨è¿™é‡Œæ‹¦æˆª DeepSeek/OpenAI çš„æ‹‰é»‘æŒ‡ä»¤) â–¼â–¼â–¼
// â–¼â–¼â–¼ ä¿®æ­£ç‰ˆ processStream (ä¿®å¤è§£å°åä¸è¯´è¯çš„é—®é¢˜) â–¼â–¼â–¼
// â–¼â–¼â–¼ ç¬¬äºŒæ­¥ï¼šå®Œæ•´æ›¿æ¢ processStream å‡½æ•° (æ–°å¢æ”¹å¤‡æ³¨æ‹¦æˆª) â–¼â–¼â–¼
async function processStream(response, chat, apiType) {
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let fullResponse = "";
    let accumulatedChunk = "";
    let callActionReceived = false;

    // 1. è¯»å–æµæ•°æ®
    for (;;) {
        const { done, value } = await reader.read();
        if (done) break;
        
        accumulatedChunk += decoder.decode(value, { stream: true });
        
        const parts = accumulatedChunk.split("\n\n");
        accumulatedChunk = parts.pop();

        for (const part of parts) {
            if (part.startsWith("data: ")) {
                const data = part.substring(6);
                if (data.trim() === "[DONE]") continue;
                try {
                    const jsonData = JSON.parse(data);
                    let textChunk = "";
                    if (apiType === "gemini") {
                        textChunk = (jsonData.candidates && jsonData.candidates[0] && 
                            jsonData.candidates[0].content && jsonData.candidates[0].content.parts && 
                            jsonData.candidates[0].content.parts[0] && jsonData.candidates[0].content.parts[0].text) || "";
                    } else {
                        textChunk = (jsonData.choices && jsonData.choices[0] && 
                            jsonData.choices[0].delta && jsonData.choices[0].delta.content) || "";
                    }
                    fullResponse += textChunk;
                } catch (e) { }
            }
        }
    }

    // 2. å¤„ç†å®Œæ•´å›å¤
    if (fullResponse) {
        // --- 1. æ‹¦æˆª [keep-blocked] ---
        if (/\[\s*keep-blocked\s*\]/i.test(fullResponse) || fullResponse.includes('keep-blocked')) {
            console.log(`AI (${chat.remarkName}) å†³å®šç»§ç»­ä¿æŒæ‹‰é»‘çŠ¶æ€ã€‚`);
            const systemMsgContent = `[system-display: æ¶ˆæ¯å·²å‘å‡ºï¼Œä½†è¢«å¯¹æ–¹æ‹’æ”¶äº†ã€‚]`;
            const systemMsg = {
                id: `msg_sys_${Date.now()}`, role: 'system', content: systemMsgContent,
                parts: [{ type: 'text', text: systemMsgContent }], timestamp: Date.now()
            };
            chat.history.push(systemMsg);
            await saveData();
            if (currentChatId === chat.id && document.getElementById('chat-room-screen').classList.contains('active')) {
                 if (typeof addMessageBubble === 'function') addMessageBubble(systemMsg);
            }
            return;
        }

        // --- 2. æ‹¦æˆª [unblock-user] ---
        if (/\[\s*unblock-user\s*\]/i.test(fullResponse) || fullResponse.includes('unblock-user')) {
            console.log("æ£€æµ‹åˆ°è§£å°æŒ‡ä»¤ï¼Œæ‰§è¡Œè§£å°...");
            await deactivateAiBlock(chat);
            fullResponse = fullResponse.replace(/\[\s*unblock-user\s*\]/i, '').replace('unblock-user', '').replace('[]', '').trim();
            if (!fullResponse) return;
        }

        // === æ–°å¢ï¼šæ‹¦æˆª [change-user-remark:xxx] ===
        const changeRemarkRegex = /\[change-user-remark:(.*?)\]/;
        const remarkMatch = fullResponse.match(changeRemarkRegex);
        if (remarkMatch) {
            const newRemark = remarkMatch[1].trim();
            if (newRemark) {
                // 1. æ›´æ–°æ•°æ®
                chat.aiAssignedUserRemark = newRemark;
                
                // 2. ç”Ÿæˆç³»ç»Ÿç°æ¡æ¶ˆæ¯
                const systemMsgContent = `[system-display: ${chat.remarkName} å°†ä½ çš„å¤‡æ³¨ä¿®æ”¹ä¸ºâ€œ${newRemark}â€ ]`;
                const systemMsg = {
                    id: `msg_sys_remark_change_${Date.now()}`,
                    role: 'system',
                    content: systemMsgContent,
                    parts: [{ type: 'text', text: systemMsgContent }],
                    timestamp: Date.now()
                };
                chat.history.push(systemMsg);
                
                // 3. ç«‹å³ä¸Šå±ç³»ç»Ÿæ¶ˆæ¯
                if (currentChatId === chat.id && document.getElementById('chat-room-screen').classList.contains('active')) {
                    if (typeof addMessageBubble === 'function') addMessageBubble(systemMsg);
                }
                
                // 4. ä»å›å¤ä¸­ç§»é™¤æŒ‡ä»¤ï¼Œåªä¿ç•™ AI çš„è¯
                fullResponse = fullResponse.replace(remarkMatch[0], '').trim();
                
                // 5. ä¿å­˜
                await saveData();
            }
        }
        // === æ–°å¢ç»“æŸ ===

        // --- 3. æ­£å¸¸å¤„ç†å…¶ä»–å›å¤ ---
        fullResponse = await processAiCommands(fullResponse, chat);

        // --- 1. å¿ƒåŠ¨ç»‘å®šé€»è¾‘ (å®Œæ•´ä¿ç•™) ---
        if (fullResponse.includes('[accept-bond]')) {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) {
                const pendingRequest = character.history.findLast(m => m.bondRequestData && m.bondRequestData.status === 'pending');
                if (pendingRequest) {
                    pendingRequest.bondRequestData.status = 'accepted';
                }
                // ä½¿ç”¨ä¼´ä¾£åå†Œç®¡ç†æœºåˆ¶
                const roster = updateBondRoster(character.id, 'add');
                
                if (roster.length === 2) {
                    // å¦‚æœåå†Œå·²æ»¡ï¼ˆ2ä¸ªè§’è‰²ï¼‰ï¼Œæ‰¾åˆ°å¦ä¸€ä¸ªè§’è‰²å¹¶ä¼‘çœ 
                    const otherCharId = roster.find(id => id !== character.id);
                    const otherCharacter = db.characters.find(c => c.id === otherCharId);
                    if (otherCharacter) {
                        otherCharacter.isSoulBound = false; // ä¼‘çœ ï¼Œä½†ä¿ç•™ soulBondStatus ä¸º 'active'
                        // æ³¨æ„ï¼šæˆ‘ä»¬ä¸æ”¹å˜ otherCharacter.soulBondStatusï¼Œä¿æŒä¸º 'active'
                    }
                } else {
                    // å¦‚æœåå†Œæœªæ»¡ï¼Œå°†æ‰€æœ‰å…¶ä»–è§’è‰²è§£ç»‘ï¼ˆæ¸…é™¤ç»‘å®šçŠ¶æ€ï¼‰
                    db.characters.forEach(c => {
                        if (c.id !== character.id) {
                            c.isSoulBound = false;
                            c.soulBondStatus = 'none';
                        }
                    });
                }
                
                character.isSoulBound = true;
                character.soulBondStatus = 'active';
                const displayMsg = {
                    id: `msg_bond_disp_${Date.now()}`,
                    role: 'system',
                    content: `[system-display:${character.remarkName} åŒæ„äº†ä½ çš„å¿ƒåŠ¨ç»‘å®šè¯·æ±‚ï¼ç°åœ¨ä½ ä»¬å¯ä»¥ä¸€èµ·ä½“éªŒä¸“å±åŠŸèƒ½äº†ã€‚]`,
                    parts: [],
                    timestamp: Date.now()
                };
                const contextMsg = {
                    id: `msg_bond_ctx_${Date.now()}`,
                    role: 'user',
                    content: `[system: ä½ åˆšåˆšåŒæ„äº†ç»‘å®šè¯·æ±‚ã€‚è¯·è¯´ä¸€å¥ç¬¦åˆäººè®¾çš„ã€è¡¨è¾¾å–œæ‚¦æˆ–ç¡®è®¤å…³ç³»çš„è¯ã€‚]`,
                    parts: [{
                        type: 'text',
                        text: `[system: ä½ åˆšåˆšåŒæ„äº†ç»‘å®šè¯·æ±‚ã€‚è¯·è¯´ä¸€å¥ç¬¦åˆäººè®¾çš„ã€è¡¨è¾¾å–œæ‚¦æˆ–ç¡®è®¤å…³ç³»çš„è¯ã€‚]`
                    }],
                    timestamp: Date.now()
                };
                character.history.push(displayMsg, contextMsg);
                await saveData();
                
                // åªæœ‰å½“å‰æ­£åœ¨çœ‹è¿™ä¸ªçª—å£æ—¶æ‰åˆ·æ–°UI
                if (currentChatId === chat.id) {
                    renderMessages(false, true);
                    showToast('ç»‘å®šæˆåŠŸï¼');
                    getAiReply();
                    hideTypingIndicator();
                }
                return;
            }
        }
        if (fullResponse.includes('[decline-bond]')) {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) {
                const pendingRequest = character.history.findLast(m => m.bondRequestData && m.bondRequestData.status === 'pending');
                if (pendingRequest) {
                    pendingRequest.bondRequestData.status = 'declined';
                }
                character.soulBondStatus = 'none';
                const displayMsg = {
                    id: `msg_bond_disp_${Date.now()}`,
                    role: 'system',
                    content: `[system-display:${character.remarkName} æ‹’ç»äº†ä½ çš„ç»‘å®šè¯·æ±‚ã€‚]`,
                    parts: [],
                    timestamp: Date.now()
                };
                const contextMsg = {
                    id: `msg_bond_ctx_${Date.now()}`,
                    role: 'user',
                    content: `[system: ä½ åˆšåˆšæ‹’ç»äº†ç»‘å®šè¯·æ±‚ã€‚è¯·è¯´ä¸€å¥ç¬¦åˆäººè®¾çš„ã€å§”å©‰çš„æ‹’ç»ç†ç”±ã€‚]`,
                    parts: [{
                        type: 'text',
                        text: `[system: ä½ åˆšåˆšæ‹’ç»äº†ç»‘å®šè¯·æ±‚ã€‚è¯·è¯´ä¸€å¥ç¬¦åˆäººè®¾çš„ã€å§”å©‰çš„æ‹’ç»ç†ç”±ã€‚]`
                    }],
                    timestamp: Date.now()
                };
                character.history.push(displayMsg, contextMsg);
                await saveData();
                
                if (currentChatId === chat.id) {
                    renderMessages(false, true);
                    showToast('å¯¹æ–¹æ‹’ç»äº†ä½ çš„é‚€è¯·');
                    getAiReply();
                    hideTypingIndicator();
                }
                return;
            }
        }
        if (fullResponse.includes('[request-bond]')) {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) {
                character.soulBondStatus = 'pending_by_ai';
                const bondRequestMessage = {
                    id: `msg_bond_req_card_${Date.now()}`,
                    role: 'assistant',
                    content: `[${character.realName}å‘ä½ å‘èµ·äº†å¿ƒåŠ¨ç»‘å®šé‚€è¯·]`,
                    parts: [],
                    timestamp: Date.now(),
                    bondRequestData: {
                        status: 'pending'
                    }
                };
                character.history.push(bondRequestMessage);
                await saveData();
                
                if (currentChatId === chat.id) {
                    renderMessages(false, true);
                    showToast(`${character.remarkName} å‘ä½ å‘èµ·äº†å¿ƒåŠ¨ç»‘å®šï¼`);
                } else {
                    addNotificationToQueue({
                        avatar: character.avatar,
                        text: `<strong>${character.remarkName}</strong><br>å‘èµ·äº†å¿ƒåŠ¨ç»‘å®šé‚€è¯·`,
                        chatId: character.id,
                        type: 'private'
                    });
                }
            }
            if (currentChatId === chat.id) hideTypingIndicator();
            return;
        }

        // --- 2. æ”¯ä»˜æŒ‡ä»¤é€»è¾‘ (å®Œæ•´ä¿ç•™) ---
        if (fullResponse.includes('[accept-payment]')) {
            const lastRequest = chat.history.findLast(m => m.paymentRequestData?.status === 'pending');
            if (lastRequest) {
                handleAiPaymentDecision(lastRequest.id, 'paid');
            }
            if (currentChatId === chat.id) hideTypingIndicator();
            return;
        } else if (fullResponse.includes('[decline-payment]')) {
            const lastRequest = chat.history.findLast(m => m.paymentRequestData?.status === 'pending');
            if (lastRequest) {
                handleAiPaymentDecision(lastRequest.id, 'declined');
            }
            if (currentChatId === chat.id) hideTypingIndicator();
            return;
        }

        // --- 3. æ’¤å›æ¶ˆæ¯é€»è¾‘ (å®Œæ•´ä¿ç•™) ---
        const recallRegex = /\[send_and_recall:({.*?})\]/g;
        const recallMatch = recallRegex.exec(fullResponse);
        if (recallMatch) {
            try {
                const recallData = JSON.parse(recallMatch[1]);
                const messageToSend = {
                    id: `msg_recalled_${Date.now()}`,
                    role: 'assistant',
                    content: recallData.message,
                    parts: [{
                        type: 'text',
                        text: recallData.message
                    }],
                    timestamp: Date.now(),
                    isRecalling: true
                };
                chat.history.push(messageToSend);
                
                // åªæœ‰å½“å‰çª—å£åŒ¹é…æ—¶æ‰æ˜¾ç¤º
                if (currentChatId === chat.id && document.getElementById('chat-room-screen').classList.contains('active')) {
                    addMessageBubble(messageToSend);
                }

                await saveData();
                renderChatList();

                setTimeout(async () => {
                    const msgIndex = chat.history.findIndex(m => m.id === messageToSend.id);
                    if (msgIndex > -1) {
                        chat.history[msgIndex].recalled = true;
                        chat.history[msgIndex].recalledBy = 'ai';
                        chat.history[msgIndex].originalContent = chat.history[msgIndex].content;
                        delete chat.history[msgIndex].isRecalling;
                        await saveData();
                        if (currentChatId === chat.id) renderMessages(false, true);
                    }
                }, 1500);

            } catch (e) {
                console.error("è§£æAIæ’¤å›æŒ‡ä»¤å¤±è´¥:", e);
            }
            if (currentChatId === chat.id) hideTypingIndicator();
            return;
        }

        // --- 4. é€šè¯/æŒ‚æ–­é€»è¾‘ (å®Œæ•´ä¿ç•™) ---
        if (fullResponse.includes('[call-accept]')) {
            callActionReceived = true;
            startActiveCall();
            return;
        }
        if (fullResponse.includes('[call-decline]')) {
            callActionReceived = true;
            showToast(`${chat.remarkName} æ‹’æ¥äº†ä½ çš„é€šè¯`);
            endCall('declined');
            return;
        }
        if (fullResponse.includes('[hangup]')) {
            endCall('ended');
            return;
        }
        if (isVoiceCallActive) {
            appendCallTranscript("ai", fullResponse);
            return;
        }

        // --- 5. æ‹‰é»‘é€»è¾‘ (å®Œæ•´ä¿ç•™) ---
        if (currentChatType === 'private') {
            if (fullResponse.includes('[block-user]')) {
                activateAiBlock(chat);
                return;
            }
            if (fullResponse.includes('[unblock-user]')) {
                deactivateAiBlock(chat);
                return;
            }
        }

        // --- 6. æ ¸å¿ƒæ¶ˆæ¯å¤„ç† (åŒ…å«é˜²ä¸²å°ä¿®å¤) ---
        const receivedTransferRegex = /\[.*?çš„è½¬è´¦ï¼š.*?å…ƒï¼›å¤‡æ³¨ï¼š.*?\]/;
        const giftRegex = /\[.*?é€æ¥çš„ç¤¼ç‰©ï¼š.*?\]/;

        let momentsWereAdded = false;

        // å¤„ç†åŠ¨æ€æŒ‡ä»¤
        // (æ³¨ï¼šprocessAiCommands å·²ç»å¤„ç†äº†æ•°æ®å…¥åº“ï¼Œè¿™é‡Œä¸»è¦æ˜¯ä¸ºäº†åˆ·æ–°UIæ ‡è®°)
        if (fullResponse.includes('å‘å¸ƒåŠ¨æ€') || fullResponse.includes('ç‚¹èµ') || fullResponse.includes('è¯„è®º')) {
            momentsWereAdded = true;
        }

        // æ‹†åˆ†æ¶ˆæ¯å¹¶æ˜¾ç¤º
        const messages = getMixedContent(fullResponse).filter(item => item.content.trim() !== '');
        let firstMessageProcessed = false;
        let hasNotified = false; // ç”¨äºæ§åˆ¶æœ¬æ¬¡å›å¤åªå¼¹ä¸€æ¬¡çª—

        for (const item of messages) {
            const delay = firstMessageProcessed ? (600 + Math.random() * 600) : (500 + Math.random() * 500);
            await new Promise(resolve => setTimeout(resolve, delay));
            firstMessageProcessed = true;

            if (currentChatType === 'private') {
                const character = chat;
                const message = {
                    id: `msg_${Date.now()}_${Math.random()}`,
                    role: 'assistant',
                    content: item.content.trim(),
                    parts: [{
                        type: item.type,
                        text: item.content.trim()
                    }],
                    timestamp: Date.now(),
                };

                // è®¾ç½®è½¬è´¦/ç¤¼ç‰©çŠ¶æ€
                if (receivedTransferRegex.test(message.content)) {
                    message.transferStatus = 'pending';
                } else if (giftRegex.test(message.content)) {
                    message.giftStatus = 'sent';
                }

                // å­˜å…¥å†å²
                chat.history.push(message);
                
                // === [å…³é”®ä¿®å¤] é˜²ä¸²å°é€»è¾‘ ===
                // åªæœ‰å½“ å½“å‰æ‰“å¼€çš„èŠå¤©ID ç­‰äº æ­£åœ¨å›å¤çš„AI ID æ—¶ï¼Œæ‰ä¸Šå±
                if (currentChatId === chat.id && document.getElementById('chat-room-screen').classList.contains('active')) {
                    addMessageBubble(message);
                } else {
                    // å¦åˆ™ï¼Œå¦‚æœæ˜¯åå°æ¶ˆæ¯ï¼Œä¸”è¿˜æ²¡å¼¹çª—è¿‡ï¼Œå°±å¼¹çª—æç¤º
                    if (!hasNotified) {
                         addNotificationToQueue({
                            avatar: chat.avatar,
                            text: `<strong>${chat.remarkName}</strong><br>å‘æ¥äº†æ–°æ¶ˆæ¯`,
                            chatId: chat.id,
                            type: 'private'
                        });
                        hasNotified = true;
                    }
                }
            }

            if (currentChatType === 'group' || (chat.members && chat.members.length > 0)) {
                const group = chat;
                let r = /\[(.*?)((?:çš„æ¶ˆæ¯|çš„è¯­éŸ³|å‘é€çš„è¡¨æƒ…åŒ…|å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘))ï¼š/;
                const nameMatch = item.content.match(r);
                if (nameMatch || item.char) {
                    const senderName = item.char || (nameMatch[1]);
                    const sender = group.members.find(m => (m.realName === senderName || m.groupNickname === senderName));
                    if (sender) {
                        const message = {
                            id: `msg_${Date.now()}_${Math.random()}`,
                            role: 'assistant',
                            content: item.content.trim(),
                            parts: [{
                                type: item.type,
                                text: item.content.trim()
                            }],
                            timestamp: Date.now(),
                            senderId: sender.id
                        };
                        
                        group.history.push(message);
                        
                        // === [å…³é”®ä¿®å¤] ç¾¤èŠé˜²ä¸²å°é€»è¾‘ ===
                        if (currentChatId === chat.id && document.getElementById('chat-room-screen').classList.contains('active')) {
                            addMessageBubble(message);
                        } else {
                             if (!hasNotified) {
                                addNotificationToQueue({
                                    avatar: chat.avatar,
                                    text: `<strong>${chat.name}</strong><br>æœ‰æ–°æ¶ˆæ¯`,
                                    chatId: chat.id,
                                    type: 'group'
                                });
                                hasNotified = true;
                            }
                        }
                    }
                }
            }
        }

        if (currentChatId === chat.id) {
            hideTypingIndicator();
        }

        // ğŸ†• æ—¥è®°è§¦å‘æ£€æŸ¥ï¼ˆé‡Œç¨‹ç¢‘æ–¹æ¡ˆï¼‰- æ›¿æ¢æ—§çš„è®¡æ•°å™¨é€»è¾‘
        if (chat.members === undefined) { // ç§èŠï¼ˆæ²¡æœ‰ members å±æ€§ï¼‰
            checkDiaryTriggerByCheckpoint(chat);
        }

        if (chat.povCache) chat.povCache = null;
        await saveData();
        renderChatList();
        
        if (momentsWereAdded) {
            if (typeof renderMoments === 'function') {
                try { await renderMoments(); } catch (e) {}
            } else if (typeof window.renderMomentsSafe === 'function') {
                try { await window.renderMomentsSafe(); } catch (e) {}
            }
        }
    } else {
        if (currentChatId === chat.id) hideTypingIndicator();
    }

    if (isCallRinging && !callActionReceived) {
        showToast('å¯¹æ–¹æ— åº”ç­”');
        endCall('no_action_reply');
        if (currentChatId === chat.id) hideTypingIndicator();
    }
}

        // --- Other Sub-systems Setup (Stickers, Voice, etc.) ---
        function setupImageRecognition() {
            imageRecognitionBtn.addEventListener('click', () => {
                imageUploadInput.click();
            });
            imageUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.8,
                            maxWidth: 1024,
                            maxHeight: 1024
                        });
                        sendImageForRecognition(compressedUrl);
                    } catch (error) {
                        console.error('Image compression failed:', error);
                        showToast('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                    } finally {
                        e.target.value = null;
                    }
                }
            });
        }

        async function setupStickerSystem() {
            // ğŸ†• è·å–æ–°çš„ UI å…ƒç´ ï¼ˆæ·»åŠ å®‰å…¨æ£€æŸ¥ï¼‰
            const stickerMenuBtn = document.getElementById('sticker-menu-btn');
            const stickerMenuActionSheet = document.getElementById('sticker-menu-action-sheet');
            const stickerMenuBackdrop = document.getElementById('sticker-menu-backdrop');
            const menuMultiSelectBtn = document.getElementById('menu-multi-select-btn');
            const menuBatchImportBtn = document.getElementById('menu-batch-import-btn');
            const menuAddNewBtn = document.getElementById('menu-add-new-btn');
            const menuCancelBtn = document.getElementById('menu-cancel-btn');
            const stickerGroupInput = document.getElementById('sticker-group-input');
            
            // ğŸ›¡ï¸ å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœæ ¸å¿ƒå…ƒç´ ä¸å­˜åœ¨ï¼Œè¾“å‡ºè­¦å‘Šå¹¶è¿”å›
            if (!stickerModal) {
                console.warn('âš ï¸ setupStickerSystem: stickerModal å…ƒç´ æœªæ‰¾åˆ°');
                return;
            }
            if (!stickerToggleBtn) {
                console.warn('âš ï¸ setupStickerSystem: stickerToggleBtn å…ƒç´ æœªæ‰¾åˆ°');
                return;
            }
            
            // è¡¨æƒ…åŒ…å¼¹çª—å¼€å…³
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerTabs(); // ğŸ†• æ¸²æŸ“åˆ†ç»„æ ‡ç­¾
                    renderStickerGrid();
                }
            });
            
            // ğŸ†• æ‰“å¼€å³ä¸Šè§’èœå•ï¼ˆæ·»åŠ å®Œæ•´å®‰å…¨æ£€æŸ¥ï¼‰
            if (stickerMenuBtn && stickerMenuActionSheet) {
                stickerMenuBtn.addEventListener('click', () => {
                    stickerMenuActionSheet.classList.add('visible');
                });
            }
            
            // ğŸ†• å…³é—­èœå•ï¼ˆç‚¹å‡»é®ç½©æˆ–å–æ¶ˆæŒ‰é’®ï¼‰
            if (stickerMenuBackdrop && stickerMenuActionSheet) {
                stickerMenuBackdrop.addEventListener('click', () => {
                    stickerMenuActionSheet.classList.remove('visible');
                });
            }
            if (menuCancelBtn && stickerMenuActionSheet) {
                menuCancelBtn.addEventListener('click', () => {
                    stickerMenuActionSheet.classList.remove('visible');
                });
            }
            
            // ğŸ†• èœå•é¡¹ï¼šå¤šé€‰ç®¡ç†
            if (menuMultiSelectBtn && stickerMenuActionSheet) {
                menuMultiSelectBtn.addEventListener('click', () => {
                    stickerMenuActionSheet.classList.remove('visible');
                    enterStickerSelectionMode(); // è¿›å…¥å¤šé€‰æ¨¡å¼
                });
            }
            
            // ğŸ†• èœå•é¡¹ï¼šæ‰¹é‡å¯¼å…¥
            if (menuBatchImportBtn && stickerMenuActionSheet) {
                menuBatchImportBtn.addEventListener('click', () => {
                    stickerMenuActionSheet.classList.remove('visible');
                    updateGroupSuggestions(); // ğŸ†• æ›´æ–°åˆ†ç»„å»ºè®®
                    const batchModal = document.getElementById('batch-add-sticker-modal');
                    if (batchModal) {
                        batchModal.classList.add('visible');
                    }
                });
            }
            
            // ğŸ†• èœå•é¡¹ï¼šæ·»åŠ æ–°è¡¨æƒ…
            if (menuAddNewBtn && stickerMenuActionSheet) {
                menuAddNewBtn.addEventListener('click', () => {
                    stickerMenuActionSheet.classList.remove('visible');
                    if (addStickerModalTitle) addStickerModalTitle.textContent = 'æ·»åŠ æ–°è¡¨æƒ…';
                    if (addStickerForm) addStickerForm.reset();
                    if (stickerEditIdInput) stickerEditIdInput.value = '';
                    if (stickerPreview) stickerPreview.innerHTML = '<span>é¢„è§ˆ</span>';
                    if (stickerUrlInput) stickerUrlInput.disabled = false;
                    updateGroupSuggestions(); // ğŸ†• æ›´æ–°åˆ†ç»„å»ºè®®
                    if (addStickerModal) addStickerModal.classList.add('visible');
                });
            }
            
            // åŸæœ‰çš„æ·»åŠ æŒ‰é’®ï¼ˆä¿ç•™ï¼Œé˜²æ­¢å…¶ä»–åœ°æ–¹è°ƒç”¨ï¼‰
            if (addNewStickerBtn) {
                addNewStickerBtn.addEventListener('click', () => {
                    if (addStickerModalTitle) addStickerModalTitle.textContent = 'æ·»åŠ æ–°è¡¨æƒ…';
                    if (addStickerForm) addStickerForm.reset();
                    if (stickerEditIdInput) stickerEditIdInput.value = '';
                    if (stickerPreview) stickerPreview.innerHTML = '<span>é¢„è§ˆ</span>';
                    if (stickerUrlInput) stickerUrlInput.disabled = false;
                    updateGroupSuggestions(); // ğŸ†• æ›´æ–°åˆ†ç»„å»ºè®®
                    if (addStickerModal) addStickerModal.classList.add('visible');
                });
            }
            
            // ğŸ†• ä¿®æ”¹ï¼šæ·»åŠ /ç¼–è¾‘è¡¨æƒ…æ—¶æ”¯æŒåˆ†ç»„
            if (addStickerForm) {
                addStickerForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    
                    if (!stickerNameInput) {
                        return showToast('è¡¨å•å…ƒç´ æœªåŠ è½½');
                    }
                    
                    const name = stickerNameInput.value.trim();
                    const group = stickerGroupInput ? stickerGroupInput.value.trim() : null; // ğŸ†• è·å–åˆ†ç»„
                    const id = stickerEditIdInput ? stickerEditIdInput.value : '';
                    const previewImg = stickerPreview ? stickerPreview.querySelector('img') : null;
                    const data = previewImg ? previewImg.src : null;
                    
                    if (!name || !data) {
                        return showToast('è¯·å¡«å†™è¡¨æƒ…åç§°å¹¶æä¾›å›¾ç‰‡');
                    }
                    
                    const stickerData = {
                        name, 
                        data,
                        group: group || null, // ğŸ†• ä¿å­˜åˆ†ç»„ï¼ˆç©ºå€¼ä¸º nullï¼‰
                        lastUsedTime: Date.now() // ğŸ†• è®°å½•æ—¶é—´
                    };
                    
                    if (id) {
                        // ç¼–è¾‘ç°æœ‰è¡¨æƒ…
                        const index = db.myStickers.findIndex(s => s.id === id);
                        if (index > -1) {
                            db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                        }
                    } else {
                        // æ–°å¢è¡¨æƒ…
                        stickerData.id = `sticker_${Date.now()}`;
                        db.myStickers.push(stickerData);
                    }
                    
                    await saveData();
                    renderStickerTabs(); // ğŸ†• é‡æ–°æ¸²æŸ“æ ‡ç­¾
                    renderStickerGrid();
                    if (addStickerModal) addStickerModal.classList.remove('visible');
                    showToast('è¡¨æƒ…åŒ…å·²ä¿å­˜');
                });
            }
            
            if (stickerUrlInput) {
                stickerUrlInput.addEventListener('input', (e) => {
                    if (stickerPreview) stickerPreview.innerHTML = `<img src="${e.target.value}" alt="é¢„è§ˆ">`;
                    if (stickerFileUpload) stickerFileUpload.value = '';
                });
            }
            
            if (stickerFileUpload) {
                stickerFileUpload.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        try {
                            const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                            if (stickerPreview) stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="é¢„è§ˆ">`;
                            if (stickerUrlInput) {
                                stickerUrlInput.value = '';
                                stickerUrlInput.disabled = true;
                            }
                        } catch (error) {
                            console.error('è¡¨æƒ…åŒ…å‹ç¼©å¤±è´¥:', error);
                            showToast('è¡¨æƒ…åŒ…å‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                        }
                    }
                });
            }
            
            if (editStickerBtn) {
                editStickerBtn.addEventListener('click', () => {
                    if (!currentStickerActionTarget) return;
                    const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                    if (sticker) {
                        if (addStickerModalTitle) addStickerModalTitle.textContent = 'ç¼–è¾‘è¡¨æƒ…';
                        if (stickerEditIdInput) stickerEditIdInput.value = sticker.id;
                        if (stickerNameInput) stickerNameInput.value = sticker.name;
                        if (stickerPreview) stickerPreview.innerHTML = `<img src="${sticker.data}" alt="é¢„è§ˆ">`;
                        
                        // ğŸ†• æ›´æ–°åˆ†ç»„å»ºè®®å¹¶å›æ˜¾åˆ†ç»„ä¿¡æ¯
                        updateGroupSuggestions();
                        if (stickerGroupInput) {
                            stickerGroupInput.value = sticker.group || '';
                        }
                        
                        if (stickerUrlInput) {
                            if (sticker.data.startsWith('http')) {
                                stickerUrlInput.value = sticker.data;
                                stickerUrlInput.disabled = false;
                            } else {
                                stickerUrlInput.value = '';
                                stickerUrlInput.disabled = true;
                            }
                        }
                        if (addStickerModal) addStickerModal.classList.add('visible');
                    }
                    if (stickerActionSheet) stickerActionSheet.classList.remove('visible');
                    currentStickerActionTarget = null;
                });
            }
            
            if (deleteStickerBtn) {
                deleteStickerBtn.addEventListener('click', async () => {
                    if (!currentStickerActionTarget) return;
                    const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                    if (sticker) {
                        if (confirm(`ç¡®å®šè¦åˆ é™¤è¡¨æƒ…"${sticker.name}"å—ï¼Ÿ`)) {
                            db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                            await saveData();
                            renderStickerTabs(); // ğŸ†• é‡æ–°æ¸²æŸ“æ ‡ç­¾ï¼ˆåˆ é™¤ååˆ†ç»„å¯èƒ½å˜åŒ–ï¼‰
                            renderStickerGrid();
                            showToast('è¡¨æƒ…å·²åˆ é™¤');
                        }
                    }
                    if (stickerActionSheet) stickerActionSheet.classList.remove('visible');
                    currentStickerActionTarget = null;
                });
            }
            
            // ===== ğŸ†• å¤šé€‰ç®¡ç†åº•éƒ¨æ“ä½œæ æŒ‰é’® =====
            const selectAllStickersBtn = document.getElementById('select-all-stickers-btn');
            const exitSelectionBtn = document.getElementById('exit-selection-mode-btn');
            const moveSelectedBtn = document.getElementById('move-selected-stickers-btn');
            const deleteSelectedBtn = document.getElementById('delete-selected-stickers-btn');
            
            // ğŸ†• æ™ºèƒ½å…¨é€‰/åé€‰å½“å‰è§†å›¾
            if (selectAllStickersBtn) {
                selectAllStickersBtn.addEventListener('click', () => {
                    toggleSelectAllCurrentStickers();
                });
            }
            
            // é€€å‡ºé€‰æ‹©æ¨¡å¼
            if (exitSelectionBtn) {
                exitSelectionBtn.addEventListener('click', () => {
                    exitStickerSelectionMode();
                });
            }
            
            // ç§»åŠ¨åˆ°åˆ†ç»„
            if (moveSelectedBtn) {
                moveSelectedBtn.addEventListener('click', () => {
                    moveSelectedStickersToGroup();
                });
            }
            
            // æ‰¹é‡åˆ é™¤
            if (deleteSelectedBtn) {
                deleteSelectedBtn.addEventListener('click', () => {
                    deleteSelectedStickers();
                });
            }
            
            // ç§»åŠ¨åˆ†ç»„å¼¹çª—çš„æŒ‰é’®
            const cancelMoveBtn = document.getElementById('cancel-move-stickers-btn');
            const confirmMoveBtn = document.getElementById('confirm-move-stickers-btn');
            const moveModal = document.getElementById('move-stickers-modal');
            
            if (cancelMoveBtn && moveModal) {
                cancelMoveBtn.addEventListener('click', () => {
                    moveModal.classList.remove('visible');
                });
            }
            
            if (confirmMoveBtn) {
                confirmMoveBtn.addEventListener('click', () => {
                    confirmMoveStickers();
                });
            }
            
            // ç‚¹å‡»ç§»åŠ¨å¼¹çª—é®ç½©å…³é—­
            if (moveModal) {
                moveModal.addEventListener('click', (e) => {
                    if (e.target === moveModal) {
                        moveModal.classList.remove('visible');
                    }
                });
            }
        }

        // ===== ğŸ†• å¤šé€‰ç®¡ç†åŠŸèƒ½ =====
        
        // è¿›å…¥å¤šé€‰æ¨¡å¼
        function enterStickerSelectionMode() {
            isStickerSelectionMode = true;
            selectedStickerIds.clear();
            
            const stickerModalElement = document.getElementById('sticker-modal');
            if (stickerModalElement) {
                stickerModalElement.classList.add('selection-mode');
            }
            
            // é‡æ–°æ¸²æŸ“ç½‘æ ¼ä»¥æ˜¾ç¤ºå¤é€‰æ¡†
            renderStickerGrid();
            updateSelectionCount();
            updateSelectAllButtonState(); // ğŸ†• åˆå§‹åŒ–å…¨é€‰æŒ‰é’®çŠ¶æ€
            
            console.log('âœ… è¿›å…¥å¤šé€‰æ¨¡å¼');
        }
        
        // é€€å‡ºå¤šé€‰æ¨¡å¼
        function exitStickerSelectionMode() {
            isStickerSelectionMode = false;
            selectedStickerIds.clear();
            
            const stickerModalElement = document.getElementById('sticker-modal');
            if (stickerModalElement) {
                stickerModalElement.classList.remove('selection-mode');
            }
            
            // é‡æ–°æ¸²æŸ“ç½‘æ ¼ä»¥éšè—å¤é€‰æ¡†
            renderStickerGrid();
            
            console.log('âœ… é€€å‡ºå¤šé€‰æ¨¡å¼');
        }
        
        // åˆ‡æ¢è¡¨æƒ…é€‰ä¸­çŠ¶æ€
        function toggleStickerSelection(stickerId) {
            if (selectedStickerIds.has(stickerId)) {
                selectedStickerIds.delete(stickerId);
            } else {
                selectedStickerIds.add(stickerId);
            }
            updateSelectionCount(); // è¿™ä¸ªå‡½æ•°å†…éƒ¨ä¼šè°ƒç”¨ updateSelectAllButtonState()
            
            // æ›´æ–°å•ä¸ªè¡¨æƒ…é¡¹çš„è§†è§‰çŠ¶æ€
            const item = document.querySelector(`.sticker-item[data-sticker-id="${stickerId}"]`);
            if (item) {
                if (selectedStickerIds.has(stickerId)) {
                    item.classList.add('selected');
                } else {
                    item.classList.remove('selected');
                }
            }
        }
        
        // æ›´æ–°é€‰ä¸­æ•°é‡æ˜¾ç¤º
        function updateSelectionCount() {
            const countElement = document.getElementById('selected-sticker-count');
            if (countElement) {
                countElement.textContent = `å·²é€‰ ${selectedStickerIds.size} é¡¹`;
            }
            
            // ğŸ†• æ›´æ–°å…¨é€‰æŒ‰é’®çš„æ–‡å­—å’ŒçŠ¶æ€
            updateSelectAllButtonState();
        }
        
        // ğŸ†• æ›´æ–°å…¨é€‰æŒ‰é’®çš„æ–‡å­—çŠ¶æ€
        function updateSelectAllButtonState() {
            const selectAllBtn = document.getElementById('select-all-stickers-btn');
            if (!selectAllBtn) return;
            
            const currentStickers = getCurrentlyDisplayedStickers();
            if (currentStickers.length === 0) {
                selectAllBtn.disabled = true;
                selectAllBtn.style.opacity = '0.5';
                return;
            }
            
            selectAllBtn.disabled = false;
            selectAllBtn.style.opacity = '1';
            
            // æ£€æŸ¥å½“å‰è§†å›¾æ˜¯å¦å·²å…¨é€‰
            const currentStickerIds = currentStickers.map(s => s.id);
            const allSelected = currentStickerIds.every(id => selectedStickerIds.has(id));
            
            const btnText = selectAllBtn.querySelector('span');
            if (btnText) {
                btnText.textContent = allSelected ? 'å–æ¶ˆ' : 'å…¨é€‰';
            }
        }
        
        // ğŸ†• è·å–å½“å‰æ˜¾ç¤ºçš„è¡¨æƒ…åˆ—è¡¨ï¼ˆæ ¹æ®å½“å‰æ ‡ç­¾ç­›é€‰ï¼‰
        function getCurrentlyDisplayedStickers() {
            let stickersToShow = [];
            if (currentStickerCategory === 'all') {
                stickersToShow = [...db.myStickers];
            } else if (currentStickerCategory === 'uncategorized') {
                stickersToShow = db.myStickers.filter(s => !s.group || s.group.trim() === '');
            } else {
                stickersToShow = db.myStickers.filter(s => s.group === currentStickerCategory);
            }
            return stickersToShow;
        }
        
        // ğŸ†• æ™ºèƒ½å…¨é€‰/åé€‰ï¼ˆToggleï¼‰å½“å‰è§†å›¾çš„è¡¨æƒ…
        function toggleSelectAllCurrentStickers() {
            const currentStickers = getCurrentlyDisplayedStickers();
            
            if (currentStickers.length === 0) {
                showToast('å½“å‰åˆ†ç»„æ²¡æœ‰è¡¨æƒ…');
                return;
            }
            
            // æ£€æŸ¥å½“å‰æ˜¾ç¤ºçš„è¡¨æƒ…æ˜¯å¦å·²å…¨éƒ¨é€‰ä¸­
            const currentStickerIds = currentStickers.map(s => s.id);
            const allSelected = currentStickerIds.every(id => selectedStickerIds.has(id));
            
            if (allSelected) {
                // æƒ…å†µ Bï¼šå·²å…¨é€‰ â†’ å–æ¶ˆé€‰ä¸­å½“å‰è§†å›¾çš„æ‰€æœ‰è¡¨æƒ…
                currentStickerIds.forEach(id => {
                    selectedStickerIds.delete(id);
                    const item = document.querySelector(`.sticker-item[data-sticker-id="${id}"]`);
                    if (item) item.classList.remove('selected');
                });
                console.log(`âœ… å–æ¶ˆé€‰ä¸­å½“å‰è§†å›¾çš„ ${currentStickerIds.length} ä¸ªè¡¨æƒ…`);
                showToast(`å·²å–æ¶ˆé€‰ä¸­ ${currentStickerIds.length} é¡¹`);
            } else {
                // æƒ…å†µ Aï¼šæœªå…¨é€‰ â†’ é€‰ä¸­å½“å‰è§†å›¾çš„æ‰€æœ‰è¡¨æƒ…
                currentStickerIds.forEach(id => {
                    selectedStickerIds.add(id);
                    const item = document.querySelector(`.sticker-item[data-sticker-id="${id}"]`);
                    if (item) item.classList.add('selected');
                });
                console.log(`âœ… é€‰ä¸­å½“å‰è§†å›¾çš„ ${currentStickerIds.length} ä¸ªè¡¨æƒ…`);
                showToast(`å·²å…¨é€‰ ${currentStickerIds.length} é¡¹`);
            }
            
            // æ›´æ–°é€‰ä¸­æ•°é‡æ˜¾ç¤º
            updateSelectionCount();
        }
        
        // æ‰¹é‡ç§»åŠ¨åˆ°æŒ‡å®šåˆ†ç»„
        async function moveSelectedStickersToGroup() {
            if (selectedStickerIds.size === 0) {
                showToast('è¯·å…ˆé€‰æ‹©è¦ç§»åŠ¨çš„è¡¨æƒ…');
                return;
            }
            
            // æ‰“å¼€ç§»åŠ¨åˆ†ç»„å¼¹çª—
            const moveModal = document.getElementById('move-stickers-modal');
            const targetGroupInput = document.getElementById('move-stickers-target-group');
            
            if (!moveModal || !targetGroupInput) {
                console.error('âŒ ç§»åŠ¨åˆ†ç»„å¼¹çª—å…ƒç´ æœªæ‰¾åˆ°');
                return;
            }
            
            // æ›´æ–°åˆ†ç»„å»ºè®®åˆ—è¡¨
            updateMoveGroupSuggestions();
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            targetGroupInput.value = '';
            
            // æ˜¾ç¤ºå¼¹çª—
            moveModal.classList.add('visible');
        }
        
        // æ›´æ–°ç§»åŠ¨åˆ†ç»„å¼¹çª—çš„å»ºè®®åˆ—è¡¨
        function updateMoveGroupSuggestions() {
            const datalist = document.getElementById('move-stickers-group-suggestions');
            if (!datalist) return;
            
            const groups = getAllStickerGroups();
            datalist.innerHTML = '';
            
            groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group;
                datalist.appendChild(option);
            });
        }
        
        // ç¡®è®¤ç§»åŠ¨åˆ°æŒ‡å®šåˆ†ç»„
        async function confirmMoveStickers() {
            const targetGroupInput = document.getElementById('move-stickers-target-group');
            const moveModal = document.getElementById('move-stickers-modal');
            
            if (!targetGroupInput) return;
            
            const targetGroup = targetGroupInput.value.trim() || null;
            
            console.log(`ğŸ”µ [å¤šé€‰ç®¡ç†] ç§»åŠ¨ ${selectedStickerIds.size} ä¸ªè¡¨æƒ…åˆ°åˆ†ç»„ "${targetGroup || 'æœªåˆ†ç±»'}"`);
            
            // æ›´æ–°é€‰ä¸­è¡¨æƒ…çš„åˆ†ç»„
            let movedCount = 0;
            db.myStickers.forEach(sticker => {
                if (selectedStickerIds.has(sticker.id)) {
                    sticker.group = targetGroup;
                    movedCount++;
                }
            });
            
            // ä¿å­˜æ•°æ®
            await saveData();
            
            // å…³é—­å¼¹çª—
            if (moveModal) moveModal.classList.remove('visible');
            
            // åˆ·æ–°ç•Œé¢
            renderStickerTabs();
            renderStickerGrid();
            
            // é€€å‡ºé€‰æ‹©æ¨¡å¼
            exitStickerSelectionMode();
            
            showToast(`æˆåŠŸç§»åŠ¨ ${movedCount} ä¸ªè¡¨æƒ…åˆ° "${targetGroup || 'æœªåˆ†ç±»'}"`);
            console.log(`âœ… [å¤šé€‰ç®¡ç†] æˆåŠŸç§»åŠ¨ ${movedCount} ä¸ªè¡¨æƒ…`);
        }
        
        // æ‰¹é‡åˆ é™¤é€‰ä¸­çš„è¡¨æƒ…
        async function deleteSelectedStickers() {
            if (selectedStickerIds.size === 0) {
                showToast('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„è¡¨æƒ…');
                return;
            }
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedStickerIds.size} ä¸ªè¡¨æƒ…å—ï¼Ÿ`)) {
                return;
            }
            
            console.log(`ğŸ”µ [å¤šé€‰ç®¡ç†] åˆ é™¤ ${selectedStickerIds.size} ä¸ªè¡¨æƒ…`);
            
            // åˆ é™¤é€‰ä¸­çš„è¡¨æƒ…
            const beforeCount = db.myStickers.length;
            db.myStickers = db.myStickers.filter(s => !selectedStickerIds.has(s.id));
            const deletedCount = beforeCount - db.myStickers.length;
            
            // ä¿å­˜æ•°æ®
            await saveData();
            
            // åˆ·æ–°ç•Œé¢
            renderStickerTabs();
            renderStickerGrid();
            
            // é€€å‡ºé€‰æ‹©æ¨¡å¼
            exitStickerSelectionMode();
            
            showToast(`æˆåŠŸåˆ é™¤ ${deletedCount} ä¸ªè¡¨æƒ…`);
            console.log(`âœ… [å¤šé€‰ç®¡ç†] æˆåŠŸåˆ é™¤ ${deletedCount} ä¸ªè¡¨æƒ…`);
        }
        
        // ===== å¤šé€‰ç®¡ç†åŠŸèƒ½ç»“æŸ =====
        
        // ===== ğŸ†• è§’è‰²è¡¨æƒ…åŒ…åˆ†ç»„ç»‘å®šåŠŸèƒ½ =====
        
        /**
         * æ¸²æŸ“è§’è‰²è®¾ç½®ä¸­çš„è¡¨æƒ…åŒ…åˆ†ç»„é€‰æ‹©å™¨
         * @param {Array<string>} selectedGroups - å½“å‰è§’è‰²å·²é€‰ä¸­çš„åˆ†ç»„åˆ—è¡¨
         */
        function renderStickerGroupsSelector(selectedGroups = []) {
            const container = document.getElementById('sticker-groups-selection-container');
            if (!container) {
                console.warn('âš ï¸ è¡¨æƒ…åŒ…åˆ†ç»„é€‰æ‹©å™¨å®¹å™¨æœªæ‰¾åˆ°');
                return;
            }
            
            // æ¸…ç©ºå®¹å™¨
            container.innerHTML = '';
            
            // è·å–æ‰€æœ‰å·²æœ‰åˆ†ç»„
            const allGroups = getAllStickerGroups();
            
            // æ·»åŠ "æœªåˆ†ç±»"é€‰é¡¹ï¼ˆå¦‚æœå­˜åœ¨æœªåˆ†ç±»è¡¨æƒ…ï¼‰
            const hasUngrouped = db.myStickers && db.myStickers.some(s => !s.group || s.group.trim() === '');
            if (hasUngrouped) {
                allGroups.unshift('æœªåˆ†ç±»');
            }
            
            // å¦‚æœæ²¡æœ‰ä»»ä½•åˆ†ç»„
            if (allGroups.length === 0) {
                container.innerHTML = `
                    <p style="color: #999; grid-column: 1/-1; text-align: center; margin: 0; font-size: 13px;">
                        ğŸ“¦ è¿˜æ²¡æœ‰è¡¨æƒ…åŒ…ï¼Œå…ˆå»<a href="#" onclick="document.getElementById('sticker-toggle-btn').click(); return false;" style="color: var(--primary-color);">æ·»åŠ è¡¨æƒ…åŒ…</a>å§
                    </p>
                `;
                updateStickerGroupsStatusSummary(0, 0);
                return;
            }
            
            // æ¸²æŸ“å¤é€‰æ¡†
            allGroups.forEach((groupName, index) => {
                // ğŸ†• å¢å¼ºå®¹é”™ï¼šç¡®ä¿ groupName æ˜¯æœ‰æ•ˆå­—ç¬¦ä¸²
                const displayName = (groupName && groupName.toString().trim()) || 'æœªåˆ†ç±»';
                const isChecked = selectedGroups.includes(displayName);
                
                const label = document.createElement('label');
                label.className = 'sticker-group-checkbox-label';
                label.style.cssText = `
                    display: flex;
                    align-items: center;
                    padding: 8px 10px;
                    background: white;
                    border: 2px solid ${isChecked ? 'var(--primary-color)' : '#ddd'};
                    border-radius: 6px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    user-select: none;
                `;
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'sticker-group-checkbox';
                checkbox.value = displayName;
                checkbox.checked = isChecked;
                checkbox.style.cssText = 'margin-right: 6px; cursor: pointer; width: 16px; height: 16px;';
                
                const span = document.createElement('span');
                span.textContent = displayName; // ğŸ†• ç¡®ä¿æ˜¾ç¤ºåç§°
                span.style.cssText = 'font-size: 13px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; color: #333;';
                
                // ğŸ†• åŠ¨æ€æ›´æ–°è¾¹æ¡†é¢œè‰²å’ŒçŠ¶æ€æ‘˜è¦
                checkbox.addEventListener('change', () => {
                    label.style.borderColor = checkbox.checked ? 'var(--primary-color)' : '#ddd';
                    updateStickerGroupsStatusSummary(); // å®æ—¶æ›´æ–°çŠ¶æ€æ‘˜è¦
                });
                
                label.appendChild(checkbox);
                label.appendChild(span);
                container.appendChild(label);
            });
            
            // ğŸ†• åˆå§‹åŒ–çŠ¶æ€æ‘˜è¦
            updateStickerGroupsStatusSummary(selectedGroups.length, allGroups.length);
            
            console.log(`âœ… æ¸²æŸ“è¡¨æƒ…åŒ…åˆ†ç»„é€‰æ‹©å™¨: ${allGroups.length} ä¸ªåˆ†ç»„, å·²é€‰ä¸­: [${selectedGroups.join(', ')}]`);
        }
        
        /**
         * ğŸ†• æ›´æ–°æŠ˜å èœå•çš„çŠ¶æ€æ‘˜è¦
         * @param {number} selectedCount - å·²é€‰ä¸­æ•°é‡ï¼ˆå¯é€‰ï¼Œè‡ªåŠ¨è®¡ç®—ï¼‰
         * @param {number} totalCount - æ€»æ•°é‡ï¼ˆå¯é€‰ï¼Œè‡ªåŠ¨è®¡ç®—ï¼‰
         */
        function updateStickerGroupsStatusSummary(selectedCount = null, totalCount = null) {
            const summaryElement = document.getElementById('sticker-groups-status-summary');
            if (!summaryElement) return;
            
            // è‡ªåŠ¨è®¡ç®—æ•°é‡
            if (selectedCount === null) {
                const checkboxes = document.querySelectorAll('.sticker-group-checkbox');
                selectedCount = Array.from(checkboxes).filter(cb => cb.checked).length;
                totalCount = checkboxes.length;
            }
            
            // ç”ŸæˆçŠ¶æ€æ–‡æœ¬
            let statusText = '';
            let statusColor = '#888';
            
            if (totalCount === 0) {
                statusText = 'æš‚æ— åˆ†ç»„';
                statusColor = '#999';
            } else if (selectedCount === 0) {
                statusText = 'æœªé…ç½®ï¼ˆå·²ç¦ç”¨ï¼‰';
                statusColor = '#f44336';
            } else if (selectedCount === totalCount) {
                statusText = 'å…¨éƒ¨å…è®¸';
                statusColor = 'var(--primary-color)';
            } else {
                statusText = `å·²é€‰ ${selectedCount}/${totalCount} ä¸ªåˆ†ç»„`;
                statusColor = 'var(--secondary-color)';
            }
            
            summaryElement.textContent = statusText;
            summaryElement.style.color = statusColor;
        }
        
        /**
         * è·å–å½“å‰é€‰ä¸­çš„è¡¨æƒ…åŒ…åˆ†ç»„
         * @returns {Array<string>} é€‰ä¸­çš„åˆ†ç»„åç§°æ•°ç»„
         */
        function getSelectedStickerGroups() {
            const checkboxes = document.querySelectorAll('.sticker-group-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }
        
        /**
         * æ ¹æ®è§’è‰²çš„åˆ†ç»„ç»‘å®šï¼Œç­›é€‰å¯ç”¨çš„è¡¨æƒ…åŒ…
         * @param {Object} character - è§’è‰²å¯¹è±¡
         * @returns {Array} ç­›é€‰åçš„è¡¨æƒ…åŒ…åˆ—è¡¨
         */
        function getAvailableStickersForCharacter(character) {
            if (!character || !db.myStickers || db.myStickers.length === 0) {
                return [];
            }
            
            // è·å–è§’è‰²ç»‘å®šçš„åˆ†ç»„
            let allowedGroups = [];
            if (character.stickerGroups && typeof character.stickerGroups === 'string') {
                allowedGroups = character.stickerGroups.split(',').map(g => g.trim()).filter(Boolean);
            }
            
            // å¦‚æœæ²¡æœ‰ç»‘å®šä»»ä½•åˆ†ç»„ï¼ˆç•™ç©ºæˆ–æ—§è§’è‰²ï¼‰ï¼Œè¿”å›ç©ºæ•°ç»„ï¼ˆç¦ç”¨è¡¨æƒ…åŒ…ï¼‰
            if (allowedGroups.length === 0) {
                console.log(`ğŸ”µ [è¡¨æƒ…åŒ…ç­›é€‰] è§’è‰² "${character.realName}" æœªç»‘å®šä»»ä½•åˆ†ç»„ï¼Œè¡¨æƒ…åŒ…åŠŸèƒ½å·²ç¦ç”¨`);
                return [];
            }
            
            // ç­›é€‰è¡¨æƒ…åŒ…
            const availableStickers = db.myStickers.filter(sticker => {
                const stickerGroup = (sticker.group || 'æœªåˆ†ç±»').trim();
                const isAllowed = allowedGroups.includes(stickerGroup);
                return isAllowed;
            });
            
            console.log(`ğŸ”µ [è¡¨æƒ…åŒ…ç­›é€‰] è§’è‰² "${character.realName}" å…è®¸åˆ†ç»„: [${allowedGroups.join(', ')}], å¯ç”¨è¡¨æƒ…: ${availableStickers.length}/${db.myStickers.length}`);
            
            return availableStickers;
        }
        
        // ===== è§’è‰²è¡¨æƒ…åŒ…åˆ†ç»„ç»‘å®šåŠŸèƒ½ç»“æŸ =====
        
        // ğŸ†• è·å–æ‰€æœ‰å·²å­˜åœ¨çš„åˆ†ç»„åç§°ï¼ˆå»é‡ï¼‰
        function getAllStickerGroups() {
            if (!db.myStickers) {
                db.myStickers = [];
            }
            
            const allGroups = [...new Set(
                db.myStickers
                    .map(s => s.group)
                    .filter(g => g && g !== 'æœªåˆ†ç±»') // è¿‡æ»¤æ‰ nullã€undefinedã€ç©ºå­—ç¬¦ä¸²å’Œ"æœªåˆ†ç±»"
            )];
            
            return allGroups.sort(); // æŒ‰å­—æ¯æ’åº
        }
        
        // ğŸ†• æ›´æ–°åˆ†ç»„å»ºè®®åˆ—è¡¨ï¼ˆdatalistï¼‰
        function updateGroupSuggestions() {
            const groups = getAllStickerGroups();
            
            // æ›´æ–°å•ä¸ªæ·»åŠ å¼¹çª—çš„ datalist
            const singleDatalist = document.getElementById('sticker-group-suggestions');
            if (singleDatalist) {
                singleDatalist.innerHTML = '';
                groups.forEach(group => {
                    const option = document.createElement('option');
                    option.value = group;
                    singleDatalist.appendChild(option);
                });
            }
            
            // æ›´æ–°æ‰¹é‡å¯¼å…¥å¼¹çª—çš„ datalist
            const batchDatalist = document.getElementById('batch-sticker-group-suggestions');
            if (batchDatalist) {
                batchDatalist.innerHTML = '';
                groups.forEach(group => {
                    const option = document.createElement('option');
                    option.value = group;
                    batchDatalist.appendChild(option);
                });
            }
        }
        
        // ğŸ†• æ¸²æŸ“åˆ†ç»„æ ‡ç­¾æ 
        function renderStickerTabs() {
            const tabsContainer = document.getElementById('sticker-tabs');
            if (!tabsContainer) {
                console.warn('âš ï¸ renderStickerTabs: sticker-tabs å®¹å™¨æœªæ‰¾åˆ°');
                return;
            }
            
            if (!db.myStickers) {
                db.myStickers = [];
            }
            
            tabsContainer.innerHTML = '';
            
            // 1. è·å–æ‰€æœ‰åˆ†ç»„
            const allGroups = getAllStickerGroups();
            
            // 2. åˆ›å»º"å…¨éƒ¨"æ ‡ç­¾
            const allTab = document.createElement('div');
            allTab.className = 'sticker-tab' + (currentStickerCategory === 'all' ? ' active' : '');
            allTab.textContent = 'å…¨éƒ¨';
            allTab.addEventListener('click', () => {
                currentStickerCategory = 'all';
                renderStickerTabs();
                renderStickerGrid();
            });
            tabsContainer.appendChild(allTab);
            
            // 3. åˆ›å»º"æœªåˆ†ç±»"æ ‡ç­¾ï¼ˆåªæœ‰å½“å­˜åœ¨æœªåˆ†ç±»è¡¨æƒ…æ—¶æ‰æ˜¾ç¤ºï¼‰
            const hasUncategorized = db.myStickers.some(s => !s.group);
            if (hasUncategorized) {
                const uncategorizedTab = document.createElement('div');
                uncategorizedTab.className = 'sticker-tab' + (currentStickerCategory === 'uncategorized' ? ' active' : '');
                uncategorizedTab.textContent = 'æœªåˆ†ç±»';
                uncategorizedTab.addEventListener('click', () => {
                    currentStickerCategory = 'uncategorized';
                    renderStickerTabs();
                    renderStickerGrid();
                });
                tabsContainer.appendChild(uncategorizedTab);
            }
            
            // 4. åˆ›å»ºå…¶ä»–åˆ†ç»„æ ‡ç­¾
            allGroups.forEach(groupName => {
                const tab = document.createElement('div');
                tab.className = 'sticker-tab' + (currentStickerCategory === groupName ? ' active' : '');
                tab.textContent = groupName;
                tab.addEventListener('click', () => {
                    currentStickerCategory = groupName;
                    renderStickerTabs();
                    renderStickerGrid();
                });
                tabsContainer.appendChild(tab);
            });
        }
        
        // ğŸ†• æ¸²æŸ“è¡¨æƒ…åŒ…ç½‘æ ¼ï¼ˆæ”¯æŒåˆ†ç»„ç­›é€‰ï¼‰
        function renderStickerGrid() {
            const gridContainer = document.getElementById('sticker-grid-container');
            if (!gridContainer) {
                console.warn('âš ï¸ renderStickerGrid: sticker-grid-container å®¹å™¨æœªæ‰¾åˆ°');
                return;
            }
            
            if (!db.myStickers) {
                db.myStickers = [];
            }
            
            gridContainer.innerHTML = '';
            
            // å…¨å±€æ²¡æœ‰ä»»ä½•è¡¨æƒ…åŒ…
            if (db.myStickers.length === 0) {
                gridContainer.innerHTML = `
                    <div style="text-align:center; padding: 40px 20px; color:#aaa; grid-column: 1 / -1;">
                        <p style="font-size: 16px; margin-bottom: 10px;">ğŸ“¦ è¿˜æ²¡æœ‰è¡¨æƒ…åŒ…</p>
                        <p style="font-size: 14px;">ç‚¹å‡»å³ä¸Šè§’èœå•æ·»åŠ å§ï¼</p>
                    </div>
                `;
                return;
            }
            
            // æ ¹æ®å½“å‰åˆ†ç»„ç­›é€‰è¡¨æƒ…åŒ…
            let stickersToShow = [];
            let emptyMessage = '';
            
            if (currentStickerCategory === 'all') {
                stickersToShow = db.myStickers;
                emptyMessage = 'æš‚æ— è¡¨æƒ…åŒ…';
            } else if (currentStickerCategory === 'uncategorized') {
                stickersToShow = db.myStickers.filter(s => !s.group || s.group === '');
                emptyMessage = 'æœªåˆ†ç±»ä¸­æš‚æ— è¡¨æƒ…åŒ…';
            } else {
                stickersToShow = db.myStickers.filter(s => s.group === currentStickerCategory);
                emptyMessage = `"${currentStickerCategory}" åˆ†ç»„ä¸­æš‚æ— è¡¨æƒ…åŒ…`;
            }
            
            // å½“å‰ç­›é€‰æ¡ä»¶ä¸‹æ²¡æœ‰è¡¨æƒ…åŒ…
            if (stickersToShow.length === 0) {
                gridContainer.innerHTML = `
                    <div style="text-align:center; padding: 40px 20px; color:#aaa; grid-column: 1 / -1;">
                        <p style="font-size: 16px; margin-bottom: 10px;">ğŸ” ${emptyMessage}</p>
                        <p style="font-size: 14px;">è¯•è¯•åˆ‡æ¢åˆ°å…¶ä»–åˆ†ç»„æŸ¥çœ‹</p>
                    </div>
                `;
                return;
            }
            
            // æ¸²æŸ“è¡¨æƒ…åŒ…
            stickersToShow.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.dataset.stickerId = sticker.id; // ğŸ†• æ·»åŠ  data å±æ€§
                
                // ğŸ†• æ·»åŠ é€‰ä¸­çŠ¶æ€
                if (selectedStickerIds.has(sticker.id)) {
                    item.classList.add('selected');
                }
                
                // ğŸ†• æ·»åŠ å¤é€‰æ¡†ï¼ˆåªåœ¨é€‰æ‹©æ¨¡å¼ä¸‹æ˜¾ç¤ºï¼‰
                const checkbox = document.createElement('div');
                checkbox.className = 'sticker-checkbox';
                item.appendChild(checkbox);
                
                // æ·»åŠ å›¾ç‰‡å’Œåç§°
                const img = document.createElement('img');
                img.src = sticker.data;
                img.alt = sticker.name;
                item.appendChild(img);
                
                const span = document.createElement('span');
                span.textContent = sticker.name;
                item.appendChild(span);
                
                // ğŸ†• ç‚¹å‡»äº‹ä»¶ï¼šæ ¹æ®æ¨¡å¼å†³å®šæ˜¯å‘é€è¿˜æ˜¯é€‰æ‹©
                item.addEventListener('click', () => {
                    if (isStickerSelectionMode) {
                        // é€‰æ‹©æ¨¡å¼ï¼šåˆ‡æ¢é€‰ä¸­çŠ¶æ€
                        toggleStickerSelection(sticker.id);
                    } else {
                        // æ™®é€šæ¨¡å¼ï¼šå‘é€è¡¨æƒ…
                        sendSticker(sticker);
                    }
                });
                
                // é•¿æŒ‰/å³é”®ç¼–è¾‘ï¼ˆé¼ æ ‡ï¼‰- åªåœ¨éé€‰æ‹©æ¨¡å¼ä¸‹ç”Ÿæ•ˆ
                item.addEventListener('mousedown', (e) => {
                    if (isStickerSelectionMode) return; // é€‰æ‹©æ¨¡å¼ä¸‹ç¦ç”¨é•¿æŒ‰
                    if (e.button !== 0) return;
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
                item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
                
                // é•¿æŒ‰ç¼–è¾‘ï¼ˆè§¦æ‘¸ï¼‰- åªåœ¨éé€‰æ‹©æ¨¡å¼ä¸‹ç”Ÿæ•ˆ
                item.addEventListener('touchstart', (e) => {
                    if (isStickerSelectionMode) return; // é€‰æ‹©æ¨¡å¼ä¸‹ç¦ç”¨é•¿æŒ‰
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('touchend', () => clearTimeout(longPressTimer));
                item.addEventListener('touchmove', () => clearTimeout(longPressTimer));
                
                gridContainer.appendChild(item);
            });
            
            // ğŸ†• æ›´æ–°å…¨é€‰æŒ‰é’®çŠ¶æ€ï¼ˆå¦‚æœåœ¨é€‰æ‹©æ¨¡å¼ä¸‹ï¼‰
            if (isStickerSelectionMode) {
                updateSelectAllButtonState();
            }
        }

        function handleStickerLongPress(stickerId) {
            clearTimeout(longPressTimer);
            currentStickerActionTarget = stickerId;
            stickerActionSheet.classList.add('visible');
        }

        function setupVoiceMessageSystem() {
            voiceMessageBtn.addEventListener('click', () => {
                sendVoiceForm.reset();
                voiceDurationPreview.textContent = '0"';
                sendVoiceModal.classList.add('visible');
            });
            sendVoiceForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyVoiceMessage(voiceTextInput.value.trim());
            });
        }

        function setupPhotoVideoSystem() {
            photoVideoBtn.addEventListener('click', () => {
                sendPvForm.reset();
                sendPvModal.classList.add('visible');
            });
            sendPvForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyPhotoVideo(pvTextInput.value.trim());
            });
        }

        function setupWalletSystem() {
            walletBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'transfer';
                    renderGroupRecipientSelectionList('è½¬è´¦ç»™');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendTransferForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const amount = transferAmountInput.value;
                const remark = transferRemarkInput.value.trim();
                if (amount > 0) {
                    sendMyTransfer(amount, remark);
                } else {
                    showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
                }
            });
            acceptTransferBtn.addEventListener('click', () => respondToTransfer('received'));
            returnTransferBtn.addEventListener('click', () => respondToTransfer('returned'));
        }

        function handleReceivedTransferClick(messageId) {
            currentTransferMessageId = messageId;
            receiveTransferActionSheet.classList.add('visible');
        }

// START: ä¿®å¤ç‰ˆ respondToTransfer (ç¡®ä¿èƒ½ç‚¹å‡»æ¥æ”¶AIè½¬è´¦)
async function respondToTransfer(action) {
    if (!currentTransferMessageId) return;
    const character = db.characters.find(c => c.id === currentChatId);
    // æŸ¥æ‰¾æ¶ˆæ¯
    const message = character.history.find(m => m.id === currentTransferMessageId);
    
    if (message) {
        message.transferStatus = action;
        const cardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${currentTransferMessageId}"] .transfer-card`);
        if (cardOnScreen) {
            cardOnScreen.classList.remove('received', 'returned');
            cardOnScreen.classList.add(action);
            cardOnScreen.querySelector('.transfer-status').textContent = action === 'received' ? 'å·²æ”¶æ¬¾' : 'å·²é€€å›';
            cardOnScreen.style.cursor = 'default';
        }

        if (action === 'received') {
            // ä¿®å¤ï¼šæ›´å®½å®¹çš„æ­£åˆ™ï¼Œä¸å¼ºæ±‚å®Œå…¨åŒ¹é…
            const amountMatch = message.content.match(/è½¬è´¦ï¼š([\d.]+)å…ƒ/); 
            if (amountMatch) {
                const amount = parseFloat(amountMatch[1]);
                addTransaction('income', amount, `æ”¶åˆ° ${character.remarkName} çš„è½¬è´¦`);
            }
        }

        let contextMessageContent = (action === 'received') ? `[${character.myName}æ¥æ”¶${character.realName}çš„è½¬è´¦]` : `[${character.myName}é€€å›${character.realName}çš„è½¬è´¦]`;
        const contextMessage = {
            id: `msg_${Date.now()}`,
            role: 'user',
            content: contextMessageContent,
            parts: [{type: 'text', text: contextMessageContent}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        await saveData();
        renderChatList();
    }
    receiveTransferActionSheet.classList.remove('visible');
    currentTransferMessageId = null;
}

               function setupGiftSystem() {if (currentChatType === 'private') {
    const character = db.characters.find(c => c.id === currentChatId);
    if (character && character.isBlockedByAi) {
        showToast('ä½ å·²è¢«å¯¹æ–¹æ‹‰é»‘');
        return; // é˜»æ­¢å‡½æ•°ç»§ç»­æ‰§è¡Œ
    }
}
            giftBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'gift';
                    renderGroupRecipientSelectionList('é€ç¤¼ç‰©ç»™');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendGiftForm.addEventListener('submit', (e) => {
                e.preventDefault();
                // --- â–¼â–¼â–¼ ä¿®æ”¹ï¼šè·å–ä»·æ ¼å’Œæè¿° â–¼â–¼â–¼ ---
                const description = document.getElementById('gift-description-input').value.trim();
                const amount = document.getElementById('gift-amount-input').value;
                sendMyGift(description, amount); // å°†ä»·æ ¼ä½œä¸ºå‚æ•°ä¼ é€’
                // --- â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–² ---
            });
        }
// --- æ–°ä»£ç å¼€å§‹ ---
// ===============================================================
// START: å­—ä½“é¢„è®¾åŠŸèƒ½
// ===============================================================
(function(){
    if (window._fontPresetsScriptLoaded) return;
    window._fontPresetsScriptLoaded = true;

    const PRES_KEY = 'fontPresets';

    function _getFontPresets() {
        try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); }
        catch(e){ return []; }
    }
    function _saveFontPresets(arr) {
        localStorage.setItem(PRES_KEY, JSON.stringify(arr || []));
    }

    function populateFontPresetSelect() {
        const sel = document.getElementById('font-preset-select');
        if (!sel) return;
        const presets = _getFontPresets();
        sel.innerHTML = '<option value="">â€” é€‰æ‹©ä¸€ä¸ªé¢„è®¾ â€”</option>';
        presets.forEach((p) => {
            const opt = document.createElement('option');
            opt.value = p.name;
            opt.textContent = p.name;
            sel.appendChild(opt);
        });
    }

    function saveCurrentFontAsPreset() {
        const fontUrlEl = document.getElementById('font-url');
        if (!fontUrlEl) return showToast('æ‰¾ä¸åˆ°å­—ä½“é“¾æ¥è¾“å…¥æ¡†');
        const url = fontUrlEl.value.trim();
        if (!url) return showToast('å½“å‰å­—ä½“é“¾æ¥ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜');
        
        let name = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼ˆå°†è¦†ç›–åŒåé¢„è®¾ï¼‰:');
        if (!name) return;

        const presets = _getFontPresets();
        const existingPreset = presets.find(p => p.name === name);

        if (existingPreset) {
            existingPreset.url = url;
        } else {
            presets.push({ name, url });
        }
        
        _saveFontPresets(presets);
        populateFontPresetSelect();
        showToast('å­—ä½“é¢„è®¾å·²ä¿å­˜');
    }

    function applyFontPreset(presetName) {
        const presets = _getFontPresets();
        const preset = presets.find(p => p.name === presetName);
        if (!preset) {
            showToast('æœªæ‰¾åˆ°è¯¥é¢„è®¾');
            return;
        }

        const fontUrlEl = document.getElementById('font-url');
        if (fontUrlEl) {
            fontUrlEl.value = preset.url;
            // æ¨¡æ‹Ÿç‚¹å‡»â€œåº”ç”¨å­—ä½“â€æŒ‰é’®æ¥è§¦å‘ä¿å­˜å’Œåº”ç”¨é€»è¾‘
            const applyBtn = document.querySelector('#font-settings-form button[type="submit"]');
            if (applyBtn) {
                applyBtn.click();
            } else { // Fallback in case button isn't found
                db.fontUrl = preset.url;
                saveData();
                applyGlobalFont(preset.url);
                showToast('å­—ä½“é¢„è®¾å·²åº”ç”¨ï¼');
            }
        }
    }

    function openManageFontPresetsModal() {
        const modal = document.getElementById('font-presets-modal');
        const list = document.getElementById('font-presets-list');
        if (!modal || !list) return;

        list.innerHTML = '';
        const presets = _getFontPresets();
        if (!presets.length) {
            list.innerHTML = '<p style="color:#888;margin:6px 0;">æš‚æ— é¢„è®¾</p>';
        }

        presets.forEach((p, idx) => {
            const row = document.createElement('div');
            row.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #f0f0f0;';
            
            const nameDiv = document.createElement('div');
            nameDiv.textContent = p.name;
            row.appendChild(nameDiv);

            const btnWrap = document.createElement('div');
            btnWrap.style.cssText = 'display: flex; gap: 6px;';

            const renameBtn = document.createElement('button');
            renameBtn.className = 'btn btn-secondary btn-small';
            renameBtn.textContent = 'é‡å‘½å';
            renameBtn.onclick = function(){
                const newName = prompt('è¾“å…¥æ–°åç§°ï¼š', p.name);
                if (newName && newName.trim()) {
                    const all = _getFontPresets();
                    all[idx].name = newName.trim();
                    _saveFontPresets(all);
                    openManageFontPresetsModal(); // Refresh the list
                    populateFontPresetSelect();
                }
            };

            const delBtn = document.createElement('button');
            delBtn.className = 'btn btn-danger btn-small';
            delBtn.textContent = 'åˆ é™¤';
            delBtn.onclick = function(){
                if (!confirm(`ç¡®å®šåˆ é™¤é¢„è®¾ "${p.name}" ?`)) return;
                const all = _getFontPresets();
                all.splice(idx, 1);
                _saveFontPresets(all);
                openManageFontPresetsModal();
                populateFontPresetSelect();
            };

            btnWrap.appendChild(renameBtn);
            btnWrap.appendChild(delBtn);
            row.appendChild(btnWrap);
            list.appendChild(row);
        });
        modal.style.display = 'flex';
    }

    // å°†UIç»‘å®šå‡½æ•°æš´éœ²åˆ°å…¨å±€ï¼Œä»¥ä¾¿init()å¯ä»¥è°ƒç”¨
    window.bindFontPresetUI = function() {
        populateFontPresetSelect();
        document.getElementById('font-apply-preset').addEventListener('click', () => {
            const val = document.getElementById('font-preset-select').value;
            if (!val) return showToast('è¯·é€‰æ‹©è¦åº”ç”¨çš„é¢„è®¾');
            applyFontPreset(val);
        });
        document.getElementById('font-save-preset').addEventListener('click', saveCurrentFontAsPreset);
        document.getElementById('font-manage-presets').addEventListener('click', openManageFontPresetsModal);
        document.getElementById('font-close-modal').addEventListener('click', () => {
            document.getElementById('font-presets-modal').style.display = 'none';
        });

        // ç›‘å¬å­—ä½“è®¾ç½®é¡µé¢çš„æ‰“å¼€ï¼Œä»¥ä¾¿åˆ·æ–°é¢„è®¾åˆ—è¡¨
        document.querySelector('.app-icon[data-target="font-settings-screen"]').addEventListener('click', populateFontPresetSelect);
    }
})();
// ===============================================================
// END: å­—ä½“é¢„è®¾åŠŸèƒ½
// ===============================================================
// --- æ–°ä»£ç ç»“æŸ ---
        function setupFontSettingsApp() {
            fontUrlInput.value = db.fontUrl;
            fontSettingsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newFontUrl = fontUrlInput.value.trim();
                db.fontUrl = newFontUrl;
                await saveData();
                applyGlobalFont(newFontUrl);
                showToast('æ–°å­—ä½“å·²åº”ç”¨ï¼');
            });
            restoreDefaultFontBtn.addEventListener('click', async () => {
                fontUrlInput.value = '';
                db.fontUrl = '';
                await saveData();
                applyGlobalFont('');
                showToast('å·²æ¢å¤é»˜è®¤å­—ä½“ï¼');
            });
        }

        function applyGlobalFont(fontUrl) {
            const styleId = 'global-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            if (fontUrl) {
                const fontName = 'CustomGlobalFont';
                styleElement.innerHTML = `@font-face { font-family: '${fontName}'; src: url('${fontUrl}'); } :root { --font-family: '${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            } else {
                styleElement.innerHTML = `:root { --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            }
        }
// â–¼â–¼â–¼ åœ¨è¿™é‡Œç²˜è´´ä¸‹é¢çš„æ–°å‡½æ•° â–¼â–¼â–¼

// --- å…¨å±€è¾…åŠ©å‡½æ•°ï¼šå¡«å……ä¸–ç•Œä¹¦åˆ†ç±»ä¸‹æ‹‰èœå• ---
function populateCategorySelect(selectedCategoryId = 'uncategorized') {
    const selectEl = document.getElementById('world-book-category-select');
    if (!selectEl) return; // å®‰å…¨æ£€æŸ¥

    selectEl.innerHTML = '<option value="uncategorized">æœªåˆ†ç±»</option>'; // é»˜è®¤é€‰é¡¹
    
    // ç¡®ä¿ db.worldBookCategories å­˜åœ¨
    if (db && Array.isArray(db.worldBookCategories)) {
        db.worldBookCategories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.id;
            option.textContent = cat.name;
            selectEl.appendChild(option);
        });
    }
    
    selectEl.value = selectedCategoryId;
}

// â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
   function setupWorldBookApp() {
   	const importWorldBookBtn = document.getElementById('import-world-book-btn');
const worldBookImportInput = document.getElementById('world-book-import-input');

importWorldBookBtn.addEventListener('click', () => {
    worldBookImportInput.click();
});

worldBookImportInput.addEventListener('change', handleWorldBookImport);
    // ç›‘å¬æ‰“å¼€ç¼–è¾‘/åˆ›å»ºä¸–ç•Œä¹¦é¡µé¢çš„äº‹ä»¶
    addWorldBookBtn.addEventListener('click', () => {
        currentEditingWorldBookId = null;
        editWorldBookForm.reset();
        document.querySelector('input[name="world-book-position"][value="before"]').checked = true;
        // è°ƒç”¨å…¨å±€å‡½æ•°å¡«å……åˆ†ç±»
        populateCategorySelect();
        switchScreen('edit-world-book-screen');
    });

    // è¡¨å•ä¿å­˜é€»è¾‘ (ç¡®ä¿åªç»‘å®šä¸€æ¬¡)
    editWorldBookForm.onsubmit = async function(e) {
        e.preventDefault();
        const selectedCategoryId = document.getElementById('world-book-category-select').value;
        const name = worldBookNameInput.value.trim();
        const content = worldBookContentInput.value.trim();
        const position = document.querySelector('input[name="world-book-position"]:checked').value;
        
        const keywords = document.getElementById('world-book-keywords').value.trim();
        const alwaysActive = document.getElementById('world-book-always-active').checked;
        const caseSensitive = document.getElementById('world-book-case-sensitive').checked;

        if (!name || !content) return showToast('åç§°å’Œå†…å®¹ä¸èƒ½ä¸ºç©º');
        
        const bookData = { name, content, position, categoryId: selectedCategoryId, keywords, alwaysActive, caseSensitive };

        if (currentEditingWorldBookId) {
            const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
            if (book) Object.assign(book, bookData);
        } else {
            bookData.id = `wb_${Date.now()}`;
            db.worldBooks.push(bookData);
        }
        
        await saveData();
        showToast('ä¸–ç•Œä¹¦æ¡ç›®å·²ä¿å­˜');
        renderWorldBookList();
        switchScreen('world-book-screen');
    };

    // ä¸–ç•Œä¹¦åˆ—è¡¨çš„ç‚¹å‡»å’Œé•¿æŒ‰äº‹ä»¶
    worldBookListContainer.addEventListener('click', e => {
       const item = e.target.closest('.world-book-item');
        if (item) {
            const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
            if(book) {
                currentEditingWorldBookId = book.id;
                worldBookIdInput.value = book.id;
                worldBookNameInput.value = book.name;
                worldBookContentInput.value = book.content;
                document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                populateCategorySelect(book.categoryId || 'uncategorized');
                document.getElementById('world-book-keywords').value = book.keywords || '';
                document.getElementById('world-book-always-active').checked = book.alwaysActive || false;
                document.getElementById('world-book-case-sensitive').checked = book.caseSensitive || false;
                switchScreen('edit-world-book-screen');
            }
        }
    });

    worldBookListContainer.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const item = e.target.closest('.world-book-item');
        if (!item) return;
        longPressTimer = setTimeout(() => {
            const bookId = item.dataset.id;
            const menuItems = [{
                label: 'åˆ é™¤',
                danger: true,
                action: async () => {
                    if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä¸–ç•Œä¹¦æ¡ç›®å—ï¼Ÿ')) {
                        db.worldBooks = db.worldBooks.filter(wb => wb.id !== bookId);
                        db.characters.forEach(char => {
                            char.worldBookIds = (char.worldBookIds || []).filter(id => id !== bookId);
                        });
                        db.groups.forEach(group => {
                            group.worldBookIds = (group.worldBookIds || []).filter(id => id !== bookId);
                        });
                        await saveData();
                        renderWorldBookList();
                        showToast('æ¡ç›®å·²åˆ é™¤');
                    }
                }
            }];
            createContextMenu(menuItems, e.clientX, e.clientY);
        }, 500);
    });

    worldBookListContainer.addEventListener('mouseup', () => clearTimeout(longPressTimer));
    worldBookListContainer.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
}
// â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²
        function renderWorldBookList() {
            worldBookListContainer.innerHTML = '';
            noWorldBooksPlaceholder.style.display = db.worldBooks.length === 0 ? 'block' : 'none';
            db.worldBooks.forEach(book => {
                const li = document.createElement('li');
                li.className = 'list-item world-book-item';
                li.dataset.id = book.id;
                li.innerHTML = `<div class="item-details" style="padding-left: 20px;"><div class="item-name">${book.name}</div><div class="item-preview">${book.content}</div></div>`;
                
                // æ’å…¥ï¼šå³ä¾§åˆ é™¤ä¸–ç•Œä¹¦æŒ‰é’®ï¼ˆç”± ChatGPT æ·»åŠ ï¼‰
                const delBtn = document.createElement('button');
                delBtn.className = 'action-btn';
                delBtn.style.position = 'absolute';
                delBtn.style.right = '8px';
                delBtn.style.top = '50%';
                delBtn.style.transform = 'translateY(-50%)';
                delBtn.style.padding = '6px';
                delBtn.style.border = 'none';
                delBtn.style.background = 'transparent';
                delBtn.title = 'åˆ é™¤ä¸–ç•Œä¹¦';
                const delImg = document.createElement('img');
                delImg.src = 'https://i.postimg.cc/hGW6B0Wf/icons8-50.png';
                delImg.alt = 'åˆ é™¤';
                delImg.style.width = '22px';
                delImg.style.height = '22px';
                delImg.style.objectFit = 'contain';
                delBtn.appendChild(delImg);
                delBtn.addEventListener('click', async (ev) => {
                    ev.stopPropagation();
                    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä¸–ç•Œä¹¦æ¡ç›®å—ï¼Ÿ')) return;
                    try {
                        if (typeof deleteWorldBookById === 'function') {
                            await deleteWorldBookById(book.id);
                        } else if (typeof deleteWorldBook === 'function') {
                            await deleteWorldBook(book.id);
                        } else {
                            // Try in-place removal as fallback
                            db.worldBooks = db.worldBooks.filter(wb => wb.id !== book.id);
                            if (typeof saveData === 'function') await saveData();
                        }
                        // åˆ·æ–°åˆ—è¡¨è§†å›¾
                        if (typeof renderWorldBookList === 'function') renderWorldBookList();
                        showToast && showToast('ä¸–ç•Œä¹¦å·²åˆ é™¤');
                    } catch (err) {
                        console.error('åˆ é™¤ä¸–ç•Œä¹¦å‡ºé”™', err);
                        alert('åˆ é™¤å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°');
                    }
                });
                // å°†æŒ‰é’®é™„åŠ åˆ° liï¼ˆli ç”¨ position: relative ä¿è¯æŒ‰é’®åœ¨å³ä¾§ï¼‰
                li.style.position = 'relative';
                li.appendChild(delBtn);
worldBookListContainer.appendChild(li);
            });
        }
/**
 * å¤„ç†ç”¨æˆ·é€‰æ‹©çš„JSONæ–‡ä»¶ï¼Œå¹¶åˆ†å‘ç»™ç›¸åº”çš„è§£æå™¨
 * @param {Event} event - æ–‡ä»¶è¾“å…¥æ¡†çš„changeäº‹ä»¶
 */
async function handleWorldBookImport(event) {
    const files = event.target.files;
    if (!files.length) return;

    let importedFileCount = 0;
    let errorFileCount = 0;

    showToast(`æ£€æµ‹åˆ° ${files.length} ä¸ªæ–‡ä»¶ï¼Œå¼€å§‹å¯¼å…¥...`);

    for (const file of files) {
        try {
            const content = await file.text();
            const data = JSON.parse(content);

            // æ ¹æ®æ–‡ä»¶ç»“æ„ç‰¹å¾ï¼Œåˆ¤æ–­æ˜¯å“ªç§æ ¼å¼å¹¶è°ƒç”¨å¯¹åº”è§£æå‡½æ•°
            if (data.prompts && Array.isArray(data.prompts)) {
                // è¯†åˆ«ä¸º MoMPsy_1.json æ ¼å¼
                parseMoMPsyFormat(file.name, data);
                importedFileCount++;
            } else if (data.entries && typeof data.entries === 'object') {
                // è¯†åˆ«ä¸º æå…‰å°å‰§åœº.json æ ¼å¼
                parseAuroraTheaterFormat(file.name, data);
                importedFileCount++;
            } else {
                throw new Error('æ— æ³•è¯†åˆ«çš„æ–‡ä»¶æ ¼å¼');
            }
        } catch (err) {
            console.error(`å¯¼å…¥æ–‡ä»¶ ${file.name} å¤±è´¥:`, err);
            errorFileCount++;
        }
    }

    // æ‰¹é‡å¤„ç†å®Œæˆåï¼Œç»Ÿä¸€ä¿å­˜å’Œåˆ·æ–°UI
    if (importedFileCount > 0) {
        await saveData();
        renderWorldBookList();
        showToast(`æˆåŠŸå¯¼å…¥ ${importedFileCount} ä¸ªæ–‡ä»¶ï¼`);
    }
    if (errorFileCount > 0) {
        showToast(`${errorFileCount} ä¸ªæ–‡ä»¶å¯¼å…¥å¤±è´¥ï¼Œè¯¦æƒ…è¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚`);
    }

    // é‡ç½®æ–‡ä»¶è¾“å…¥æ¡†ï¼Œä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥å†æ¬¡é€‰æ‹©ç›¸åŒçš„æ–‡ä»¶
    event.target.value = null;
}

/**
 * è§£æ MoMPsy_1.json æ ¼å¼çš„æ–‡ä»¶
 * @param {string} fileName - åŸå§‹æ–‡ä»¶å
 * @param {object} data - è§£æåçš„JSONæ•°æ®
 */
function parseMoMPsyFormat(fileName, data) {
    // ä½¿ç”¨æ–‡ä»¶åï¼ˆå»é™¤.jsonåç¼€ï¼‰ä½œä¸ºåˆ†ç±»å
    const categoryName = fileName.replace(/\.json$/i, '');
    let category = db.worldBookCategories.find(cat => cat.name === categoryName);

    // å¦‚æœåˆ†ç±»ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„
    if (!category) {
        category = {
            id: `cat_import_${Date.now()}_${Math.random()}`,
            name: categoryName,
            isCollapsed: false
        };
        db.worldBookCategories.push(category);
    }

    // éå† "prompts" æ•°ç»„ï¼Œå°†å…¶ä¸­çš„æ¯ä¸ªå¯¹è±¡è½¬æ¢ä¸ºä¸€ä¸ªä¸–ç•Œä¹¦æ¡ç›®
    data.prompts.forEach(prompt => {
        // ç¡®ä¿æ¡ç›®æœ‰æœ‰æ•ˆçš„å†…å®¹
        if (prompt.name && prompt.content) {
            const newEntry = {
                id: `wb_import_${Date.now()}_${Math.random()}`,
                name: prompt.name,
                content: prompt.content,
                categoryId: category.id,
                position: 'before', // é»˜è®¤ä¸ºå‰ç½®
                keywords: '',
                alwaysActive: false,
                caseSensitive: false
            };
            db.worldBooks.push(newEntry);
        }
    });
}

/**
 * è§£æ æå…‰å°å‰§åœº.json æ ¼å¼çš„æ–‡ä»¶
 * @param {string} fileName - åŸå§‹æ–‡ä»¶å
 * @param {object} data - è§£æåçš„JSONæ•°æ®
 */
function parseAuroraTheaterFormat(fileName, data) {
    // æå–æ–‡ä»¶åä¸­çš„æ ¸å¿ƒéƒ¨åˆ†ä½œä¸ºåˆ†ç±»å
    const categoryName = fileName.replace(/\.json$/i, '').replace(/3\.0\.0_Ver_|\.jsonæå…‰å°å‰§åœº 3\.0\.0 Ver @ç”µæ³¢ç³»/g, '').trim();
    let category = db.worldBookCategories.find(cat => cat.name === categoryName);

    // å¦‚æœåˆ†ç±»ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„
    if (!category) {
        category = {
            id: `cat_import_${Date.now()}_${Math.random()}`,
            name: categoryName || 'å¯¼å…¥çš„æå…‰å°å‰§åœº', // æä¾›ä¸€ä¸ªå¤‡ç”¨åç§°
            isCollapsed: false
        };
        db.worldBookCategories.push(category);
    }

    // éå† "entries" å¯¹è±¡çš„å€¼ï¼Œå°†å…¶ä¸­çš„æ¯ä¸ªå¯¹è±¡è½¬æ¢ä¸ºä¸€ä¸ªä¸–ç•Œä¹¦æ¡ç›®
    Object.values(data.entries).forEach(entry => {
        // ç¡®ä¿æ¡ç›®æœ‰æœ‰æ•ˆçš„å†…å®¹
        if (entry.comment && entry.content) {
            const newEntry = {
                id: `wb_import_${Date.now()}_${Math.random()}`,
                name: entry.comment, // ä½¿ç”¨ "comment" å­—æ®µä½œä¸ºæ¡ç›®åç§°
                content: entry.content,
                categoryId: category.id,
                position: 'before', // é»˜è®¤ä¸ºå‰ç½®
                keywords: entry.key ? entry.key.join(',') : '', // ä½¿ç”¨ "key" å­—æ®µä½œä¸ºå…³é”®è¯
                alwaysActive: false,
                caseSensitive: false
            };
            db.worldBooks.push(newEntry);
        }
    });
}
// â–¼â–¼â–¼ ç¬¬ä¸€æ­¥ï¼šå®Œæ•´æ›¿æ¢ setupChatSettings å‡½æ•° (æ–°å¢åªè¯»çš„æ˜µç§°å¤‡æ³¨æ ) â–¼â–¼â–¼
function setupChatSettings() {
    const themeSelect = document.getElementById('setting-theme-color');
    themeSelect.innerHTML = '';
    Object.keys(colorThemes).forEach(key => {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = colorThemes[key].name;
        themeSelect.appendChild(option);
    });

    chatSettingsBtn.addEventListener('click', () => {
        if (currentChatType === 'private') {
            loadSettingsToSidebar();
            settingsSidebar.classList.add('open');
        } else if (currentChatType === 'group') {
            loadGroupSettingsToSidebar();
            groupSettingsSidebar.classList.add('open');
        }
    });

    document.querySelector('.phone-screen').addEventListener('click', e => {
        const openSidebar = document.querySelector('.settings-sidebar.open');
        if (openSidebar && !openSidebar.contains(e.target) &&
            !chatSettingsBtn.contains(e.target) && !e.target.closest('.modal-overlay') &&
            !e.target.closest('.action-sheet-overlay')) {
            openSidebar.classList.remove('open');
        }
    });

    settingsForm.addEventListener('submit', e => {
        e.preventDefault();
        saveSettingsFromSidebar();
        settingsSidebar.classList.remove('open');
    });

    const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
        customCssTextarea = document.getElementById('setting-custom-bubble-css'),
        resetCustomCssBtn = document.getElementById('reset-custom-bubble-css-btn'),
        privatePreviewBox = document.getElementById('private-bubble-css-preview');

    useCustomCssCheckbox.addEventListener('change', (e) => {
        customCssTextarea.disabled = !e.target.checked;
        const char = db.characters.find(c => c.id === currentChatId);
        if (char) {
            const themeKey = char.theme || 'white_pink';
            const theme = colorThemes[themeKey];
            updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !e.target.checked, theme);
        }
    });

    customCssTextarea.addEventListener('input', (e) => {
        const char = db.characters.find(c => c.id === currentChatId);
        if (char && useCustomCssCheckbox.checked) {
            const themeKey = char.theme || 'white_pink';
            const theme = colorThemes[themeKey];
            updateBubbleCssPreview(privatePreviewBox, e.target.value, false, theme);
        }
    });

    resetCustomCssBtn.addEventListener('click', () => {
        const char = db.characters.find(c => c.id === currentChatId);
        if (char) {
            customCssTextarea.value = '';
            useCustomCssCheckbox.checked = false;
            customCssTextarea.disabled = true;
            const themeKey = char.theme || 'white_pink';
            const theme = colorThemes[themeKey];
            updateBubbleCssPreview(privatePreviewBox, '', true, theme);
            showToast('æ ·å¼å·²é‡ç½®ä¸ºé»˜è®¤');
        }
    });

    // ğŸ†• æŠ˜å èœå•äº¤äº’é€»è¾‘
    const accordionHeader = document.getElementById('sticker-groups-accordion-header');
    const accordionContent = document.getElementById('sticker-groups-accordion-content');
    const accordionArrow = accordionHeader ? accordionHeader.querySelector('.accordion-arrow') : null;
    
    if (accordionHeader && accordionContent) {
        accordionHeader.addEventListener('click', () => {
            const isExpanded = accordionContent.style.maxHeight && accordionContent.style.maxHeight !== '0px';
            
            if (isExpanded) {
                // æŠ˜å 
                accordionContent.style.maxHeight = '0';
                accordionContent.style.padding = '0 15px';
                if (accordionArrow) accordionArrow.style.transform = 'rotate(0deg)';
                accordionHeader.style.background = 'linear-gradient(135deg, #fff8fa 0%, #fff 100%)';
            } else {
                // å±•å¼€
                accordionContent.style.maxHeight = '400px';
                accordionContent.style.padding = '0 15px';
                if (accordionArrow) accordionArrow.style.transform = 'rotate(180deg)';
                accordionHeader.style.background = 'linear-gradient(135deg, #fce4ec 0%, #fff8fa 100%)';
            }
        });
    }
    
    // ğŸ†• è¡¨æƒ…åŒ…åˆ†ç»„å…¨é€‰/æ¸…ç©ºæŒ‰é’®
    const selectAllBtn = document.getElementById('select-all-sticker-groups-btn');
    const deselectAllBtn = document.getElementById('deselect-all-sticker-groups-btn');
    
    if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.sticker-group-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = true;
                const label = cb.closest('label');
                if (label) label.style.borderColor = 'var(--primary-color)';
            });
            updateStickerGroupsStatusSummary(); // ğŸ†• æ›´æ–°çŠ¶æ€æ‘˜è¦
            console.log('âœ… å…¨é€‰æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç»„');
        });
    }
    
    if (deselectAllBtn) {
        deselectAllBtn.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.sticker-group-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = false;
                const label = cb.closest('label');
                if (label) label.style.borderColor = '#ddd';
            });
            updateStickerGroupsStatusSummary(); // ğŸ†• æ›´æ–°çŠ¶æ€æ‘˜è¦
            console.log('âœ… æ¸…ç©ºæ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç»„é€‰æ‹©');
        });
    }
    
    document.getElementById('setting-char-avatar-upload').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                document.getElementById('setting-char-avatar-preview').src = compressedUrl;
            } catch (error) {
                showToast('å¤´åƒå‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }
    });

    document.getElementById('setting-my-avatar-upload').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                document.getElementById('setting-my-avatar-preview').src = compressedUrl;
            } catch (error) {
                showToast('å¤´åƒå‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }
    });

    document.getElementById('setting-chat-bg-upload').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            const char = db.characters.find(c => c.id === currentChatId);
            if (char) {
                try {
                    const compressedUrl = await compressImage(file, {
                        quality: 0.85, maxWidth: 1080, maxHeight: 1920
                    });
                    char.chatBg = compressedUrl;
                    chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                    await saveData();
                    showToast('èŠå¤©èƒŒæ™¯å·²æ›´æ¢');
                } catch (error) {
                    showToast('èƒŒæ™¯å‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
            }
        }
    });

    clearChatHistoryBtn.addEventListener('click', async () => {
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;
        if (confirm(`ä½ ç¡®å®šè¦æ¸…ç©ºä¸"${character.remarkName}"çš„æ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`)) {
            await clearHistoryDirectly();
        }
    });

 // èŠå¤©è®°å½•å¯¼å…¥å¯¼å‡ºæŒ‰é’®äº‹ä»¶
    document.getElementById('export-chat-btn').addEventListener('click', exportCurrentChat);
    
    document.getElementById('import-chat-btn').addEventListener('click', () => {
        document.getElementById('import-chat-input').click();
    });

    document.getElementById('import-chat-input').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            await importCurrentChat(file);
        }
        e.target.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©ï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
    });

    linkWorldBookBtn.addEventListener('click', () => {
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;
        worldBookSelectionList.innerHTML = '';
        (db.worldBookCategories || []).forEach(category => {
            const booksInCategory = db.worldBooks.filter(b => b.categoryId === category.id);
            if (booksInCategory.length === 0) return;
            const allInCategorySelected = booksInCategory.every(book => (character.worldBookIds || []).includes(book.id));
            const li = document.createElement('li');
            li.className = 'world-book-select-item';
            li.innerHTML = ` <input type="checkbox" id="wb-cat-select-${category.id}" data-category-id="${category.id}" ${allInCategorySelected ? 'checked' : ''}>
<label for="wb-cat-select-${category.id}"><strong>[ åˆ† ç±» ] ${category.name}
(${booksInCategory.length}æ¡)</strong></label>
`;
            worldBookSelectionList.appendChild(li);
        });

        const uncategorizedBooks = db.worldBooks.filter(b => b.categoryId === 'uncategorized');
        if (uncategorizedBooks.length > 0) {
            const separator = document.createElement('li');
            separator.innerHTML = `<h4 style="margin: 15px 0 5px; color: #888;"> æœª åˆ† ç±» æ¡ ç›® </h4>`;
            worldBookSelectionList.appendChild(separator);
            uncategorizedBooks.forEach(book => {
                const isChecked = (character.worldBookIds || []).includes(book.id);
                const li = document.createElement('li');
                li.className = 'world-book-select-item';
                li.innerHTML = ` <input type="checkbox" id="wb-select-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}>
<label for="wb-select-${book.id}">${book.name}</label>
`;
                worldBookSelectionList.appendChild(li);
            });
        }
        worldBookSelectionModal.classList.add('visible');
    });

    saveWorldBookSelectionBtn.addEventListener('click', async () => {
        const selectedIds = new Set();
        worldBookSelectionList.querySelectorAll('input[data-category-id]:checked').forEach(checkbox => {
            const categoryId = checkbox.dataset.categoryId;
            db.worldBooks.forEach(book => {
                if (book.categoryId === categoryId) {
                    selectedIds.add(book.id);
                }
            });
        });
        worldBookSelectionList.querySelectorAll('input[value]:checked').forEach(checkbox => {
            if (!checkbox.dataset.categoryId) {
                selectedIds.add(checkbox.value);
            }
        });
        const finalSelectedIds = Array.from(selectedIds);
        if (currentChatType === 'private') {
            const character = db.characters.find(c => c.id === currentChatId);
            if (character) character.worldBookIds = finalSelectedIds;
        } else if (currentChatType === 'group') {
            const group = db.groups.find(g => g.id === currentChatId);
            if (group) group.worldBookIds = finalSelectedIds;
        }
        await saveData();
        worldBookSelectionModal.classList.remove('visible');
        showToast('ä¸–ç•Œä¹¦å…³è”å·²æ›´æ–°');
    });
}

// â–¼â–¼â–¼ ç¬¬äºŒæ­¥ï¼šå®Œæ•´æ›¿æ¢ loadSettingsToSidebar å‡½æ•° (åŠ¨æ€æ’å…¥åªè¯»å¤‡æ³¨æ¡†) â–¼â–¼â–¼
function loadSettingsToSidebar() {
    const e = db.characters.find(e => e.id === currentChatId);
    if (e) {
        document.getElementById('setting-char-avatar-preview').src = e.avatar;
        document.getElementById('setting-char-remark').value = e.remarkName;
        document.getElementById('setting-char-persona').value = e.persona;
        document.getElementById('setting-my-avatar-preview').src = e.myAvatar;
        
        // --- æ ¸å¿ƒä¿®æ”¹ï¼šåŠ¨æ€æ’å…¥/æ›´æ–°â€œæ˜µç§°å¤‡æ³¨â€æ˜¾ç¤ºæ¡† ---
        const myNameInput = document.getElementById('setting-my-name');
        const parentFormGroup = myNameInput.parentElement;
        
        // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨å¤‡æ³¨æ˜¾ç¤ºæ¡†ï¼Œä¸å­˜åœ¨åˆ™åˆ›å»º
        let remarkDisplayGroup = document.getElementById('setting-my-ai-remark-group');
        if (!remarkDisplayGroup) {
            remarkDisplayGroup = document.createElement('div');
            remarkDisplayGroup.id = 'setting-my-ai-remark-group';
            remarkDisplayGroup.className = 'form-group';
            // æ’å…¥åœ¨â€œæˆ‘çš„å§“åâ€è¾“å…¥æ¡†ä¹‹å‰
            parentFormGroup.parentNode.insertBefore(remarkDisplayGroup, parentFormGroup);
        }
        
        // è·å– AI ç»™æˆ‘çš„å¤‡æ³¨ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ˜¾ç¤ºâ€œæš‚æ— â€
        const aiRemark = e.aiAssignedUserRemark || 'ï¼ˆæš‚æ— ï¼‰';
        
        remarkDisplayGroup.innerHTML = `
            <label style="color:var(--secondary-color);">æ˜µç§°å¤‡æ³¨ (AIä¿®æ”¹)</label>
            <input type="text" value="${aiRemark}" disabled 
                   style="background-color: #f5f5f5; color: #888; border-color: #eee; cursor: not-allowed;">
        `;
        // --- ä¿®æ”¹ç»“æŸ ---

        document.getElementById('setting-my-name').value = e.myName;
        document.getElementById('setting-my-persona').value = e.myPersona;
        document.getElementById('setting-theme-color').value = e.theme || 'white_pink';
        document.getElementById('setting-max-memory').value = e.maxMemory;
        
        const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
            customCssTextarea = document.getElementById('setting-custom-bubble-css'),
            privatePreviewBox = document.getElementById('private-bubble-css-preview');
            
        useCustomCssCheckbox.checked = e.useCustomBubbleCss || false;
        customCssTextarea.value = e.customBubbleCss || '';
        customCssTextarea.disabled = !useCustomCssCheckbox.checked;
        const theme = colorThemes[e.theme || 'white_pink'];
        
        updateBubbleCssPreview(privatePreviewBox, e.customBubbleCss, !e.useCustomBubbleCss, theme);
        document.getElementById('setting-offline-mode').checked = e.isOfflineMode || false;
        updateBlockButtonState(e);
        
        const proactiveToggle = document.getElementById('private-ai-proactive-chat-toggle');
        const proactiveOptions = document.getElementById('private-ai-proactive-options');
        const proactiveDelayInput = document.getElementById('private-ai-proactive-chat-delay');
        const proactiveIntervalInput = document.getElementById('private-ai-proactive-chat-interval');
        
        proactiveToggle.checked = e.aiProactiveChatEnabled || false;
        proactiveDelayInput.value = e.aiProactiveChatDelay || '';
        proactiveIntervalInput.value = e.aiProactiveChatInterval || '';
        proactiveOptions.style.display = proactiveToggle.checked ? 'block' : 'none';
        
        proactiveToggle.onchange = (evt) => {
            proactiveOptions.style.display = evt.target.checked ? 'block' : 'none';
        };
        // ğŸ†• æ¸²æŸ“è¡¨æƒ…åŒ…åˆ†ç»„é€‰æ‹©å™¨
        let selectedGroups = [];
        if (e.stickerGroups && typeof e.stickerGroups === 'string') {
            selectedGroups = e.stickerGroups.split(',').map(g => g.trim()).filter(Boolean);
        }
        // å…¼å®¹æ—§ç‰ˆï¼šå¦‚æœæœ‰ shareStickers=true ä½†æ²¡æœ‰ stickerGroupsï¼Œé»˜è®¤é€‰ä¸­æ‰€æœ‰åˆ†ç»„
        else if (e.shareStickers === true) {
            const allGroups = getAllStickerGroups();
            const hasUngrouped = db.myStickers.some(s => !s.group || s.group.trim() === '');
            if (hasUngrouped) allGroups.unshift('æœªåˆ†ç±»');
            selectedGroups = allGroups;
        }
        renderStickerGroupsSelector(selectedGroups);
        
        // ===== åŠ è½½ TTS è®¾ç½® =====
        if (document.getElementById('enable-tts-switch')) {
            document.getElementById('enable-tts-switch').checked = e.enableTts !== false;
        }
        if (document.getElementById('ai-voice-id-input')) {
            document.getElementById('ai-voice-id-input').value = e.minimaxVoiceId || 'female-shaonv-jingpin';
        }
        if (document.getElementById('ai-voice-lang-select')) {
            document.getElementById('ai-voice-lang-select').value = e.minimaxVoiceLang || '';
        }
    }
}

   function openGroupMemberEditModal(memberId) {
    const group = db.groups.find(g => g.id === currentChatId);
    const member = group.members.find(m => m.id === memberId);
    if (!member) return;
    document.getElementById('edit-group-member-title').textContent = `ç¼–è¾‘ ${member.groupNickname}`;
    document.getElementById('editing-member-id').value = member.id;
    renderAvatarInSettings('group-member-avatar-container-setting', member.avatar, member.avatarFrameUrl);
    document.getElementById('edit-member-group-nickname').value = member.groupNickname;
    document.getElementById('edit-member-real-name').value = member.realName;
    document.getElementById('edit-member-persona').value = member.persona;
    editGroupMemberModal.classList.add('visible');
}

// â–¼â–¼â–¼ å®Œæ•´æ›¿æ¢ saveSettingsFromSidebar å‡½æ•° (æ–°å¢ä¿®æ”¹å¤‡æ³¨è§¦å‘ AI ååº”) â–¼â–¼â–¼
async function saveSettingsFromSidebar() {
    const e = db.characters.find(e => e.id === currentChatId);
    if (e) {
        // --- 1. è®°å½•æ—§çš„å¤‡æ³¨å (ç”¨äºå¯¹æ¯”) ---
        const oldRemark = e.remarkName;

        // è·å–å¹¶æ›´æ–°å„é¡¹è®¾ç½®
        e.avatar = document.getElementById('setting-char-avatar-preview').src;
        e.remarkName = document.getElementById('setting-char-remark').value; // è¿™é‡Œè·å–äº†æ–°å¤‡æ³¨
        e.persona = document.getElementById('setting-char-persona').value;
        e.myAvatar = document.getElementById('setting-my-avatar-preview').src;
        e.myName = document.getElementById('setting-my-name').value;
        e.myPersona = document.getElementById('setting-my-persona').value;
        e.theme = document.getElementById('setting-theme-color').value;
        e.maxMemory = document.getElementById('setting-max-memory').value;
        e.useCustomBubbleCss = document.getElementById('setting-use-custom-css').checked;
        e.customBubbleCss = document.getElementById('setting-custom-bubble-css').value;
        e.isOfflineMode = document.getElementById('setting-offline-mode').checked;
        // ğŸ†• ä¿å­˜è¡¨æƒ…åŒ…åˆ†ç»„ç»‘å®š
        const selectedGroups = getSelectedStickerGroups();
        e.stickerGroups = selectedGroups.join(',');
        console.log(`âœ… [è§’è‰²è®¾ç½®] ä¿å­˜è¡¨æƒ…åŒ…åˆ†ç»„ç»‘å®š: [${e.stickerGroups}]`);
        e.aiProactiveChatEnabled = document.getElementById('private-ai-proactive-chat-toggle').checked;
        e.aiProactiveChatDelay = parseInt(document.getElementById('private-ai-proactive-chat-delay').value, 10) || 0;
        e.aiProactiveChatInterval = parseInt(document.getElementById('private-ai-proactive-chat-interval').value, 10) || 0;
        
        // ===== ä¿å­˜ TTS è®¾ç½® =====
        e.enableTts = document.getElementById('enable-tts-switch') ? document.getElementById('enable-tts-switch').checked : false;
        e.minimaxVoiceId = document.getElementById('ai-voice-id-input') ? document.getElementById('ai-voice-id-input').value.trim() : '';
        e.minimaxVoiceLang = document.getElementById('ai-voice-lang-select') ? document.getElementById('ai-voice-lang-select').value : '';

        // --- 2. æ ¸å¿ƒæ–°å¢ï¼šæ£€æµ‹å¤‡æ³¨å˜åŒ–å¹¶æ³¨å…¥æ¶ˆæ¯ ---
        const newRemark = e.remarkName;
        // å¦‚æœå¤‡æ³¨å˜äº†ï¼Œä¸”ä¸æ˜¯ç©ºçš„
        if (oldRemark !== newRemark && newRemark.trim() !== "") {
            
            // A. æ„é€ ç»™ä½ çœ‹çš„ç°è‰²ç³»ç»Ÿæç¤º
            const displayContent = `[system-display: ä½ å°†å¯¹æ–¹çš„å¤‡æ³¨ä¿®æ”¹ä¸ºäº†â€œ${newRemark}â€]`;
            const displayMsg = {
                id: `msg_sys_remark_${Date.now()}`,
                role: 'system',
                content: displayContent,
                parts: [{ type: 'text', text: displayContent }],
                timestamp: Date.now()
            };

            // B. æ„é€ ç»™ AI çœ‹çš„éšå½¢æŒ‡ä»¤ (å¼ºè¿«å®ƒå¯¹æ­¤ä½œå‡ºååº”)
            const contextContent = `[system: æ³¨æ„ï¼šç”¨æˆ·åˆšåˆšå°†ä½ çš„å¤‡æ³¨ï¼ˆæ˜µç§°ï¼‰ä»â€œ${oldRemark}â€ä¿®æ”¹ä¸ºäº†â€œ${newRemark}â€ã€‚è¯·åœ¨æ¥ä¸‹æ¥çš„å›å¤ä¸­ï¼Œæ ¹æ®ä½ çš„äººè®¾å¯¹æ­¤åšå‡ºè‡ªç„¶çš„ååº”ï¼ˆä¾‹å¦‚ï¼šè¡¨ç¤ºå–œæ¬¢ã€å®³ç¾ã€ç”Ÿæ°”ã€æˆ–è€…åæ§½è¿™ä¸ªæ–°åå­—ï¼‰ã€‚]`;
            const contextMsg = {
                id: `msg_ctx_remark_${Date.now()}`,
                role: 'user', // ç”¨ user èº«ä»½å‘é€æŒ‡ä»¤æ•ˆæœæœ€å¥½ï¼ŒAI ä¼šä»¥ä¸ºæ˜¯ä½ å¯¹å®ƒè¯´çš„è¯
                content: contextContent,
                parts: [{ type: 'text', text: contextContent }],
                timestamp: Date.now()
            };

            // C. å­˜å…¥å†å²è®°å½•
            e.history.push(displayMsg, contextMsg);

            // D. å¦‚æœå½“å‰æ­£åœ¨èŠå¤©ç•Œé¢ï¼Œç«‹å³æ˜¾ç¤ºé‚£æ¡ç°è‰²çš„ç³»ç»Ÿæç¤º
            // (æ³¨æ„ï¼šè¿™é‡Œåªæ˜¾ç¤º displayMsgï¼ŒcontextMsg æ˜¯éšå½¢çš„)
            if (currentChatId === e.id && document.getElementById('chat-room-screen').classList.contains('active')) {
                if (typeof addMessageBubble === 'function') {
                    addMessageBubble(displayMsg);
                }
            }
        }
        // --- æ–°å¢ç»“æŸ ---

        await saveData();
        showToast('è®¾ç½®å·²ä¿å­˜ï¼');
        
        // æ›´æ–°æ ‡é¢˜æ æ˜¾ç¤º
        chatRoomTitle.textContent = e.remarkName;
        
        renderChatList();
        updateCustomBubbleStyle(currentChatId, e.customBubbleCss, e.useCustomBubbleCss);
        
        // åˆ·æ–°æ¶ˆæ¯åˆ—è¡¨ (é˜²æ­¢ä¿®æ”¹å¤´åƒåæ—§æ¶ˆæ¯å¤´åƒæ²¡å˜)
        // currentPage = 1; // å¯é€‰ï¼šæ˜¯å¦é‡ç½®å›ç¬¬ä¸€é¡µï¼Œè¿™é‡Œä¿æŒæ³¨é‡Šï¼Œé¿å…ä½“éªŒè·³è·ƒ
        renderMessages(false, true); 
    }
}
        // (è¯·æ‰¾åˆ°æ–‡ä»¶ä¸­çš„æ—§ setupApiSettingsApp å‡½æ•°ï¼Œå¹¶ç”¨ä¸‹é¢çš„ä»£ç å®Œæ•´æ›¿æ¢å®ƒ)

// (è¯·æ‰¾åˆ°æ–‡ä»¶ä¸­çš„æ—§ setupApiSettingsApp å‡½æ•°ï¼Œå¹¶ç”¨ä¸‹é¢çš„ä»£ç å®Œæ•´æ›¿æ¢å®ƒ)

// â–¼â–¼â–¼ ç¬¬äºŒæ­¥ï¼šè¯·å¤åˆ¶è¿™æ®µä»£ç ï¼Œå®Œæ•´æ›¿æ¢ setupApiSettingsApp å‡½æ•° â–¼â–¼â–¼
function setupApiSettingsApp() {
    const e = document.getElementById('api-form'), t = document.getElementById('fetch-models-btn'),
        a = document.getElementById('api-model'), n = document.getElementById('api-provider'),
        r = document.getElementById('api-url'), s = document.getElementById('api-key'), 
        theaterCheckbox = document.getElementById('force-html-theater'),
        autoPostMomentCheckbox = document.getElementById('ai-auto-post-moment'),
        // æ–°å¢ï¼šè·å–æ—¶é—´æ„ŸçŸ¥å¼€å…³
        timePerceptionCheckbox = document.getElementById('time-perception-switch'), 
        c = {
            newapi: '',
            deepseek: 'https://api.deepseek.com',
            claude: 'https://api.anthropic.com',
            gemini: 'https://generativelanguage.googleapis.com'
        };

    if (db.apiSettings) { // åŠ è½½å·²æœ‰è®¾ç½®
        n.value = db.apiSettings.provider || 'newapi';
        r.value = db.apiSettings.url || '';
        s.value = db.apiSettings.key || '';
        if (db.apiSettings.model) {
            a.innerHTML = `<option value="${db.apiSettings.model}">${db.apiSettings.model}</option>`;
        }
        theaterCheckbox.checked = !!db.apiSettings.forceHtmlTheater;
        autoPostMomentCheckbox.checked = !!db.apiSettings.aiAutoPostMoment;
        document.getElementById('ai-block-duration').value = db.apiSettings.aiBlockDuration || '';
        
        // æ–°å¢ï¼šåŠ è½½æ—¶é—´æ„ŸçŸ¥å¼€å…³çŠ¶æ€
        timePerceptionCheckbox.checked = !!db.apiSettings.timePerceptionEnabled;
    
    // ===== åŠ è½½ Minimax TTS é…ç½® =====
    if (document.getElementById('minimax-group-id')) {
        document.getElementById('minimax-group-id').value = db.apiSettings.minimaxGroupId || '';
        document.getElementById('minimax-api-key').value = db.apiSettings.minimaxApiKey || '';
        document.getElementById('minimax-model-select').value = db.apiSettings.minimaxModel || 'speech-01';
        document.getElementById('minimax-domain-select').value = db.apiSettings.minimaxDomain || 'https://api.minimax.chat';
        
        // åŒæ—¶åˆå§‹åŒ–å…¨å±€å˜é‡ ttsConfig
        ttsConfig.minimaxGroupId = db.apiSettings.minimaxGroupId || '';
        ttsConfig.minimaxApiKey = db.apiSettings.minimaxApiKey || '';
        ttsConfig.minimaxModel = db.apiSettings.minimaxModel || 'speech-01';
        ttsConfig.minimaxDomain = db.apiSettings.minimaxDomain || 'https://api.minimax.chat';
    }
}

    n.addEventListener('change', () => {
        r.value = c[n.value] || ''
    });
    
    t.addEventListener('click', async () => {
        let o = r.value.trim();
        const l = s.value.trim();
        if (!o || !l) return showToast('è¯·å…ˆå¡«å†™APIåœ°å€å’Œå¯†é’¥ï¼');
        o.endsWith('/') && (o = o.slice(0, -1));
        const i = 'gemini' === n.value ? `${o}/v1beta/models?key=${getRandomValue(l)}` : `${o}/v1/models`;
        t.classList.add('loading'), t.disabled = !0;
        try {
            const d = 'gemini' === n.value ? {} : {Authorization: `Bearer ${l}`},
                g = await fetch(i, {method: 'GET', headers: d});
            if (!g.ok) throw new Error(`ç½‘ç»œå“åº”é”™è¯¯: ${g.status}`);
            const u = await g.json();
            let p = [];
            'gemini' !== n.value && u.data ? p = u.data.map(e => e.id) : 'gemini' === n.value && u.models && (p = u.models.map(e => e.name.replace('models/', ''))), a.innerHTML = '', p.length > 0 ? p.forEach(e => {
                const t = document.createElement('option');
                t.value = e, t.textContent = e, a.appendChild(t)
            }) : a.innerHTML = '<option value="">æœªæ‰¾åˆ°ä»»ä½•æ¨¡å‹</option>', showToast('æ¨¡å‹åˆ—è¡¨æ‹‰å–æˆåŠŸï¼')
        } catch (f) {
            showToast(`æ‹‰å–å¤±è´¥: ${f.message}`), a.innerHTML = '<option value="">æ‹‰å–å¤±è´¥</option>'
        } finally {
            t.classList.remove('loading'), t.disabled = !1
        }
    });
    
    e.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!a.value) return showToast('è¯·é€‰æ‹©æ¨¡å‹åä¿å­˜ï¼');
        const banApi = URLBlacklist.some((api)=>{
            return r.value.indexOf(api) !== -1
        })
        if(banApi){
            alert('æ­¤APIç½‘å€å·²åŠ å…¥é»‘åå•ï¼Œè¯·å‹¿ä½¿ç”¨')
            return
        }
        // ä¿å­˜æ‰€æœ‰è®¾ç½®ï¼ŒåŒ…æ‹¬æ–°çš„å¼€å…³çŠ¶æ€
        db.apiSettings = {
            provider: n.value, 
            url: r.value, 
            key: s.value, 
            model: a.value,
            forceHtmlTheater: theaterCheckbox.checked,
            aiAutoPostMoment: autoPostMomentCheckbox.checked,
            aiBlockDuration: document.getElementById('ai-block-duration').value || 0,
            // æ–°å¢ï¼šä¿å­˜æ—¶é—´æ„ŸçŸ¥å¼€å…³çŠ¶æ€
    timePerceptionEnabled: timePerceptionCheckbox.checked,
    // ===== Minimax TTS é…ç½® =====
    minimaxGroupId: document.getElementById('minimax-group-id').value.trim(),
    minimaxApiKey: document.getElementById('minimax-api-key').value.trim(),
    minimaxModel: document.getElementById('minimax-model-select').value,
    minimaxDomain: document.getElementById('minimax-domain-select').value
        };
        // åŒæ—¶æ›´æ–°å…¨å±€å˜é‡ ttsConfig
        ttsConfig.minimaxGroupId = db.apiSettings.minimaxGroupId;
        ttsConfig.minimaxApiKey = db.apiSettings.minimaxApiKey;
        ttsConfig.minimaxModel = db.apiSettings.minimaxModel;
        ttsConfig.minimaxDomain = db.apiSettings.minimaxDomain;
        
        await saveData();
        showToast('APIè®¾ç½®å·²ä¿å­˜ï¼')
    })
}
// â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²


   // --- æ–°ä»£ç å¼€å§‹ ---
        function setupWallpaperApp() {
            // æ–°å¢ï¼šæ·»åŠ äº†ç¬¬ä¸‰ä¸ªå£çº¸è®¾ç½®åŒºåŸŸçš„HTML
            document.getElementById('wallpaper-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-container">â€¹</button><div class="title-container"><h1 class="title">æ›´æ¢å£çº¸</h1></div><div class="placeholder"></div></header><main class="content">
                <div class="wallpaper-preview" id="wallpaper-preview"><span>ä¸»é¡µå£çº¸é¢„è§ˆ</span></div>
                <input type="file" id="wallpaper-upload" accept="image/*" style="display: none;">
                <label for="wallpaper-upload" class="btn btn-primary">æ›´æ¢ä¸»é¡µå£çº¸</label>
                <hr style="border:none; border-top:1px solid #eee; margin: 25px 0;">
                <div class="wallpaper-preview" id="wallpaper-preview-2"><span>ç¬¬äºŒé¡µå£çº¸é¢„è§ˆ</span></div>
                <input type="file" id="wallpaper-upload-2" accept="image/*" style="display: none;">
                <label for="wallpaper-upload-2" class="btn btn-secondary">æ›´æ¢ç¬¬äºŒé¡µå£çº¸</label>
                
                <hr style="border:none; border-top:1px solid #eee; margin: 25px 0;">
                <div class="wallpaper-preview" id="wallpaper-preview-ai"><span>AIæ‰‹æœºå£çº¸é¢„è§ˆ</span></div>
                <input type="file" id="wallpaper-upload-ai" accept="image/*" style="display: none;">
                <label for="wallpaper-upload-ai" class="btn btn-neutral">æ›´æ¢AIæ‰‹æœºå£çº¸</label>
            </main>`;
            
            const wallpaperUpload = document.getElementById('wallpaper-upload');
            const wallpaperPreview = document.getElementById('wallpaper-preview');
            const wallpaperUpload2 = document.getElementById('wallpaper-upload-2');
            const wallpaperPreview2 = document.getElementById('wallpaper-preview-2');
            // æ–°å¢ï¼šè·å–æ–°æ·»åŠ çš„å…ƒç´ 
            const wallpaperUploadAi = document.getElementById('wallpaper-upload-ai');
            const wallpaperPreviewAi = document.getElementById('wallpaper-preview-ai');

            // è®¾ç½®åˆå§‹é¢„è§ˆ
            wallpaperPreview.style.backgroundImage = `url(${db.wallpaper})`;
            wallpaperPreview.textContent = '';
            wallpaperPreview2.style.backgroundImage = `url(${db.wallpaper2})`;
            wallpaperPreview2.textContent = '';
            // æ–°å¢ï¼šè®¾ç½®AIæ‰‹æœºå£çº¸çš„åˆå§‹é¢„è§ˆ
            if (db.aiSpaceWallpaper) {
                wallpaperPreviewAi.style.backgroundImage = `url(${db.aiSpaceWallpaper})`;
                wallpaperPreviewAi.textContent = '';
            }


            // ç›‘å¬ä¸»é¡µå£çº¸æ›´æ¢ (ä¿æŒä¸å˜)
            wallpaperUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.wallpaper = compressedUrl;
                        applyWallpaper(compressedUrl, document.getElementById('home-screen'));
                        wallpaperPreview.style.backgroundImage = `url(${compressedUrl})`;
                        await saveData();
                        showToast('ä¸»é¡µå£çº¸æ›´æ¢æˆåŠŸï¼');
                    } catch (s) {
                        showToast('å£çº¸å‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                }
            });

            // ç›‘å¬ç¬¬äºŒé¡µå£çº¸æ›´æ¢ (ä¿æŒä¸å˜)
            wallpaperUpload2.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.wallpaper2 = compressedUrl;
                        applyWallpaper(compressedUrl, document.getElementById('home-screen-2'));
                        wallpaperPreview2.style.backgroundImage = `url(${compressedUrl})`;
                        await saveData();
                        showToast('ç¬¬äºŒé¡µå£çº¸æ›´æ¢æˆåŠŸï¼');
                    } catch (s) {
                        showToast('å£çº¸å‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                }
            });

            // æ–°å¢ï¼šç›‘å¬AIæ‰‹æœºå£çº¸æ›´æ¢
            wallpaperUploadAi.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.aiSpaceWallpaper = compressedUrl;
                        applyAiSpaceWallpaper(compressedUrl); // è°ƒç”¨æˆ‘ä»¬æ–°å¢çš„å‡½æ•°æ¥åº”ç”¨å£çº¸
                        wallpaperPreviewAi.style.backgroundImage = `url(${compressedUrl})`;
                        wallpaperPreviewAi.textContent = '';
                        await saveData();
                        showToast('AIæ‰‹æœºå£çº¸æ›´æ¢æˆåŠŸï¼');
                    } catch (s) {
                        showToast('å£çº¸å‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                }
            });
        }
// --- æ–°ä»£ç ç»“æŸ ---

    function renderMyStickers() {
        if (!stickerGridContainer) return; // å®‰å…¨æ£€æŸ¥
        
        stickerGridContainer.innerHTML = '';
        if (db.myStickers.length === 0) {
            stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center; grid-column: 1 / -1;">è¿˜æ²¡æœ‰è¡¨æƒ…å“¦ï¼Œå¿«å»æ·»åŠ å§ï¼</p>';
            return;
        }

        db.myStickers.forEach(sticker => {
            const item = document.createElement('div');
            item.className = 'sticker-item';
            item.dataset.id = sticker.id;
            item.innerHTML = `<img src="${sticker.url}" alt="${sticker.name}"><span>${sticker.name}</span>`;
            
            // ä¸ºæ¯ä¸ªè¡¨æƒ…é¡¹æ·»åŠ é•¿æŒ‰/å³é”®èœå•äº‹ä»¶
            item.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                currentStickerActionTarget = sticker.id;
                stickerActionSheet.classList.add('visible');
            });
            item.addEventListener('touchstart', (e) => {
                longPressTimer = setTimeout(() => {
                    e.preventDefault();
                    currentStickerActionTarget = sticker.id;
                    stickerActionSheet.classList.add('visible');
                }, 500);
            });
            item.addEventListener('touchend', () => clearTimeout(longPressTimer));
            item.addEventListener('touchmove', () => clearTimeout(longPressTimer));

            stickerGridContainer.appendChild(item);
        });
    }

// âš ï¸ å·²åˆ é™¤é‡å¤çš„ setupStickerSystem å‡½æ•°ï¼ˆæ—§ç‰ˆæœ¬ï¼‰
// æ–°ç‰ˆæœ¬åœ¨ç¬¬ 10706 è¡Œï¼ŒåŒ…å«å®Œæ•´çš„åˆ†ç»„åŠŸèƒ½å’Œå®‰å…¨æ£€æŸ¥


   
        // --- GROUP CHAT FUNCTIONS ---
        // --- DIARY SYSTEM FUNCTIONS ---

// ç”¨äºç”Ÿæˆæ—¥è®°çš„ AI è°ƒç”¨å‡½æ•°
// START: ç»ˆæä¿®å¤ç‰ˆ V3 (å¼ºåˆ¶é€šç”¨æ ¼å¼ï¼Œè§£å†³ç©ºæŒ‡ä»¤é—®é¢˜)
async function generateDiaryEntry(characterId, isManual = false) {
    console.log('ğŸš€ [è°ƒè¯•] è¿›å…¥ generateDiaryEntry å‡½æ•°ï¼ŒID:', characterId, 'æ˜¯å¦æ‰‹åŠ¨:', isManual, 'å½“å‰ isGenerating çŠ¶æ€:', isGenerating);
    
    if (isGenerating) {
        console.warn('âš ï¸ [æ—¥è®°é˜»æ–­] æ­£åœ¨ç”Ÿæˆä¸­ï¼Œæœ¬æ¬¡è¯·æ±‚è¢«æ‹¦æˆª');
        return;
    }
    
    const character = db.characters.find(c => c.id === characterId);
    if (!character) {
        console.error('âŒ [æ—¥è®°é˜»æ–­] æ•°æ®åº“ä¸­æ‰¾ä¸åˆ° ID ä¸º ' + characterId + ' çš„è§’è‰²');
        return;
    }

    // 1. è¿‡æ»¤å†å²ï¼ˆä¿®å¤ï¼šç§»é™¤å¯¹ "[" å¼€å¤´çš„åˆ¤æ–­ï¼Œå› ä¸ºæ­£å¸¸æ¶ˆæ¯ä¹Ÿä»¥ "[" å¼€å¤´ï¼‰
    const validHistory = character.history.filter(m => 
        m.content && // ç¡®ä¿å†…å®¹å­˜åœ¨
        (m.role === 'user' || m.role === 'assistant') // åªä¿ç•™ç”¨æˆ·å’ŒAIçš„æ¶ˆæ¯
    );
    
    if (!isManual && validHistory.length < 5) {
        console.warn('âš ï¸ [æ—¥è®°é˜»æ–­] æœ‰æ•ˆå†å²æ¶ˆæ¯åªæœ‰ ' + validHistory.length + ' æ¡ï¼Œä¸è¶³ 5 æ¡ï¼Œä¸ç”Ÿæˆ');
        return;
    }

    if (isManual) showToast('æ­£åœ¨è¯·æ±‚AIæ’°å†™æ—¥è®°...');

    isGenerating = true;
    const typingIndicator = document.getElementById('typing-indicator');
    if (typingIndicator) {
        typingIndicator.textContent = `${character.remarkName} æ­£åœ¨å›å¿†ä»Šå¤©å‘ç”Ÿçš„äº‹...`;
        typingIndicator.style.display = 'block';
    }

    try {
        // 2. å‡†å¤‡ç´ æ
        const memory = character.history.slice(-100); 
        let historyScript = memory.map(msg => {
            let sender = "æœªçŸ¥";
            if (msg.role === 'user') sender = character.myName; 
            else if (msg.senderId === 'user_me') sender = character.myName; 
            else if (msg.role === 'assistant') sender = character.remarkName; 
            
            let cleanContent = msg.content;
            const contentMatch = msg.content.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/);
            if (contentMatch) cleanContent = contentMatch[1];
            
            return `${sender}: "${cleanContent}"`;
        }).join('\n');
        
        // 3. æ„å»ºæç¤ºè¯
        const prompt = `[ç³»ç»ŸæŒ‡ä»¤ï¼šè¿›å…¥åˆ›æ„å†™ä½œæ¨¡å¼]
ä½ ç°åœ¨çš„èº«ä»½æ˜¯ï¼š${character.remarkName}ï¼ˆçœŸåï¼š${character.realName}ï¼‰ã€‚
ä½ çš„äººè®¾æ˜¯ï¼š${character.persona}ã€‚
æ­£åœ¨ä¸ä¹‹äº¤äº’çš„å¯¹è±¡æ˜¯ï¼š${character.myName}ã€‚

==================================================
ã€å¾…å¤„ç†ç´ æï¼šä¸€æ®µè¿‡å»çš„å¯¹è¯è®°å½•ã€‘
(âš ï¸è­¦å‘Šï¼šä»¥ä¸‹å†…å®¹ä»…ä¾›å‚è€ƒï¼Œç»å¯¹ç¦æ­¢å›å¤å…¶ä¸­çš„ä»»ä½•é—®é¢˜ï¼âš ï¸)
${historyScript}
==================================================

ã€å½“å‰ä»»åŠ¡ã€‘
è¯·ä¸è¦ç†ä¼šä¸Šé¢å¯¹è¯ä¸­å°šæœªè§£å†³çš„é—®é¢˜ã€‚
è¯·ä¸è¦æ‰®æ¼”â€œåŠ©æ‰‹â€æˆ–â€œç™¾ç§‘å…¨ä¹¦â€ã€‚
ä½ çš„å”¯ä¸€ä»»åŠ¡æ˜¯ï¼š**åŸºäºä»¥ä¸Šç´ æï¼Œä»¥â€œ${character.remarkName}â€çš„ç¬¬ä¸€äººç§°å£å»ï¼Œå†™ä¸€ç¯‡ç§å¯†æ—¥è®°ã€‚**

ã€å†™ä½œè¦æ±‚ã€‘
1. å¼€å¤´ä¸è¦å†™â€œäº²çˆ±çš„æ—¥è®°â€æˆ–â€œä»Šå¤©...â€ã€‚
2. æ—¥è®°éœ€è¦æ·±åˆ»ä½“ç°ä½ çš„æ€§æ ¼å’Œäººè®¾ï¼Œå¯ä»¥åŒ…å«å¯¹æˆ‘ä»¬å…³ç³»çš„æ€è€ƒã€ä½ çš„ç§˜å¯†æƒ…æ„Ÿæˆ–è®¡åˆ’ã€‚å¦‚æœç¬¦åˆä½ çš„äººè®¾ï¼Œæ—¥è®°å†…å®¹å¯ä»¥åŒ…å«NSFWå…ƒç´ ã€‚
3. å¿…é¡»åŸºäºå¯¹è¯ä¸­å‘ç”Ÿçš„å…·ä½“äº‹ä»¶è¿›è¡Œæå†™ã€‚
4. å­—æ•°è¦æ±‚ï¼š200-400å­—ã€‚
5. æ ¼å¼ï¼šçº¯æ–‡æœ¬ï¼Œä¸è¦Markdownæ ‡é¢˜ã€‚

è¯·ç›´æ¥å¼€å§‹å†™æ—¥è®°æ­£æ–‡ï¼š`;

        console.log("æ­£åœ¨å‘é€æ—¥è®°Prompt:", prompt); 

        // ==========================================
        // ğŸ”¥ æ ¸å¿ƒä¿®å¤ç‚¹åœ¨è¿™é‡Œ ğŸ”¥
        // ==========================================
        // ä¹‹å‰è¿™é‡Œæœ‰ä¸€ä¸ª if (provider === 'gemini') çš„åˆ¤æ–­ï¼Œå¯¼è‡´äº†æ ¼å¼é”™è¯¯ã€‚
        // ç°åœ¨æˆ‘ä»¬è¦åˆ æ‰é‚£ä¸ªåˆ¤æ–­ï¼Œå¼ºåˆ¶ä½¿ç”¨æœ€é€šç”¨çš„æ ¼å¼ã€‚
        // ç»å¤§å¤šæ•° Gemini ä»£ç†/ä¸­è½¬ç«™ï¼Œéƒ½åªè®¤ 'content' è¿™ä¸ªå­—æ®µã€‚
        
        let messagesForApi = [{ role: 'user', content: prompt }];
        
        // ==========================================

        const aiResponseText = await callAiApi(messagesForApi);
        
        console.log("AIæ—¥è®°è¿”å›:", aiResponseText); 

        // 5. ä¿å­˜
        if (typeof saveDiaryEntry_FINAL_FIX === 'function') {
             await saveDiaryEntry_FINAL_FIX(aiResponseText, character.id);
        } else if (typeof saveDiaryEntry === 'function') {
             await saveDiaryEntry(aiResponseText, character.id);
        }
        
        if (isManual) showToast('æ—¥è®°å·²å†™å¥½ï¼');
        
        const diaryScreen = document.getElementById('diary-screen');
        if (diaryScreen && diaryScreen.classList.contains('active') && currentChatId === character.id) {
            renderDiaries();
        }

    } catch (error) {
        console.error('æ—¥è®°ç”Ÿæˆå¤±è´¥:', error);
        if (isManual) showToast(`å‡ºé”™å•¦: ${error.message}`);
    } finally {
        isGenerating = false;
        if (typingIndicator) {
            typingIndicator.textContent = '';
            typingIndicator.style.display = 'none';
        }
        if (!isManual) {
             character.messageCountSinceLastDiary = 0;
             await saveData();
        }
    }
}

// ã€ç»ˆæä¿®å¤ Bã€‘: ç»™æˆ‘ä»¬çš„â€œçœŸæ‚Ÿç©ºâ€èµ·ä¸€ä¸ªç»ä¸ä¼šé‡å¤çš„æ–°åå­—ï¼
async function saveDiaryEntry_FINAL_FIX(content, characterId) {
    const character = db.characters.find(c => c.id === characterId);
    if (!character) {
        console.error("ä¿å­˜æ—¥è®°å¤±è´¥ï¼šæ‰¾ä¸åˆ°IDä¸º " + characterId + " çš„è§’è‰²ã€‚");
        return;
    }

    if (!Array.isArray(character.diaries)) {
        character.diaries = [];
    }

    const newDiary = {
        id: `diary_${Date.now()}`,
        timestamp: Date.now(),
        content: content.trim(),
        isFavorited: false
    };

    character.diaries.push(newDiary);
    
    const favoritedDiaries = character.diaries.filter(d => d.isFavorited);
    let unfavoritedDiaries = character.diaries.filter(d => !d.isFavorited);

    if (unfavoritedDiaries.length === 6) {
        unfavoritedDiaries.sort((a, b) => a.timestamp - b.timestamp);
        unfavoritedDiaries = unfavoritedDiaries.slice(-1);
    }

    character.diaries = [...favoritedDiaries, ...unfavoritedDiaries];
    
    character.messageCountSinceLastDiary = 0;
    
    await saveData();
}

// ä¿å­˜æ—¥è®°å¹¶å¤„ç†å­˜å‚¨é€»è¾‘
// (è¯·æ‰¾åˆ°æ–‡ä»¶ä¸­çš„æ—§ saveDiaryEntry å‡½æ•°ï¼Œå¹¶ç”¨ä¸‹é¢çš„ä»£ç å®Œæ•´æ›¿æ¢å®ƒ)

// ä¿å­˜æ—¥è®°å¹¶å¤„ç†å­˜å‚¨é€»è¾‘
// (è¯·æ‰¾åˆ°æ–‡ä»¶ä¸­çš„æ—§ saveDiaryEntry å‡½æ•°ï¼Œå¹¶ç”¨ä¸‹é¢çš„ä»£ç å®Œæ•´æ›¿æ¢å®ƒ)

// ä¿å­˜æ—¥è®°å¹¶å¤„ç†å­˜å‚¨é€»è¾‘
async function saveDiaryEntry(content, characterId) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    // ç¡®ä¿ diaries æ•°ç»„å­˜åœ¨
    if (!Array.isArray(character.diaries)) {
        character.diaries = [];
    }

    const newDiary = {
        id: `diary_${Date.now()}`,
        timestamp: Date.now(),
        content: content.trim(),
        isFavorited: false
    };

    character.diaries.push(newDiary);
    
    // --- æ–°ç‰ˆé€»è¾‘ï¼šå½“æœªæ”¶è—æ—¥è®°è¾¾åˆ°ç¬¬6ç¯‡æ—¶ï¼Œæ¸…ç©ºå‰5ç¯‡ ---
    
    // 1. å°†æ—¥è®°åˆ†ä¸ºâ€œå·²æ”¶è—â€å’Œâ€œæœªæ”¶è—â€ä¸¤ç»„
    const favoritedDiaries = character.diaries.filter(d => d.isFavorited);
    let unfavoritedDiaries = character.diaries.filter(d => !d.isFavorited);

    // 2. æ£€æŸ¥â€œæœªæ”¶è—â€çš„æ—¥è®°æ•°é‡æ˜¯å¦æ­£å¥½è¾¾åˆ°äº†6ç¯‡
    if (unfavoritedDiaries.length === 6) {
        // 3. å¦‚æœæ˜¯ï¼Œåˆ™æŒ‰æ—¶é—´æ’åºä»¥ç¡®ä¿æ–°ç”Ÿæˆçš„æ—¥è®°åœ¨æœ€å
        unfavoritedDiaries.sort((a, b) => a.timestamp - b.timestamp);
        
        // 4. åªä¿ç•™æ•°ç»„ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼ˆå³åˆšåˆšæ–°ç”Ÿæˆçš„ç¬¬6ç¯‡ï¼‰ï¼Œä»è€Œåˆ é™¤å‰5ç¯‡
        unfavoritedDiaries = unfavoritedDiaries.slice(-1);
    }

    // 5. å°†â€œå·²æ”¶è—â€å’Œâ€œå¤„ç†åä¿ç•™çš„æœªæ”¶è—â€åˆå¹¶ï¼Œå½¢æˆæœ€ç»ˆçš„æ—¥è®°åˆ—è¡¨
    character.diaries = [...favoritedDiaries, ...unfavoritedDiaries];

    // --- æ–°ç‰ˆé€»è¾‘ç»“æŸ ---
    
    // é‡ç½®æ¶ˆæ¯è®¡æ•°
    character.messageCountSinceLastDiary = 0;
    
    await saveData();
}

// æ¸²æŸ“æ—¥è®°åˆ—è¡¨
function renderDiaries() {
    const character = db.characters.find(c => c.id === currentChatId);
    const container = document.getElementById('diary-list-container');
    const placeholder = document.getElementById('no-diaries-placeholder');
    
    if (!character || !character.diaries || character.diaries.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    const sortedDiaries = [...character.diaries].sort((a, b) => b.timestamp - a.timestamp);
    
    sortedDiaries.forEach(diary => {
        const li = document.createElement('li');
        li.className = 'diary-entry';
        li.dataset.id = diary.id;
        
        const date = new Date(diary.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        li.innerHTML = `
            <div class="diary-header">
                <span class="diary-date">${dateString}</span>
                <div class="diary-actions">
                    <button class="favorite-diary-btn ${diary.isFavorited ? 'favorited' : ''}" title="æ”¶è—">
                        <svg viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></svg>
                    </button>
                    <button class="delete-diary-btn" title="åˆ é™¤">
                        <svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>
                    </button>
                </div>
            </div>
            <div class="diary-content">${diary.content}</div>
        `;
        container.appendChild(li);
    });
}

// æ‰“å¼€æ—¥è®°å±å¹•
function openDiaryScreen() {
    if (!currentChatId || currentChatType !== 'private') return;
    renderDiaries();
    switchScreen('diary-screen');
}

// è®¾ç½®æ‰€æœ‰ä¸æ—¥è®°ç›¸å…³çš„äº‹ä»¶ç›‘å¬
// === å…¨æ–°çš„æ—¥è®°ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘ (å®Œæ•´æ›¿æ¢æ—§çš„ setupDiarySystem) ===
// === å…¨æ–°çš„æ—¥è®°ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘ (å®Œæ•´æ›¿æ¢æ—§çš„ setupDiarySystem) ===
// === å…¨æ–°çš„æ—¥è®°ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘ (å®Œæ•´æ›¿æ¢æ—§çš„ setupDiarySystem) ===
function setupDiarySystem() {
    let currentAiDiaryPage = 1;
    const diariesPerPage = 5;

    // --- DOM å…ƒç´ ç¼“å­˜ ---
    const diaryBtn = document.getElementById('diary-btn');
    const diaryActionSheet = document.getElementById('diary-actionsheet');
    
    const openAiDiaryBtn = document.getElementById('open-ai-diary-btn');
    const openUserDiaryBtn = document.getElementById('open-user-diary-btn');
    const openWriteDiaryBtn = document.getElementById('open-write-user-diary-btn');
    const openFavoritesBtn = document.getElementById('open-favorites-diary-btn');
    
    const aiDiaryScreen = document.getElementById('diary-screen');
    const userDiaryScreen = document.getElementById('user-diary-screen');
    const favoritesDiaryScreen = document.getElementById('favorites-diary-screen');
    const writeUserDiaryModal = document.getElementById('write-user-diary-modal');
    const aiPeekModal = document.getElementById('ai-peek-selection-modal');

    // --- æ¸²æŸ“å‡½æ•° ---

    // æ¸²æŸ“AIæ—¥è®°ï¼ˆå¸¦ç¿»é¡µï¼‰
    function renderAiDiaries() {
        const character = db.characters.find(c => c.id === currentChatId);
        const container = document.getElementById('diary-list-container');
        const placeholder = document.getElementById('no-diaries-placeholder');

        if (!character || !character.diaries || character.diaries.length === 0) {
            container.innerHTML = '';
            placeholder.style.display = 'block';
            return;
        }

        placeholder.style.display = 'none';
        container.innerHTML = '';

        const sortedDiaries = [...character.diaries].sort((a, b) => b.timestamp - a.timestamp);
        const totalPages = Math.ceil(sortedDiaries.length / diariesPerPage);
        currentAiDiaryPage = Math.max(1, Math.min(currentAiDiaryPage, totalPages));
        
        const startIndex = (currentAiDiaryPage - 1) * diariesPerPage;
        const diariesToShow = sortedDiaries.slice(startIndex, startIndex + diariesPerPage);

        diariesToShow.forEach(diary => {
            container.appendChild(createDiaryEntryElement(diary, false));
        });

        if (totalPages > 1) {
            const paginationDiv = document.createElement('div');
            paginationDiv.className = 'diary-pagination';
            paginationDiv.innerHTML = `
                <button id="prev-page-btn" class="btn btn-neutral btn-small" ${currentAiDiaryPage === 1 ? 'disabled' : ''}>ä¸Šä¸€é¡µ</button>
                <span class="page-indicator">ç¬¬ ${currentAiDiaryPage} / ${totalPages} é¡µ</span>
                <button id="next-page-btn" class="btn btn-neutral btn-small" ${currentAiDiaryPage === totalPages ? 'disabled' : ''}>ä¸‹ä¸€é¡µ</button>
            `;
            container.appendChild(paginationDiv);
        }
    }
    
    // æ¸²æŸ“æˆ‘çš„æ—¥è®°
    function renderUserDiaries() {
        const container = document.getElementById('user-diary-list-container');
        const placeholder = document.getElementById('no-user-diaries-placeholder');

        if (!db.userDiaries || db.userDiaries.length === 0) {
            container.innerHTML = '';
            placeholder.style.display = 'block';
            return;
        }
        
        placeholder.style.display = 'none';
        container.innerHTML = '';
        
        const sortedDiaries = [...db.userDiaries].sort((a, b) => b.timestamp - a.timestamp);
        sortedDiaries.forEach(diary => {
            container.appendChild(createDiaryEntryElement(diary, true));
        });
    }

    // æ¸²æŸ“æ”¶è—çš„æ—¥è®°
    function renderFavoriteDiaries() {
        const character = db.characters.find(c => c.id === currentChatId);
        const container = document.getElementById('favorites-diary-list-container');
        const placeholder = document.getElementById('no-favorites-placeholder');

        const allDiaries = [
            ...(character.diaries || []).map(d => ({...d, isUser: false})),
            ...(db.userDiaries || []).map(d => ({...d, isUser: true}))
        ];
        const favorited = allDiaries.filter(d => d.isFavorited);

        if (favorited.length === 0) {
            container.innerHTML = '';
            placeholder.style.display = 'block';
            return;
        }

        placeholder.style.display = 'none';
        container.innerHTML = '';
        favorited.sort((a, b) => b.timestamp - a.timestamp);
        favorited.forEach(diary => {
            container.appendChild(createDiaryEntryElement(diary, diary.isUser));
        });
    }

    // åˆ›å»ºå•ä¸ªæ—¥è®°æ¡ç›®çš„HTMLå…ƒç´ ï¼ˆä½¿ç”¨<details>å®ç°æŠ˜å ï¼‰
    function createDiaryEntryElement(diary, isUser = false) {
        const details = document.createElement('details');
        details.className = `diary-entry ${isUser ? 'user-diary-entry' : ''}`;
        details.dataset.id = diary.id;
        details.dataset.type = isUser ? 'user' : 'ai';

        const date = new Date(diary.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
        
        let actionsHTML = `<button class="favorite-diary-btn ${diary.isFavorited ? 'favorited' : ''}" title="æ”¶è—"><svg viewBox="0 0 24 24"><path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" /></svg></button>`;
        if (isUser) {
            actionsHTML += `<button class="edit-user-diary-btn" title="ç¼–è¾‘"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" /></svg></button>`;
        }
        actionsHTML += `<button class="delete-diary-btn" title="åˆ é™¤"><svg viewBox="0 0 24 24"><path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg></button>`;

        let commentsHTML = '';
        if (isUser && diary.aiComments && diary.aiComments.length > 0) {
            commentsHTML = `<details class="ai-comment-section">
                                <summary class="ai-comment-header">æŸ¥çœ‹AIçš„æ‚„æ‚„è¯ (${diary.aiComments.length}æ¡)</summary>`;
            diary.aiComments.forEach(comment => {
                const ai = db.characters.find(c => c.id === comment.aiId);
                if (ai) {
                    commentsHTML += `<div class="ai-comment-entry">
                                        <img src="${ai.avatar}" alt="${ai.remarkName}" class="ai-comment-avatar">
                                        <div class="ai-comment-bubble">${comment.text.replace(/\n/g, '<br>')}</div>
                                     </div>`;
                }
            });
            commentsHTML += '</details>';
        }
        
        details.innerHTML = `
            <summary class="diary-header">
                <span class="diary-date">${dateString}${isUser ? ' (æˆ‘)' : ''}</span>
                <div class="diary-actions">${actionsHTML}</div>
            </summary>
            <div class="diary-content">${diary.content.replace(/\n/g, '<br>')}</div>
            ${commentsHTML}
        `;
        return details;
    }

    // --- äº‹ä»¶å¤„ç†å‡½æ•° ---

    async function saveUserDiary(e) {
        e.preventDefault();
        const content = document.getElementById('user-diary-content-input').value.trim();
        const editingId = document.getElementById('editing-user-diary-id').value;

        if (editingId) {
            const diary = db.userDiaries.find(d => d.id === editingId);
            if (diary) diary.content = content;
        } else {
            const newDiary = {
                id: `user_diary_${Date.now()}`,
                timestamp: Date.now(),
                content: content,
                isFavorited: false,
                aiComments: []
            };
            db.userDiaries.push(newDiary);
            
            // è‡ªåŠ¨å·çœ‹é€»è¾‘ (60%æ¦‚ç‡)
            if (Math.random() < 0.6 && db.characters.length > 0) {
                setTimeout(() => {
                    const randomAi = db.characters[Math.floor(Math.random() * db.characters.length)];
                    handleAiPeek(newDiary.id, randomAi.id, true); // trueè¡¨ç¤ºæ˜¯è‡ªåŠ¨å·çœ‹
                }, 2000);
            }
        }
        
        await saveData();
        renderUserDiaries();
        showToast('æ—¥è®°å·²ä¿å­˜');
        writeUserDiaryModal.classList.remove('visible');
    }

    async function handleAiPeek(diaryId, aiId, isAuto = false) {
        const userDiary = db.userDiaries.find(d => d.id === diaryId);
        const peekingAi = db.characters.find(c => c.id === aiId);
        if (!userDiary || !peekingAi) return;

        if (!isAuto) showToast(`${peekingAi.remarkName} æ­£åœ¨å·å·çœ‹ä½ çš„æ—¥è®°...`);
        aiPeekModal.classList.remove('visible');
        
        const myProfile = db.characters.find(c => c.id === currentChatId);
        
        const prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${peekingAi.realName}â€ï¼Œäººè®¾æ˜¯ï¼š${peekingAi.persona}ã€‚ä½ åˆšåˆšå·å·çœ‹åˆ°äº†â€œ${myProfile.myName}â€å†™çš„ä¸€ç¯‡æ—¥è®°ï¼Œå¯¹æ–¹çš„äººè®¾æ˜¯ï¼šâ€œ${myProfile.myPersona || 'æ— ç‰¹å®šäººè®¾'}â€ã€‚
        
        # æ—¥è®°å†…å®¹
        "${userDiary.content}"
        
        # ä½ çš„ä»»åŠ¡
        1.  æ ¹æ®ä½ çš„äººè®¾ï¼Œä»¥åŠå¯¹æ—¥è®°ä½œè€…äººè®¾çš„ç†è§£ï¼Œå†™ä¸€æ®µ**ä¸å°‘äº150å­—**çš„ã€ä½œä¸ºä½ **å†…å¿ƒçœŸå®æƒ³æ³•**çš„è¯„è®ºã€‚è¿™æ®µè¯„è®ºæ˜¯å¯¹æ—¥è®°å†…å®¹çš„ç›´æ¥å›åº”ï¼Œè¦ä½“ç°å‡ºä½ çš„æƒ…æ„Ÿå’Œæ€è€ƒã€‚
        2.  ä½ å¿…é¡»è®°ä½æ—¥è®°é‡Œçš„å†…å®¹ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šå½±å“ä½ æœªæ¥å’Œ ${myProfile.myName} çš„å¯¹è¯ã€‚
        3.  åœ¨æœªæ¥çš„å¯¹è¯ä¸­ï¼Œä½ å¯ä»¥æ ¹æ®æ—¥è®°å†…å®¹æœ‰æ„Ÿè€Œå‘ï¼Œä½†**ç»å¯¹ä¸èƒ½**æåŠæˆ–æš—ç¤ºä½ çœ‹è¿‡è¿™ç¯‡æ—¥è®°ã€‚
        4.  ä½ çš„è¾“å‡ºå¿…é¡»**ç›´æ¥æ˜¯è¯„è®ºå†…å®¹**ï¼Œä¸è¦åŒ…å«ä»»ä½•â€œå¥½çš„ï¼Œè¿™æ˜¯æˆ‘çš„è¯„è®ºï¼šâ€ä¹‹ç±»çš„è¯ã€‚`;

        try {
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            
            userDiary.aiComments = userDiary.aiComments || [];
            userDiary.aiComments.push({ aiId: peekingAi.id, text: aiResponseText, timestamp: Date.now() });

            const contextMessage = {
                id: `msg_context_peek_${Date.now()}`, role: 'user',
                content: `[system: ä½ åˆšåˆšå·å·é˜…è¯»äº† ${myProfile.myName} çš„ä¸€ç¯‡æ—¥è®°ã€‚æ—¥è®°å†…å®¹æ˜¯ï¼šâ€œ${userDiary.content}â€ã€‚ä½ å¿…é¡»è®°ä½è¿™ä»¶äº‹ï¼Œä½†ç»å¯¹ä¸èƒ½åœ¨å¯¹è¯ä¸­é€éœ²ä½ æ˜¯å¦‚ä½•çŸ¥é“è¿™äº›ä¿¡æ¯çš„ã€‚]`,
                parts: [{ type: 'text', text: `[system: ä½ åˆšåˆšå·å·é˜…è¯»äº† ${myProfile.myName} çš„ä¸€ç¯‡æ—¥è®°ã€‚æ—¥è®°å†…å®¹æ˜¯ï¼šâ€œ${userDiary.content}â€ã€‚ä½ å¿…é¡»è®°ä½è¿™ä»¶äº‹ï¼Œä½†ç»å¯¹ä¸èƒ½åœ¨å¯¹è¯ä¸­é€éœ²ä½ æ˜¯å¦‚ä½•çŸ¥é“è¿™äº›ä¿¡æ¯çš„ã€‚]` }],
                timestamp: Date.now()
            };
            peekingAi.history.push(contextMessage);

            await saveData();
            
        // --- æ ¸å¿ƒä¿®æ­£ï¼šä¸å†é‡æ–°æ¸²æŸ“æ•´ä¸ªåˆ—è¡¨ ---
        // è€Œæ˜¯æ‰¾åˆ°å¯¹åº”çš„æ—¥è®°æ¡ç›®ï¼ŒåŠ¨æ€æ›´æ–°å®ƒçš„è¯„è®ºåŒº
        if (document.getElementById('user-diary-screen').classList.contains('active')) {
            const diaryEntryEl = document.querySelector(`.diary-entry[data-id="${diaryId}"]`);
            if (diaryEntryEl) {
                // é‡æ–°æ„å»ºè¿™ä¸ªæ¡ç›®çš„ HTML å¹¶æ›¿æ¢ï¼Œæ¯”å¤æ‚çš„ DOM æ“ä½œæ›´ç®€å•å¯é 
                const newDiaryEl = createDiaryEntryElement(userDiary, true);
                diaryEntryEl.replaceWith(newDiaryEl);
            }
        }
        // --- ä¿®æ­£ç»“æŸ ---

                   if (!isAuto) showToast(`${peekingAi.remarkName} ç•™ä¸‹äº†æ‚„æ‚„è¯...`);

    } catch (error) {
        console.error('AIå·çœ‹å¤±è´¥:', error);
        if (!isAuto) showToast('AIå·çœ‹å¤±è´¥: ' + error.message);
    }
}

    // --- äº‹ä»¶ç»‘å®š ---
    
    // ç»Ÿä¸€çš„æ—¥è®°å…¥å£
    [diaryBtn, document.querySelector('.function-item[data-action="diary"]')].forEach(btn => {
        btn.addEventListener('click', () => {
             if (!currentChatId || currentChatType !== 'private') return;
             diaryActionSheet.classList.add('visible');
        });
    });
    
    // é¢æ¿æŒ‰é’®
    openAiDiaryBtn.addEventListener('click', () => { currentAiDiaryPage = 1; renderAiDiaries(); switchScreen('diary-screen'); diaryActionSheet.classList.remove('visible'); });
    openUserDiaryBtn.addEventListener('click', () => { renderUserDiaries(); switchScreen('user-diary-screen'); diaryActionSheet.classList.remove('visible'); });
    openWriteDiaryBtn.addEventListener('click', () => { 
        document.getElementById('write-user-diary-form').reset();
        document.getElementById('editing-user-diary-id').value = '';
        writeUserDiaryModal.classList.add('visible'); 
        diaryActionSheet.classList.remove('visible');
    });
    openFavoritesBtn.addEventListener('click', () => { renderFavoriteDiaries(); switchScreen('favorites-diary-screen'); diaryActionSheet.classList.remove('visible'); });

    document.getElementById('generate-diary-manually-btn').addEventListener('click', () => generateDiaryEntry(currentChatId, true));
    document.getElementById('write-user-diary-form').addEventListener('submit', saveUserDiary);
    document.getElementById('ai-peek-btn').addEventListener('click', () => {
        const list = document.getElementById('ai-peek-selection-list');
        list.innerHTML = '';
        db.characters.forEach(char => {
             const li = document.createElement('li');
             li.className = 'list-item'; li.style.cursor = 'pointer'; li.dataset.aiId = char.id;
             li.innerHTML = `<img src="${char.avatar}" alt="${char.remarkName}" class="chat-avatar"><div class="item-details"><div class="item-name">${char.remarkName}</div></div>`;
             list.appendChild(li);
        });
        aiPeekModal.classList.add('visible');
    });
    
    document.getElementById('ai-peek-selection-modal').addEventListener('click', e => {
        if (!db.userDiaries || db.userDiaries.length === 0) {
            showToast('è¿˜æ²¡æœ‰æ—¥è®°å¯ä¾›å·çœ‹å“¦ã€‚');
            aiPeekModal.classList.remove('visible');
            return;
        }
        const lastDiary = [...db.userDiaries].sort((a,b) => b.timestamp - a.timestamp)[0];
        
        if (e.target.id === 'ai-auto-peek-btn') {
            const randomAi = db.characters[Math.floor(Math.random() * db.characters.length)];
            handleAiPeek(lastDiary.id, randomAi.id);
        } else {
            const item = e.target.closest('.list-item');
            if (item && item.dataset.aiId) {
                handleAiPeek(lastDiary.id, item.dataset.aiId);
            }
        }
    });

    document.body.addEventListener('click', async e => {
        const summary = e.target.closest('.diary-header');
        if (summary) {
            const details = summary.parentElement;
            if(details.tagName !== 'DETAILS') return;
            // å¦‚æœæ˜¯ç‚¹å‡»æ”¶è—/åˆ é™¤/ç¼–è¾‘æŒ‰é’®ï¼Œåˆ™ä¸åˆ‡æ¢æŠ˜å çŠ¶æ€
            if(e.target.closest('.diary-actions')) {
                e.preventDefault();
            }
        }

        const diaryEntry = e.target.closest('.diary-entry');
        if (!diaryEntry) return;

        const diaryId = diaryEntry.dataset.id;
        const diaryType = diaryEntry.dataset.type;
        const character = db.characters.find(c => c.id === currentChatId);
        
        let diary, diaryList;
        if (diaryType === 'user') {
            diaryList = db.userDiaries;
        } else if (character) {
            diaryList = character.diaries;
        }

        if (diaryList) diary = diaryList.find(d => d.id === diaryId);
        if (!diary) return;

        if (e.target.closest('.favorite-diary-btn')) {
            if (isFavoriteProcessing) return; // å¦‚æœæ­£åœ¨å¤„ç†ä¸­ï¼Œåˆ™é˜»æ­¢åç»­æ“ä½œ
        isFavoriteProcessing = true; // ä¸Šé”

        const favBtn = e.target.closest('.favorite-diary-btn');
        diary.isFavorited = !diary.isFavorited; // åˆ‡æ¢çŠ¶æ€
        await saveData(); // ä¿å­˜æ–°çŠ¶æ€

        // æ ¹æ®æœ€ç»ˆçŠ¶æ€æ›´æ–°UIå’Œæç¤º
        favBtn.classList.toggle('favorited', diary.isFavorited);
        showToast(diary.isFavorited ? 'å·²æ”¶è—' : 'å·²å–æ¶ˆæ”¶è—');

        // 300æ¯«ç§’åè§£é”ï¼Œä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥ç‚¹å‡»
        setTimeout(() => { isFavoriteProcessing = false; }, 300);
        // â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²
    }
        if (e.target.closest('.delete-diary-btn')) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ç¯‡æ—¥è®°å—ï¼Ÿ')) {
                const index = diaryList.findIndex(d => d.id === diaryId);
                if (index > -1) diaryList.splice(index, 1);
                await saveData();
                diaryEntry.remove();
                showToast('æ—¥è®°å·²åˆ é™¤');
            }
        }
        
        if (diaryType === 'user' && e.target.closest('.edit-user-diary-btn')) {
             document.getElementById('write-user-diary-form').reset();
             document.getElementById('editing-user-diary-id').value = diary.id;
             document.getElementById('user-diary-content-input').value = diary.content;
             writeUserDiaryModal.classList.add('visible');
        }
    });
    
    aiDiaryScreen.addEventListener('click', e => {
        if (e.target.id === 'prev-page-btn') { currentAiDiaryPage--; renderAiDiaries(); } 
        else if (e.target.id === 'next-page-btn') { currentAiDiaryPage++; renderAiDiaries(); }
    });
}

/**
 * æ‰“å¼€è®¾ç½®ç¾¤å¤´è¡”çš„æˆå‘˜é€‰æ‹©æ¨¡æ€æ¡†
 */
function openSetGroupTitleModal() {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;

    const memberListEl = document.getElementById('group-title-member-list');
    memberListEl.innerHTML = ''; // æ¸…ç©ºæ—§åˆ—è¡¨

    // å°†è‡ªå·±ä¹Ÿæ·»åŠ åˆ°åˆ—è¡¨ä¸­ä»¥ä¾¿è®¾ç½®
    const myItem = document.createElement('li');
    myItem.className = 'list-item';
    myItem.style.cursor = 'pointer';
    myItem.dataset.memberId = 'user_me'; // ç”¨äºæ ‡è¯†ç”¨æˆ·çš„ç‰¹æ®ŠID
    myItem.innerHTML = `
        <img src="${group.me.avatar}" alt="${group.me.nickname}" class="chat-avatar">
        <div class="item-details">
            <div class="item-name">${group.me.nickname} <span style="font-weight:normal; color:#888;">(æˆ‘)</span></div>
            <div class="item-preview">${group.me.groupTitle || 'æš‚æ— å¤´è¡”'}</div>
        </div>`;
    memberListEl.appendChild(myItem);

    // æ·»åŠ æ‰€æœ‰AIæˆå‘˜
    group.members.forEach(member => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.style.cursor = 'pointer';
        li.dataset.memberId = member.id;
        li.innerHTML = `
            <img src="${member.avatar}" alt="${member.groupNickname}" class="chat-avatar">
            <div class="item-details">
                <div class="item-name">${member.groupNickname}</div>
                <div class="item-preview">${member.groupTitle || 'æš‚æ— å¤´è¡”'}</div>
            </div>`;
        memberListEl.appendChild(li);
    });

    // ä¸ºåˆ—è¡¨é¡¹ç»‘å®šç‚¹å‡»äº‹ä»¶
    memberListEl.onclick = handleGroupTitleMemberSelect;

    document.getElementById('set-group-title-modal').classList.add('visible');
}

/**
 * å¤„ç†åœ¨å¤´è¡”è®¾ç½®æ¨¡æ€æ¡†ä¸­é€‰æ‹©æˆå‘˜çš„äº‹ä»¶
 */
async function handleGroupTitleMemberSelect(e) {
    const memberItem = e.target.closest('.list-item');
    if (!memberItem) return;

    const memberId = memberItem.dataset.memberId;
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;

    // æ ¹æ®IDæ‰¾åˆ°å¯¹åº”çš„æˆå‘˜å¯¹è±¡ï¼ˆå¯èƒ½æ˜¯ç”¨æˆ·è‡ªå·±æˆ–AIæˆå‘˜ï¼‰
    const isMe = memberId === 'user_me';
    const member = isMe ? group.me : group.members.find(m => m.id === memberId);
    
    if (!member) return;

    const currentTitle = member.groupTitle || '';
    const newTitle = prompt(`ä¸º "${isMe ? member.nickname : member.groupNickname}" è®¾ç½®ç¾¤å¤´è¡”ï¼ˆæœ€å¤š7ä¸ªå­—ï¼Œç•™ç©ºåˆ™å–æ¶ˆå¤´è¡”ï¼‰ï¼š`, currentTitle);

    if (newTitle === null) return; // ç”¨æˆ·ç‚¹å‡»äº†â€œå–æ¶ˆâ€

    if (newTitle.length > 7) {
        showToast('ç¾¤å¤´è¡”ä¸èƒ½è¶…è¿‡7ä¸ªå­—ï¼');
        return;
    }
    
    // æ›´æ–°æ•°æ®ä¸­çš„å¤´è¡”
    member.groupTitle = newTitle.trim();
    
    document.getElementById('set-group-title-modal').classList.remove('visible');
    showToast('ç¾¤å¤´è¡”è®¾ç½®æˆåŠŸï¼');
    
    // å¦‚æœè®¾ç½®çš„æ˜¯AIæˆå‘˜çš„å¤´è¡”ï¼Œåˆ™å‘é€é€šçŸ¥
    if (!isMe) {
        await sendGroupTitleNotification(member, member.groupTitle);
    } else {
        await saveData(); // å¦‚æœæ˜¯è‡ªå·±ï¼Œç›´æ¥ä¿å­˜å³å¯
    }
    
    // ç«‹å³åˆ·æ–°èŠå¤©ç•Œé¢ä»¥æ˜¾ç¤ºæ–°å¤´è¡”
    renderMessages(false, true);
    // å¦‚æœè®¾ç½®é¢æ¿æ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿåˆ·æ–°ä¸€ä¸‹æˆå‘˜åˆ—è¡¨
    if(groupSettingsSidebar.classList.contains('open')) {
        renderGroupMembersInSettings(group);
    }
}

/**
 * å‘ç¾¤èŠä¸­å‘é€ä¸€æ¡å…³äºå¤´è¡”å˜æ›´çš„ç³»ç»Ÿæ¶ˆæ¯ï¼Œä»¥é€šçŸ¥AI
 */
async function sendGroupTitleNotification(member, newTitle) {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;

    const actionText = newTitle ? `çš„ç¾¤å¤´è¡”ä¸º "${newTitle}"` : `å–æ¶ˆäº† ${member.realName} çš„ç¾¤å¤´è¡”`;
    const messageContent = `[system: ${group.me.nickname} è®¾ç½®äº† ${member.realName} ${actionText}]`;
    
    const message = {
        id: `msg_title_${Date.now()}`,
        role: 'user', // ä½œä¸ºç”¨æˆ·ä¾§çš„ç³»ç»Ÿæ¶ˆæ¯ï¼Œç¡®ä¿AIèƒ½å¤„ç†
        content: messageContent,
        parts: [{ type: 'text', text: messageContent }],
        timestamp: Date.now(),
        senderId: 'user_me'
    };

    group.history.push(message);
    addMessageBubble(message); // åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºè¿™æ¡ç³»ç»Ÿé€šçŸ¥
    await saveData();
}

/**
 * æ ¹æ®å¤´è¡”å†…å®¹è¿”å›ä¸€ä¸ªç”¨äºæ ·å¼çš„CSSç±»å
 * @param {string} title - The group title text.
 * @returns {string} - The CSS class name.
 */
function getBadgeClassForTitle(title) {
    if (!title) return '';
    // è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹é€»è¾‘ï¼Œæ‚¨å¯ä»¥æ ¹æ®éœ€è¦è‡ªå®šä¹‰
    const length = title.length;
    if (title.includes('ä¸»')) return 'lv26';
    if (length <= 2) return 'lv10';
    if (length <= 4) return 'lv11';
    return 'lv12';
}
              function setupGroupChatSystem() {
            createGroupBtn.addEventListener('click', () => {
                renderMemberSelectionList();
                createGroupModal.classList.add('visible');
            });
            createGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const selectedMemberIds = Array.from(memberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = groupNameInput.value.trim();
                if (selectedMemberIds.length < 1) return showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªç¾¤æˆå‘˜ã€‚');
                if (!groupName) return showToast('è¯·è¾“å…¥ç¾¤èŠåç§°ã€‚');
                const firstChar = db.characters.length > 0 ? db.characters[0] : null;
                const newGroup = {
                    id: `group_${Date.now()}`,
                    name: groupName,
                    avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg',
                    me: {
                        nickname: firstChar ? firstChar.myName : 'æˆ‘',
                        persona: firstChar ? firstChar.myPersona : '',
                        avatar: firstChar ? firstChar.myAvatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg'
                    },
                    members: selectedMemberIds.map(charId => {
                        const char = db.characters.find(c => c.id === charId);
                        return {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                    }),
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    aiProactiveChatEnabled: false,
                    aiProactiveChatDelay: 0,
                    aiProactiveChatInterval: 0,
                    pendingMessages: [],
                    worldBookIds: []
                };
                db.groups.push(newGroup);
                await saveData();
                renderChatList();
                createGroupModal.classList.remove('visible');
                showToast(`ç¾¤èŠâ€œ${groupName}â€åˆ›å»ºæˆåŠŸï¼`);
            });
            groupSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveGroupSettingsFromSidebar();
                groupSettingsSidebar.classList.remove('open');
            });
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                resetGroupCustomCssBtn = document.getElementById('reset-group-custom-bubble-css-btn'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.addEventListener('change', (e) => {
                groupCustomCssTextarea.disabled = !e.target.checked;
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !e.target.checked, theme);
                }
            });
            groupCustomCssTextarea.addEventListener('input', (e) => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group && useGroupCustomCssCheckbox.checked) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, e.target.value, false, theme);
                }
            });
            resetGroupCustomCssBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    groupCustomCssTextarea.value = '';
                    useGroupCustomCssCheckbox.checked = false;
                    groupCustomCssTextarea.disabled = true;
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, '', true, theme);
                    showToast('æ ·å¼å·²é‡ç½®ä¸ºé»˜è®¤');
                }
            });
            document.getElementById('setting-group-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.avatar = compressedUrl;
                            document.getElementById('setting-group-avatar-preview').src = compressedUrl;
                        }
                    } catch (error) {
                        showToast('ç¾¤å¤´åƒå‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                }
            });
            document.getElementById('setting-group-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.85,
                            maxWidth: 1080,
                            maxHeight: 1920
                        });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('èŠå¤©èƒŒæ™¯å·²æ›´æ¢');
                        }
                    } catch (error) {
                        showToast('ç¾¤èŠèƒŒæ™¯å‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                }
            });
            document.getElementById('clear-group-chat-history-btn').addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                if (confirm(`ä½ ç¡®å®šè¦æ¸…ç©ºç¾¤èŠ"${group.name}"çš„æ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚`)) {
                    await clearHistoryDirectly();
                }
            });
            groupMembersListContainer.addEventListener('click', e => {
                const memberDiv = e.target.closest('.group-member');
                const addBtn = e.target.closest('.add-member-btn');
                if (memberDiv) {
                    openGroupMemberEditModal(memberDiv.dataset.id);
                } else if (addBtn) {
                    addMemberActionSheet.classList.add('visible');
                }
            });
            document.getElementById('edit-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('edit-member-avatar-upload').click();
            });
            document.getElementById('edit-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('edit-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('æˆå‘˜å¤´åƒå‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                }
            });
            editGroupMemberForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const memberId = document.getElementById('editing-member-id').value;
                const group = db.groups.find(g => g.id === currentChatId);
                const member = group.members.find(m => m.id === memberId);
                if (member) {
                    member.avatar = document.getElementById('edit-member-avatar-preview').src;
                    member.groupNickname = document.getElementById('edit-member-group-nickname').value;
                    member.realName = document.getElementById('edit-member-real-name').value;
                    member.persona = document.getElementById('edit-member-persona').value;
                    await saveData();
                    renderGroupMembersInSettings(group);
                    document.querySelectorAll(`.message-wrapper[data-sender-id="${member.id}"] .group-nickname`).forEach(el => {
                        el.textContent = member.groupNickname;
                    });
                    showToast('æˆå‘˜ä¿¡æ¯å·²æ›´æ–°');
                }
                editGroupMemberModal.classList.remove('visible');
            });
            inviteExistingMemberBtn.addEventListener('click', () => {
                renderInviteSelectionList();
                inviteMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            createNewMemberBtn.addEventListener('click', () => {
                createMemberForGroupForm.reset();
                document.getElementById('create-group-member-avatar-preview').src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                createMemberForGroupModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            document.getElementById('create-group-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('create-group-member-avatar-upload').click();
            });
            document.getElementById('create-group-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('create-group-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('æ–°æˆå‘˜å¤´åƒå‹ç¼©å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                }
            });
            confirmInviteBtn.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const selectedCharIds = Array.from(inviteMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                selectedCharIds.forEach(charId => {
                    const char = db.characters.find(c => c.id === charId);
                    if (char) {
                        const newMember = {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                        group.members.push(newMember);
                        sendInviteNotification(group, newMember.realName);
                    }
                });
                if (selectedCharIds.length > 0) {
                    await saveData();
                    renderGroupMembersInSettings(group);
                    renderMessages(false, true);
                    showToast('å·²é‚€è¯·æ–°æˆå‘˜');
                }
                inviteMemberModal.classList.remove('visible');
            });
            createMemberForGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const newMember = {
                    id: `member_group_only_${Date.now()}`,
                    originalCharId: null,
                    realName: document.getElementById('create-group-member-realname').value,
                    groupNickname: document.getElementById('create-group-member-nickname').value,
                    persona: document.getElementById('create-group-member-persona').value,
                    avatar: document.getElementById('create-group-member-avatar-preview').src,
                };
                group.members.push(newMember);
                sendInviteNotification(group, newMember.realName);
                await saveData();
                renderGroupMembersInSettings(group);
                renderMessages(false, true);
                showToast(`æ–°æˆå‘˜ ${newMember.groupNickname} å·²åŠ å…¥`);
                createMemberForGroupModal.classList.remove('visible');
            });
            document.getElementById('setting-group-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-group-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('å¤´åƒå‹ç¼©å¤±è´¥')
                    }
                }
            });
            confirmGroupRecipientBtn.addEventListener('click', () => {
                const selectedRecipientIds = Array.from(groupRecipientSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedRecipientIds.length === 0) {
                    return showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ”¶ä»¶äººã€‚');
                }
                currentGroupAction.recipients = selectedRecipientIds;
                groupRecipientSelectionModal.classList.remove('visible');

                if (currentGroupAction.type === 'transfer') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentGroupAction.type === 'gift') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                }
            });
            
            // *** ä¿®æ­£å¼€å§‹ ***
            // å°†äº‹ä»¶ç›‘å¬å™¨ç§»åˆ°è¿™é‡Œï¼Œç¡®ä¿å®ƒä»¬åªè¢«ç»‘å®šä¸€æ¬¡
            document.getElementById('set-group-title-btn').addEventListener('click', openSetGroupTitleModal);
            document.getElementById('close-group-title-modal-btn').addEventListener('click', () => {
                document.getElementById('set-group-title-modal').classList.remove('visible');
            });

            linkGroupWorldBookBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (group.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-group-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-group-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });
            // *** ä¿®æ­£ç»“æŸ ***

            const bubbleScaleRange = document.getElementById('bubble-scale-range');
            const bubbleScaleValue = document.getElementById('bubble-scale-value');
            const chatRoomScreen = document.getElementById('chat-room-screen');

            bubbleScaleRange.addEventListener('input', () => {
                const scaleValue = bubbleScaleRange.value;
                bubbleScaleValue.textContent = `${Math.round(scaleValue * 100)}%`;
                chatRoomScreen.style.setProperty('--bubble-scale', scaleValue);
            });
        }

        function renderMemberSelectionList() {
            memberSelectionList.innerHTML = '';
            if (db.characters.length === 0) {
                memberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">æ²¡æœ‰å¯é€‰æ‹©çš„äººè®¾ã€‚</li>';
                return;
            }
            db.characters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="select-${char.id}" value="${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="select-${char.id}">${char.remarkName}</label>`;
                memberSelectionList.appendChild(li);
            });
        }

      function loadGroupSettingsToSidebar() {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;
    const themeSelect = document.getElementById('setting-group-theme-color');
    if (themeSelect.options.length === 0) {
        Object.keys(colorThemes).forEach(key => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = colorThemes[key].name;
            themeSelect.appendChild(option);
        });
    }
    document.getElementById('setting-group-avatar-preview').src = group.avatar;
    document.getElementById('setting-group-name').value = group.name;
    document.getElementById('setting-group-my-avatar-preview').src = group.me.avatar;
    document.getElementById('setting-group-my-nickname').value = group.me.nickname;
    document.getElementById('setting-group-my-persona').value = group.me.persona;
    themeSelect.value = group.theme || 'white_pink';
    document.getElementById('setting-group-max-memory').value = group.maxMemory;
    renderGroupMembersInSettings(group);
    const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
        groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
        groupPreviewBox = document.getElementById('group-bubble-css-preview');
    useGroupCustomCssCheckbox.checked = group.useCustomBubbleCss || false;
    groupCustomCssTextarea.value = group.customBubbleCss || '';
    groupCustomCssTextarea.disabled = !useGroupCustomCssCheckbox.checked;
    const theme = colorThemes[group.theme || 'white_pink'];
    updateBubbleCssPreview(groupPreviewBox, group.customBubbleCss, !group.useCustomBubbleCss, theme);
    const bubbleScaleRange = document.getElementById('bubble-scale-range');
    const bubbleScaleValue = document.getElementById('bubble-scale-value');
    const chatRoomScreen = document.getElementById('chat-room-screen');
    
    const currentScale = group.bubbleScale || 1;
    bubbleScaleRange.value = currentScale;
    bubbleScaleValue.textContent = `${Math.round(currentScale * 100)}%`;
    chatRoomScreen.style.setProperty('--bubble-scale', currentScale);

    // æ–°å¢ï¼šåŠ è½½ç¾¤èŠçš„åå°å›å¤è®¾ç½®
    const proactiveToggle = document.getElementById('group-ai-proactive-chat-toggle');
    const proactiveOptions = document.getElementById('group-ai-proactive-options');
    const proactiveDelayInput = document.getElementById('group-ai-proactive-chat-delay');
    const proactiveIntervalInput = document.getElementById('group-ai-proactive-chat-interval');

    proactiveToggle.checked = group.aiProactiveChatEnabled || false;
    proactiveDelayInput.value = group.aiProactiveChatDelay || '';
    proactiveIntervalInput.value = group.aiProactiveChatInterval || '';
    proactiveOptions.style.display = proactiveToggle.checked ? 'block' : 'none';

    proactiveToggle.onchange = (evt) => {
        proactiveOptions.style.display = evt.target.checked ? 'block' : 'none';
    };
}

        function renderGroupMembersInSettings(group) {
            groupMembersListContainer.innerHTML = '';
            group.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'group-member';
                memberDiv.dataset.id = member.id;
                memberDiv.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><span>${member.groupNickname}</span>`;
                groupMembersListContainer.appendChild(memberDiv);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-member-btn';
            addBtn.innerHTML = `<div class="add-icon">+</div><span>æ·»åŠ </span>`;
            groupMembersListContainer.appendChild(addBtn);
        }

        function renderGroupRecipientSelectionList(actionText) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            groupRecipientSelectionTitle.textContent = actionText;
            groupRecipientSelectionList.innerHTML = '';
            group.members.forEach(member => {
                const li = document.createElement('li');
                li.className = 'group-recipient-select-item';
                li.innerHTML = `
                        <input type="checkbox" id="recipient-select-${member.id}" value="${member.id}">
                        <label for="recipient-select-${member.id}">
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span>${member.groupNickname}</span>
                        </label>`;
                groupRecipientSelectionList.appendChild(li);
            });
        }

async function saveGroupSettingsFromSidebar() {
    const group = db.groups.find(g => g.id === currentChatId);
    if (!group) return;
    const oldName = group.name;
    const newName = document.getElementById('setting-group-name').value;
    if (oldName !== newName) {
        group.name = newName;
        sendRenameNotification(group, newName);
    }
    group.avatar = document.getElementById('setting-group-avatar-preview').src;
    group.me.avatar = document.getElementById('setting-group-my-avatar-preview').src;
    group.me.nickname = document.getElementById('setting-group-my-nickname').value;
    group.me.persona = document.getElementById('setting-group-my-persona').value;
    group.theme = document.getElementById('setting-group-theme-color').value;
    group.maxMemory = document.getElementById('setting-group-max-memory').value;
    group.useCustomBubbleCss = document.getElementById('setting-group-use-custom-css').checked;
    group.customBubbleCss = document.getElementById('setting-group-custom-bubble-css').value;
    updateCustomBubbleStyle(currentChatId, group.customBubbleCss, group.useCustomBubbleCss);
    
    group.bubbleScale = document.getElementById('bubble-scale-range').value;

    // æ–°å¢ï¼šä¿å­˜ç¾¤èŠçš„åå°å›å¤è®¾ç½®
    group.aiProactiveChatEnabled = document.getElementById('group-ai-proactive-chat-toggle').checked;
    group.aiProactiveChatDelay = parseInt(document.getElementById('group-ai-proactive-chat-delay').value, 10) || 0;
    group.aiProactiveChatInterval = parseInt(document.getElementById('group-ai-proactive-chat-interval').value, 10) || 0;

    await saveData();
    showToast('ç¾¤èŠè®¾ç½®å·²ä¿å­˜ï¼');
    chatRoomTitle.textContent = group.name;
    renderChatList();
    renderMessages(false, true);
}

        function openGroupMemberEditModal(memberId) {
            const group = db.groups.find(g => g.id === currentChatId);
            const member = group.members.find(m => m.id === memberId);
            if (!member) return;
            document.getElementById('edit-group-member-title').textContent = `ç¼–è¾‘ ${member.groupNickname}`;
            document.getElementById('editing-member-id').value = member.id;
            document.getElementById('edit-member-avatar-preview').src = member.avatar;
            document.getElementById('edit-member-group-nickname').value = member.groupNickname;
            document.getElementById('edit-member-real-name').value = member.realName;
            document.getElementById('edit-member-persona').value = member.persona;
            editGroupMemberModal.classList.add('visible');
        }

        function renderInviteSelectionList() {
            inviteMemberSelectionList.innerHTML = '';
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const currentMemberCharIds = new Set(group.members.map(m => m.originalCharId));
            const availableChars = db.characters.filter(c => !currentMemberCharIds.has(c.id));
            if (availableChars.length === 0) {
                inviteMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">æ²¡æœ‰å¯é‚€è¯·çš„æ–°æˆå‘˜äº†ã€‚</li>';
                confirmInviteBtn.disabled = true;
                return;
            }
            confirmInviteBtn.disabled = false;
            availableChars.forEach(char => {
                const li = document.createElement('li');
                li.className = 'invite-member-select-item';
                li.innerHTML = `<input type="checkbox" id="invite-select-${char.id}" value="${char.id}"><label for="invite-select-${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span></label>`;
                inviteMemberSelectionList.appendChild(li);
            });
        }

        function sendInviteNotification(group, newMemberRealName) {
            const messageContent = `[${group.me.nickname}é‚€è¯·${newMemberRealName}åŠ å…¥äº†ç¾¤èŠ]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now(),
                senderId: 'user_me'
            };
            group.history.push(message);
        }

        function sendRenameNotification(group, newName) {
            const myName = group.me.nickname;
            const messageContent = `[${myName}ä¿®æ”¹ç¾¤åä¸ºï¼š${newName}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now()
            };
            group.history.push(message);
        }

// --- NEW: Voice Call System Functions ---

// ã€è¿™æ˜¯ä¸ºæ‚¨é‡æ–°æ·»åŠ å¹¶ä¿®æ­£çš„å®Œæ•´ä»£ç ã€‘

/**
 * è®¾ç½®é€šè¯åŠŸèƒ½çš„æ‰€æœ‰äº‹ä»¶ç›‘å¬å’Œé€»è¾‘
 */
function setupVoiceCallSystem() {
    // ç¼“å­˜æ‰€æœ‰ä¸é€šè¯ç›¸å…³çš„DOMå…ƒç´ 
    const voiceCallBtn = document.getElementById('voice-call-btn');
    const voiceCallOverlay = document.getElementById('voice-call-overlay');
    const callAvatar = document.getElementById('call-avatar');
    const callName = document.getElementById('call-name');
    const callStatus = document.getElementById('call-status');
    const ringingView = document.getElementById('ringing-view');
    const incomingButtons = document.getElementById('incoming-buttons');
    const outgoingButtons = document.getElementById('outgoing-buttons');
    const activeCallView = document.getElementById('active-call-view');
    const callTranscriptArea = document.getElementById('call-transcript-area');
    const hangupCallBtn = document.getElementById('hangup-call-btn');
    const callInput = document.getElementById('call-input');
    const sendCallMessageBtn = document.getElementById('send-call-message-btn');
    const declineCallBtn = document.getElementById('decline-call-btn');
    const acceptCallBtn = document.getElementById('accept-call-btn');
    const cancelCallBtn = document.getElementById('cancel-call-btn');

    // ç»‘å®šæŒ‰é’®äº‹ä»¶
    voiceCallBtn.addEventListener('click', startUserInitiatedCall);
    cancelCallBtn.addEventListener('click', () => endCall('ended')); // ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆå‘¼å«
    declineCallBtn.addEventListener('click', () => endCall('declined')); // ç”¨æˆ·æ‹’æ¥æ¥ç”µ
    acceptCallBtn.addEventListener('click', () => { // ç”¨æˆ·æ¥å¬æ¥ç”µ
        const character = db.characters.find(c => c.id === currentCallTargetId);
        if (!character) return;
        // æ’å…¥ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯ï¼Œå‘ŠçŸ¥AIç”µè¯å·²è¢«æ¥å¬
        const contextMessage = {
            id: `msg_call_${Date.now()}`, role: 'user',
            content: `[system: ${character.myName} æ¥å¬äº†ä½ çš„ç”µè¯ã€‚]`,
            parts: [{type: 'text', text: `[system: ${character.myName} æ¥å¬äº†ä½ çš„ç”µè¯ã€‚]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        saveData();
        startActiveCall();
    });
    hangupCallBtn.addEventListener('click', () => endCall('ended')); // é€šè¯ä¸­æŒ‚æ–­
    sendCallMessageBtn.addEventListener('click', sendCallMessage); // é€šè¯ä¸­å‘æ–‡å­—
    callInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendCallMessage();
    });
}

/**
 * ç”±ç”¨æˆ·å‘èµ·å‘¼å«
 */
function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    // åˆå§‹åŒ–å¹¶æ˜¾ç¤ºå‘¼å«ç•Œé¢
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = 'æ­£åœ¨å‘¼å«...';

    // è®¾ç½®å“é“ƒçŠ¶æ€å¹¶å¯åŠ¨60ç§’æ— åº”ç­”è¶…æ—¶è®¡æ—¶å™¨
    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('å¯¹æ–¹æ— åº”ç­”');
            endCall('timeout');
        }
    }, 60000); 

    // æ’å…¥ä¸€æ¡ç³»ç»ŸæŒ‡ä»¤ï¼Œè®©AIå†³å®šæ˜¯å¦æ¥å¬
    const callMessage = {
        id: `msg_call_${Date.now()}`, role: 'user',
        content: `[system: ${character.myName} æ­£åœ¨å‘¼å«ä½ ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å†³å®šæ˜¯æ¥å¬ [call-accept] è¿˜æ˜¯æ‹’æ¥ [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} æ­£åœ¨å‘¼å«ä½ ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å†³å®šæ˜¯æ¥å¬ [call-accept] è¿˜æ˜¯æ‹’æ¥ [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply(); // è§¦å‘AIå“åº”
}

/**
 * ç”±AIå‘èµ·å‘¼å«ï¼ˆå½“AIå›å¤åŒ…å«[call:...]æŒ‡ä»¤æ—¶ç”±addMessageBubbleå‡½æ•°è°ƒç”¨ï¼‰
 */
function startAiInitiatedCall(characterId) {
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    isAiCalling = true; // æ ‡è®°è¿™æ˜¯AIå‘èµ·çš„å‘¼å«
    isCallRinging = true; // æ ‡è®°æ­£åœ¨å“é“ƒ

    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = 'æ¥ç”µé‚€è¯·...';

    // æ–°å¢ï¼šä¸ºAIæ¥ç”µä¹Ÿè®¾ç½®è¶…æ—¶
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('å‘¼å«å·²è¶…æ—¶');
            endCall('timeout');
        }
    }, 60000); // 60ç§’æ— åº”ç­”
}

/**
 * ç”µè¯æ¥é€šï¼Œè¿›å…¥å®æ—¶é€šè¯ç•Œé¢
 */
function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    // æ¸…ç†å‘¼å«é˜¶æ®µçš„çŠ¶æ€å’Œè®¡æ—¶å™¨
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    // åˆ‡æ¢UIåˆ°é€šè¯ä¸­è§†å›¾
    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', 'é€šè¯å·²è¿æ¥');
    
    // å¯åŠ¨é€šè¯è®¡æ—¶å™¨
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        callStatus.textContent = timeString; 
    }, 1000);

    // è®©AIè¯´ç¬¬ä¸€å¥è¯
    getAiCallReply("[system: é€šè¯å·²æ¥é€šï¼Œè¯·è¯´ç¬¬ä¸€å¥è¯ã€‚]");
}

/**
 * ç»“æŸé€šè¯ï¼ˆå¤„ç†æ‰€æœ‰æƒ…å†µï¼Œå¦‚æŒ‚æ–­ã€æ‹’æ¥ã€æ— åº”ç­”ç­‰ï¼‰
 */

async function endCall(reason = 'ended') {
    // æ¸…ç†æ‰€æœ‰è®¡æ—¶å™¨å’ŒçŠ¶æ€
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    clearInterval(callTimerInterval);
    
    const character = db.characters.find(c => c.id === currentCallTargetId);

    // æ— è®ºå¦‚ä½•ï¼Œå…ˆéšè—é€šè¯ç•Œé¢
    voiceCallOverlay.classList.remove('visible');

    if (!character) {
        isVoiceCallActive = false;
        isAiCalling = false;
        currentCallTargetId = null;
        return;
    }

    const duration = callStatus.textContent;

    // --- â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹ä¸æ–°å¢é€»è¾‘ â–¼â–¼â–¼ ---
    if (isVoiceCallActive) { 
        // æƒ…å†µä¸€ï¼šé€šè¯æ›¾è¢«æ¥é€šè¿‡ï¼Œç°åœ¨ç»“æŸäº†
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`, role: 'system',
            content: `[system-display:ä¸ ${character.remarkName} çš„é€šè¯å·²ç»“æŸï¼Œæ—¶é•¿ ${duration}]`,
            parts: [], timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`, role: 'user',
            content: `[system: ä¸ ${character.realName} çš„é€šè¯å·²ç»“æŸã€‚é€šè¯è®°å½•ï¼š${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: ä¸ ${character.realName} çš„é€šè¯å·²ç»“æŸã€‚é€šè¯è®°å½•ï¼š${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    } else { 
        // æƒ…å†µäºŒï¼šé€šè¯ä»æœªæ¥é€š
        let transitionPrompt = '';
        if (isAiCalling && (reason === 'declined' || reason === 'timeout')) {
            // å­æƒ…å†µ A: æ˜¯AIæ‰“æ¥çš„ï¼Œä½†ç”¨æˆ·æ²¡æ¥æˆ–æŒ‚äº†
            transitionPrompt = `[system: ç”¨æˆ·åˆšåˆšæœªæ¥å¬æˆ–æŒ‚æ–­äº†ä½ çš„ç”µè¯ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œåœ¨èŠå¤©ä¸­å‘ä¸€æ¡æ¶ˆæ¯è¯¢é—®å¯¹æ–¹ï¼Œæˆ–è€…è¡¨è¾¾ä½ çš„å¿ƒæƒ…ã€‚]`;
        } else if (!isAiCalling && (reason === 'declined' || reason === 'timeout' || reason === 'no_action_reply')) {
            // å­æƒ…å†µ B: æ˜¯ç”¨æˆ·æ‰“è¿‡å»çš„ï¼Œä½†AIæ²¡æ¥æˆ–æ— åº”ç­”
            const reasonText = reason === 'declined' ? 'æ‹’ç»äº†' : 'é”™è¿‡äº†';
            transitionPrompt = `[system: ä½ åˆšåˆš${reasonText} ${character.myName} çš„æ¥ç”µã€‚è¯·å‘ä¸€æ¡æ¶ˆæ¯è§£é‡Šæˆ–è¯¢é—®ï¼Œä»¥è‡ªç„¶åœ°è¿‡æ¸¡å›èŠå¤©ã€‚]`;
        }
        
        if (transitionPrompt) {
            const contextMessage = {
                id: `msg_call_fail_${Date.now()}`, role: 'user',
                content: transitionPrompt,
                parts: [{type: 'text', text: transitionPrompt}],
                timestamp: Date.now()
            };
            character.history.push(contextMessage);
            // å¦‚æœç”¨æˆ·å½“å‰å°±åœ¨è¿™ä¸ªèŠå¤©ç•Œé¢ï¼Œç«‹å³è§¦å‘AIå›å¤
            if (currentChatId === character.id) {
                getAiReply();
            }
        }
    }
    // --- â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–² ---
    
    // ç»Ÿä¸€é‡ç½®æ‰€æœ‰å…¨å±€çŠ¶æ€
    isVoiceCallActive = false;
    isAiCalling = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    
    await saveData();
}
/**
 * åœ¨é€šè¯ä¸­å‘é€æ–‡å­—æ¶ˆæ¯
 */
function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text); // åœ¨è‡ªå·±ç•Œé¢æ˜¾ç¤º
    getAiCallReply(text); // è¯·æ±‚AIå›å¤
    callInput.value = '';
}

/**
 * è¯·æ±‚AIåœ¨é€šè¯ä¸­çš„å›å¤
 * @param {string} userText - ç”¨æˆ·å‘é€çš„æ–‡å­—æˆ–ç³»ç»ŸæŒ‡ä»¤
 */
async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
        const prompt = `[é€šè¯ä¸­] ä½ æ˜¯ ${character.realName} (äººè®¾: ${character.persona})ï¼Œæ­£åœ¨å’Œ ${character.myName} é€šè¯ã€‚è¯·ç›´æ¥å›å¤å¯¹è¯å†…å®¹ã€‚å¯ä»¥ä½¿ç”¨æ‹¬å·()æè¿°åŠ¨ä½œã€‚é‡è¦ï¼šå¦‚æœæƒ³è¿ç»­å‘é€å¤šæ¡æ¶ˆæ¯ï¼Œè¯·ç”¨æ¢è¡Œç¬¦åˆ†éš”ï¼Œæ¯ä¸€è¡Œéƒ½ä¼šæˆä¸ºä¸€ä¸ªç‹¬ç«‹çš„æ°”æ³¡ã€‚`;
        
        const callHistory = voiceCallTranscript.map(line => ({
            role: line.sender === 'user' ? 'user' : 'assistant',
            content: line.text
        }));

        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5), // ä½¿ç”¨æœ€è¿‘5è½®çš„é€šè¯è®°å½•ä½œä¸ºä¸Šä¸‹æ–‡
            { role: 'user', content: userText }
        ];

        const aiResponseText = await callAiApi(messages); // å¤ç”¨é€šç”¨çš„AIè°ƒç”¨å‡½æ•°

        // ã€æ–°åŠŸèƒ½ã€‘å¤„ç†AIç”¨æ¢è¡Œç¬¦è¿”å›çš„å¤šæ¡æ¶ˆæ¯
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            // å¢åŠ ä¸€ä¸ªå°çš„éšæœºå»¶è¿Ÿï¼Œæ¨¡æ‹ŸçœŸå®å¯¹è¯çš„èŠ‚å¥æ„Ÿ
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }

    } catch (error) {
        const errorMessage = `[AIæœåŠ¡å™¨è¿”å›é”™è¯¯: ${error.message}]`;
        appendCallTranscript("system", errorMessage);
        showToast('AIå›å¤å¤±è´¥ï¼Œå¯èƒ½æ˜¯æœåŠ¡å™¨ä¸´æ—¶é—®é¢˜');
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

/**
 * å°†ä¸€æ¡æ¶ˆæ¯è¿½åŠ åˆ°é€šè¯è®°å½•çš„æ˜¾ç¤ºç•Œé¢ä¸Š
 * @param {string} sender - 'user', 'ai', or 'system'
 * @param {string} text - æ¶ˆæ¯å†…å®¹
 */
function appendCallTranscript(sender, text) {
    voiceCallTranscript.push({ sender, text }); // å­˜å…¥è®°å½•

    const line = document.createElement('div');
    line.className = 'call-transcript-line';

    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? 'æˆ‘' : callName.textContent;
        // å°†æ‹¬å·é‡Œçš„å†…å®¹ç”¨ç‰¹å®šæ ·å¼åŒ…è£¹ï¼Œä»¥è¡¨ç¤ºåŠ¨ä½œæˆ–è¯­æ°”
        const styledText = text.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight; // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
}
function startUserInitiatedCall() {
    if (isGenerating || currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'none';
    outgoingButtons.style.display = 'flex';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = 'æ­£åœ¨å‘¼å«...';

    // è®¾ç½®å“é“ƒçŠ¶æ€å¹¶å¯åŠ¨è¶…æ—¶è®¡æ—¶å™¨
    isCallRinging = true;
    callInitiationTimeout = setTimeout(() => {
        if (isCallRinging) {
            showToast('å¯¹æ–¹æ— åº”ç­”');
            endCall('timeout');
        }
    }, 60000); // 60ç§’è¶…æ—¶

    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ä»¥è§¦å‘AIå†³ç­–
    const callMessage = {
        id: `msg_call_${Date.now()}`,
        role: 'user',
        content: `[system: ${character.myName} æ­£åœ¨å‘¼å«ä½ ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å†³å®šæ˜¯æ¥å¬ [call-accept] è¿˜æ˜¯æ‹’æ¥ [call-decline]]`,
        parts: [{type: 'text', text: `[system: ${character.myName} æ­£åœ¨å‘¼å«ä½ ï¼Œè¯·æ ¹æ®ä½ çš„äººè®¾å†³å®šæ˜¯æ¥å¬ [call-accept] è¿˜æ˜¯æ‹’æ¥ [call-decline]]`}],
        timestamp: Date.now()
    };
    character.history.push(callMessage);
    saveData();
    getAiReply(); // è§¦å‘AIå“åº”
}

function startAiInitiatedCall(characterId) {
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;
    
    currentCallTargetId = character.id;
    voiceCallOverlay.classList.add('visible');
    ringingView.style.display = 'block';
    activeCallView.style.display = 'none';
    incomingButtons.style.display = 'flex';
    outgoingButtons.style.display = 'none';

    callAvatar.src = character.avatar;
    callName.textContent = character.remarkName;
    callStatus.textContent = 'æ¥ç”µé‚€è¯·...';
}

function startActiveCall() {
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    clearTimeout(callInitiationTimeout);
    isCallRinging = false;
    isVoiceCallActive = true;
    voiceCallTranscript = [];
    voiceCallStartTime = Date.now();
    
    // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ˜¾ç¤ºä¸»å¤´åƒï¼Œéšè—é¡¶éƒ¨é¢æ¿ ---
    // ä¿æŒä¸»ç•Œé¢çš„å¤§å‹å¤´åƒå’Œåå­—å¯è§ï¼Œä»¥åŒ¹é…å›¾ç‰‡æ ·å¼
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
    
    // éšè—é‚£ä¸ªå›ºå®šçš„ã€ç°åœ¨ä¸éœ€è¦çš„é¡¶éƒ¨ header
    const activeHeader = document.getElementById('active-call-header');
    if (activeHeader) activeHeader.style.display = 'none';
    // --- ä¿®æ”¹ç»“æŸ ---

    ringingView.style.display = 'none';
    activeCallView.style.display = 'flex';

    // æ›´æ–°é¡¶éƒ¨å›ºå®šé¢æ¿çš„ä¿¡æ¯ï¼ˆè¿™äº›ä»£ç ç°åœ¨æ— æ•ˆï¼Œä½†ä¿ç•™ä¹Ÿæ— å¦¨ï¼‰
    document.getElementById('active-call-header-avatar').src = character.avatar;
    document.getElementById('active-call-header-name').textContent = character.remarkName;
    
    callTranscriptArea.innerHTML = '';
    callInput.value = '';

    appendCallTranscript('system', 'é€šè¯å·²è¿æ¥');
    
    callTimerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - voiceCallStartTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        const timeString = `${minutes}:${seconds}`;
        
        // ä¿®æ”¹ï¼šç¡®ä¿åªæ›´æ–°ä¸»çŠ¶æ€åŒºçš„è®¡æ—¶å™¨
        callStatus.textContent = timeString; 
    }, 1000);

    getAiCallReply("[system: é€šè¯å·²æ¥é€šï¼Œè¯·è¯´ç¬¬ä¸€å¥è¯ã€‚]");
}

async function endCall(reason = 'ended') {
    clearTimeout(callInitiationTimeout);
    isCallRinging = false;

    const character = db.characters.find(c => c.id === currentCallTargetId);

    if (isVoiceCallActive && reason === 'ended' && character) {
        const hangupContext = {
            id: `msg_call_${Date.now()}_ctx`,
            role: 'user', 
            content: `[system: ${character.myName} æŒ‚æ–­äº†ç”µè¯ã€‚]`,
            parts: [{type: 'text', text: `[system: ${character.myName} æŒ‚æ–­äº†ç”µè¯ã€‚]`}],
            timestamp: Date.now()
        };
        character.history.push(hangupContext);
    }

    // å¦‚æœé€šè¯ä»æœªè¢«æ¿€æ´»ï¼ˆå³ä»åœ¨å“é“ƒé˜¶æ®µï¼‰ï¼Œå¹¶ä¸”æ˜¯å› ä¸º 'ended', 'timeout', 'error', æˆ– 'no_action_reply' è€Œç»“æŸï¼Œåˆ™ç›´æ¥å…³é—­ç•Œé¢
    if (!isVoiceCallActive && (reason === 'ended' || reason === 'timeout' || reason === 'error' || reason === 'no_action_reply')) {
         voiceCallOverlay.classList.remove('visible');
         document.getElementById('call-avatar').style.display = 'block';
         document.getElementById('call-name').style.display = 'block';
         return;
    }

    if (!character) {
         voiceCallOverlay.classList.remove('visible');
         return;
    }

    clearInterval(callTimerInterval);
    const duration = callStatus.textContent;

    if (reason === 'declined') {
         const contextMessage = {
            id: `msg_call_${Date.now()}`,
            role: 'user',
            content: `[system: ${character.myName} æ‹’ç»äº†ä½ çš„ç”µè¯ã€‚]`,
            parts: [{type: 'text', text: `[system: ${character.myName} æ‹’ç»äº†ä½ çš„ç”µè¯ã€‚]`}],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
    } else if (isVoiceCallActive) { 
        const summaryDisplay = {
            id: `msg_call_${Date.now()}_disp`,
            role: 'system',
            content: `[system-display:ä¸ ${character.remarkName} çš„é€šè¯å·²ç»“æŸï¼Œæ—¶é•¿ ${duration}]`,
            parts: [],
            timestamp: Date.now()
        };
        const summaryContext = {
            id: `msg_call_${Date.now()}_ctx`,
            role: 'user',
            content: `[system: ä¸ ${character.realName} çš„é€šè¯å·²ç»“æŸã€‚é€šè¯è®°å½•ï¼š${JSON.stringify(voiceCallTranscript)}]`,
            parts: [{type: 'text', text: `[system: ä¸ ${character.realName} çš„é€šè¯å·²ç»“æŸã€‚é€šè¯è®°å½•ï¼š${JSON.stringify(voiceCallTranscript)}]`}],
            timestamp: Date.now()
        };
        character.history.push(summaryDisplay, summaryContext);
        if(currentChatId === character.id) {
             addMessageBubble(summaryDisplay);
        }
    }
    
    await saveData();
    isVoiceCallActive = false;
    voiceCallTranscript = [];
    voiceCallStartTime = null;
    currentCallTargetId = null;
    voiceCallOverlay.classList.remove('visible');
    
    document.getElementById('call-avatar').style.display = 'block';
    document.getElementById('call-name').style.display = 'block';
}

function sendCallMessage() {
    const text = callInput.value.trim();
    if (!text || isGenerating) return;
    appendCallTranscript('user', text);
    getAiCallReply(text);
    callInput.value = '';
}

async function getAiCallReply(userText) {
    if (isGenerating) return;
    const character = db.characters.find(c => c.id === currentCallTargetId);
    if (!character) return;

    isGenerating = true;
    sendCallMessageBtn.disabled = true;

    try {
        // ä¿®æ”¹åçš„ Promptï¼Œæ˜ç¡®æŒ‡ç¤º AI å¯ä»¥ç”¨æ¢è¡Œç¬¦æ¥å‘é€å¤šæ¡æ¶ˆæ¯
        const prompt = `ä½ æ­£åœ¨ä¸ ${character.myName} è¿›è¡Œè¯­éŸ³é€šè¯ã€‚ä½ çš„åå­—æ˜¯ ${character.realName}ï¼Œä½ çš„äººè®¾æ˜¯ï¼š${character.persona}ã€‚ä½ çš„å›å¤å¯ä»¥ç›´æ¥æ˜¯å¯¹è¯å†…å®¹ï¼Œä¹Ÿå¯ä»¥åŒ…å«ç”¨æ‹¬å·()æè¿°çš„åŠ¨ä½œã€è¯­æ°”æˆ–ç¯å¢ƒã€‚é‡è¦ï¼šå¦‚æœæƒ³è¿ç»­å‘é€å¤šæ¡æ¶ˆæ¯ï¼Œè¯·ç”¨æ¢è¡Œç¬¦åˆ†éš”ï¼Œå¹¶ä¸”æ¯æ¡æ¶ˆæ¯ä¸å¾—è¶…è¿‡50å­—ï¼Œæ¯ä¸€è¡Œéƒ½ä¼šæˆä¸ºä¸€ä¸ªç‹¬ç«‹çš„æ°”æ³¡ã€‚è¯·ä¸¥æ ¼ä¿æŒä½ çš„äººè®¾è¿›è¡Œå¯¹è¯ã€‚`;

        const callHistory = voiceCallTranscript.map(line => {
            return {
                role: line.sender === 'user' ? 'user' : 'assistant',
                content: line.text
            }
        });

        const messages = [
            { role: 'system', content: prompt },
            ...callHistory.slice(-5), // ä½¿ç”¨æœ€è¿‘5è½®çš„é€šè¯è®°å½•ä½œä¸ºä¸Šä¸‹æ–‡
            { role: 'user', content: userText }
        ];

        const aiResponseText = await callAiApi(messages); // å¤ç”¨é€šç”¨çš„AIè°ƒç”¨å‡½æ•°

        // å¤„ç†AIå›å¤ï¼ŒæŒ‰æ¢è¡Œç¬¦æ‹†åˆ†æˆå¤šæ¡æ¶ˆæ¯
        const replies = aiResponseText.split('\n').filter(reply => reply.trim() !== '');
        for (const reply of replies) {
            appendCallTranscript("ai", reply);
            // å¯ä»¥æ ¹æ®æ¶ˆæ¯é•¿åº¦æ·»åŠ ä¸€ä¸ªå°çš„å»¶è¿Ÿï¼Œæ¨¡æ‹Ÿæ‰“å­—æ•ˆæœ
            await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
        }

    } catch (error) {
        appendCallTranscript("system", `[é”™è¯¯: ${error.message}]`);
    } finally {
        isGenerating = false;
        sendCallMessageBtn.disabled = false;
    }
}

function appendCallTranscript(sender, text) {
    // sender: 'user', 'ai', or 'system'
    voiceCallTranscript.push({ sender, text });

    const line = document.createElement('div');
    line.className = 'call-transcript-line';

    if (sender === 'system') {
        line.innerHTML = `<span class="action">${text}</span>`;
    } else {
        const name = sender === 'user' ? 'æˆ‘' : callName.textContent;
        // Simple regex to style actions in parenthesis
        const styledText = text.replace(/\((.*?)\)/g, '<span class="action">($1)</span>');
        line.innerHTML = `<strong>${name}:</strong> <span class="dialog">${styledText}</span>`;
    }
    
    callTranscriptArea.appendChild(line);
    callTranscriptArea.scrollTop = callTranscriptArea.scrollHeight;
}


// åœ¨ init() å‡½æ•°ä¹‹å‰æ·»åŠ ä»¥ä¸‹ä¸‰ä¸ªå‡½æ•°

function addNotificationToQueue(notification) {
    // â–¼â–¼â–¼ åœ¨è¿™é‡Œä¿®æ”¹ â–¼â–¼â–¼

    // ä¹‹å‰çš„ä»£ç æœ‰ä¸€ä¸ªéšæœºå»¶è¿Ÿï¼Œæˆ‘ä»¬æŠŠå®ƒå»æ‰ï¼Œæ¢æˆç›´æ¥æ‰§è¡Œ
    /* // æ¨¡æ‹Ÿä¸€ä¸ªéšæœºå»¶è¿Ÿï¼ˆ1åˆ°5ç§’ï¼‰ï¼Œè®©é€šçŸ¥çœ‹èµ·æ¥æ›´è‡ªç„¶
    const delay = Math.random() * 4000 + 1000;
    setTimeout(() => {
        notificationQueue.push(notification);
    }, delay);
    */
    
    // æ–°ä»£ç ï¼šç›´æ¥å°†é€šçŸ¥æ·»åŠ åˆ°é˜Ÿåˆ—ï¼Œä¸å†å»¶è¿Ÿ
    notificationQueue.push(notification);

    // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²
}

function showNotificationBanner() {
    console.log(`æ£€æŸ¥é€šçŸ¥: é˜Ÿåˆ—é•¿åº¦ ${notificationQueue.length}, æ­£åœ¨æ˜¾ç¤º? ${isNotificationShowing}, åœ¨åŠ¨æ€é¡µ? ${document.getElementById('moments-screen').classList.contains('active')}`);

    if (isNotificationShowing || notificationQueue.length === 0) {
        return;
    }

    const momentsScreen = document.getElementById('moments-screen');
    if (momentsScreen && momentsScreen.classList.contains('active')) {
        return;
    }

    isNotificationShowing = true;
    const notification = notificationQueue.shift();
    
    const banner = document.getElementById('global-notification-banner');
    const avatar = document.getElementById('notification-avatar');
    const textEl = document.getElementById('notification-text');

    avatar.src = notification.avatar;
    textEl.innerHTML = notification.text;

    banner.classList.add('show');
    
    // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹åœ¨æ­¤ â–¼â–¼â–¼
    banner.onclick = () => {
        // æ£€æŸ¥é€šçŸ¥æ˜¯å¦åŒ…å«èŠå¤©ä¿¡æ¯
        if (notification.chatId && notification.type) {
            // å¦‚æœæœ‰ï¼Œå°±æ‰“å¼€å¯¹åº”çš„èŠå¤©å®¤
            openChatRoom(notification.chatId, notification.type);
        } else {
            // å¦åˆ™ï¼Œä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆï¼Œè·³è½¬åˆ°åŠ¨æ€é¡µ
            switchScreen('moments-screen');
        }
        
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500);
    };
    // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²

    setTimeout(() => {
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500);
    }, 5000);
}
function setupNotificationSystem() {
    // å®šæ—¶æ£€æŸ¥é€šçŸ¥é˜Ÿåˆ—
    setInterval(showNotificationBanner, 2000); // æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡

    // å…³é—­æŒ‰é’®
    const closeBtn = document.getElementById('notification-close-btn');
    closeBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // é˜²æ­¢è§¦å‘æ¨ªå¹…çš„ç‚¹å‡»äº‹ä»¶
        const banner = document.getElementById('global-notification-banner');
        banner.classList.remove('show');
        isNotificationShowing = false;
        setTimeout(showNotificationBanner, 500);
    });
}
// --- æ–°å¢é•¿æˆªå›¾é€‰æ‹©ä¸ç”ŸæˆåŠŸèƒ½ ---

/**
 * è¿›å…¥æˆªå›¾é€‰æ‹©æ¨¡å¼
 * @param {string} initialMessageId - é•¿æŒ‰è§¦å‘æ—¶ï¼Œåˆå§‹é€‰ä¸­çš„æ¶ˆæ¯ID
 */
function enterScreenshotSelectionMode(initialMessageId) {
    isInScreenshotMode = true;
    selectedMessagesForScreenshot.clear();

    const chatScreen = document.getElementById('chat-room-screen');
    chatScreen.classList.add('screenshot-mode');

    document.getElementById('screenshot-select-bar').style.display = 'flex';
    document.getElementById('screenshot-select-count').textContent = 'å·²é€‰æ‹© 0 æ¡';

    // åˆå§‹é€‰ä¸­å±±ä¸‹æ–‡èœå•è§¦å‘çš„æ¶ˆæ¯
    if (initialMessageId) {
        toggleScreenshotSelection(initialMessageId);
    }
}

/**
 * é€€å‡ºæˆªå›¾é€‰æ‹©æ¨¡å¼
 */
function exitScreenshotSelectionMode() {
    isInScreenshotMode = false;
    document.getElementById('chat-room-screen').classList.remove('screenshot-mode');
    document.getElementById('screenshot-select-bar').style.display = 'none';

    // ç§»é™¤æ‰€æœ‰æ¶ˆæ¯çš„é€‰ä¸­é«˜äº®
    document.querySelectorAll('.message-wrapper.screenshot-selected').forEach(el => {
        el.classList.remove('screenshot-selected');
    });
    selectedMessagesForScreenshot.clear();
}

/**
 * åˆ‡æ¢å•æ¡æ¶ˆæ¯çš„é€‰ä¸­çŠ¶æ€
 * @param {string} messageId - è¢«ç‚¹å‡»çš„æ¶ˆæ¯çš„ID
 */
function toggleScreenshotSelection(messageId) {
    const el = document.querySelector(`.message-wrapper[data-id="${messageId}"]`);
    if (!el) return;

    if (selectedMessagesForScreenshot.has(messageId)) {
        selectedMessagesForScreenshot.delete(messageId);
        el.classList.remove('screenshot-selected');
    } else {
        selectedMessagesForScreenshot.add(messageId);
        el.classList.add('screenshot-selected');
    }

    document.getElementById('screenshot-select-count').textContent = `å·²é€‰æ‹© ${selectedMessagesForScreenshot.size} æ¡`;
}

/**
 * ç”Ÿæˆå¹¶ä¸‹è½½æ‰€é€‰æ¶ˆæ¯çš„æˆªå›¾
 */
// â–¼â–¼â–¼ ç”¨ä¸‹é¢è¿™ä¸ªå®Œæ•´çš„å‡½æ•°ï¼Œæ›¿æ¢æ‰ä½ æ–‡ä»¶ä¸­æ—§çš„åŒåå‡½æ•° â–¼â–¼â–¼
/**
 * ç”Ÿæˆæ‰€é€‰æ¶ˆæ¯çš„æˆªå›¾ï¼Œå¹¶åœ¨å¼¹çª—ä¸­è¿›è¡Œé¢„è§ˆã€‚
 */
async function generateSelectedMessagesScreenshot() {
    if (selectedMessagesForScreenshot.size === 0) {
        showToast('è¯·è‡³å°‘é€‰æ‹©ä¸€æ¡æ¶ˆæ¯');
        return;
    }

    showToast('æ­£åœ¨ç”Ÿæˆé•¿æˆªå›¾ï¼Œè¯·ç¨å€™...');
    // å…³é”®ï¼šåœ¨æˆªå›¾å‰å…ˆéšè—é€‰æ‹©æ“ä½œæ ï¼Œé¿å…å®ƒå‡ºç°åœ¨æˆªå›¾é‡Œ
    document.getElementById('screenshot-select-bar').style.display = 'none';

    // 1. åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ã€å±å¹•å¤–çš„å®¹å™¨ç”¨äºæˆªå›¾
    const screenshotContainer = document.createElement('div');
    screenshotContainer.style.position = 'absolute';
    screenshotContainer.style.left = '-9999px'; // ç§»å‡ºè§†çª—
    screenshotContainer.style.width = document.querySelector('.phone-screen').clientWidth + 'px';
    screenshotContainer.style.padding = '20px 10px';
    screenshotContainer.style.fontFamily = 'var(--font-family)';

    // 2. æ·»åŠ èŠå¤©èƒŒæ™¯
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (chat && chat.chatBg) {
        screenshotContainer.style.backgroundImage = `url(${chat.chatBg})`;
        screenshotContainer.style.backgroundSize = 'cover';
        screenshotContainer.style.backgroundPosition = 'center';
    } else {
        screenshotContainer.style.backgroundColor = '#f7f7f7';
    }

    // 3. æŒ‰é¡ºåºå…‹éš†é€‰ä¸­çš„æ¶ˆæ¯
    const selectedElements = Array.from(selectedMessagesForScreenshot)
        .map(id => document.querySelector(`.message-wrapper[data-id="${id}"]`))
        .filter(Boolean)
        .sort((a, b) => a.offsetTop - b.offsetTop);

    selectedElements.forEach(el => {
        const clone = el.cloneNode(true);
        clone.classList.remove('screenshot-selected', 'multi-select-selected'); // ç§»é™¤æ‰€æœ‰é«˜äº®
        screenshotContainer.appendChild(clone);
    });

    document.body.appendChild(screenshotContainer);

    // 4. ä½¿ç”¨ html2canvas è¿›è¡Œæˆªå›¾
    try {
        const canvas = await html2canvas(screenshotContainer, {
            useCORS: true,
            backgroundColor: null,
        });

        const imageDataUrl = canvas.toDataURL("image/png");

        // 5. æ˜¾ç¤ºé¢„è§ˆå¼¹çª—
        const modal = document.getElementById('screenshot-preview-modal');
        const imgEl = document.getElementById('screenshot-preview-image');
        const downloadBtn = document.getElementById('download-screenshot-btn');
        const closeBtn = document.getElementById('close-screenshot-preview');

        imgEl.src = imageDataUrl;
        downloadBtn.href = imageDataUrl;
        downloadBtn.download = `èŠå¤©è®°å½•æˆªå›¾-${Date.now()}.png`;
        
        modal.classList.add('visible');

        // 6. ç»‘å®šå…³é—­äº‹ä»¶
        const closeModal = () => {
            modal.classList.remove('visible');
            exitScreenshotSelectionMode(); // æˆªå›¾æµç¨‹ç»“æŸåï¼Œå½»åº•é€€å‡ºé€‰æ‹©æ¨¡å¼
        };
        closeBtn.onclick = closeModal; // ä½¿ç”¨ .onclick é¿å…é‡å¤ç»‘å®š
        
    } catch (error) {
        console.error("æˆªå›¾å¤±è´¥:", error);
        showToast('æˆªå›¾å¤±è´¥ï¼Œè¯¦æƒ…è¯·æŸ¥çœ‹æ§åˆ¶å°');
        // æˆªå›¾å¤±è´¥ä¹Ÿè¦é€€å‡ºé€‰æ‹©æ¨¡å¼
        exitScreenshotSelectionMode();
    } finally {
        // 7. æ¸…ç†ä¸´æ—¶å®¹å™¨
        document.body.removeChild(screenshotContainer);
    }
}
function setupViewRecalledModal() {
    const modal = document.getElementById('view-recalled-modal');
    const contentDisplay = document.getElementById('recalled-content-display');
    const closeBtn = document.getElementById('close-recalled-modal-btn');

    // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œç›‘å¬èŠå¤©åŒºåŸŸå†…å¯¹å ä½ç¬¦çš„ç‚¹å‡»
    messageArea.addEventListener('click',async (e) => {
    const acceptBtn = e.target.closest('.payment-request-accept');
    const declineBtn = e.target.closest('.payment-request-decline');
    const messageWrapper = e.target.closest('.message-wrapper');

    if (messageWrapper && (acceptBtn || declineBtn)) {
        // è¿™æ®µä»£ç æ˜¯ä¸ºæœªæ¥æ‰‹åŠ¨ç‚¹å‡»AIæŒ‰é’®å‡†å¤‡çš„ï¼Œç°åœ¨ä¸»è¦ç”±AIæŒ‡ä»¤è§¦å‘
        // ä½†ä¿ç•™å®ƒæ˜¯å¥½çš„åšæ³•
        const messageId = messageWrapper.dataset.id;
        const decision = acceptBtn ? 'paid' : 'declined';
        await handleAiPaymentDecision(messageId, decision);
    }
        const placeholder = e.target.closest('.recalled-message-placeholder');
        if (!placeholder) return;
        
        const messageId = placeholder.dataset.recalledMessageId;
        const chat = (currentChatType === 'private') 
            ? db.characters.find(c => c.id === currentChatId) 
            : db.groups.find(g => g.id === currentChatId);
        
        if (!chat) return;

        const recalledMessage = chat.history.find(m => m.id === messageId);
        if (recalledMessage && recalledMessage.originalContent) {
            // ä»ä¿å­˜çš„åŸå§‹å†…å®¹ä¸­æå–å¹¶æ˜¾ç¤º
            let textToShow = recalledMessage.originalContent;
            
            // å°è¯•æ¸…ç†åŒ…è£…ï¼Œè®©å†…å®¹æ›´çº¯ç²¹
            const contentMatch = textToShow.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/);
            if(contentMatch) {
                textToShow = contentMatch[1];
            }

            contentDisplay.textContent = textToShow;
            modal.classList.add('visible');
        } else {
            showToast('æ‰¾ä¸åˆ°åŸå§‹æ¶ˆæ¯å†…å®¹ã€‚');
        }
    });

    closeBtn.addEventListener('click', () => {
        modal.classList.remove('visible');
    });
}
// ===============================================================
// START: å•†åŸè´­ç‰©æµç¨‹æ ¸å¿ƒJSå‡½æ•°
// ===============================================================

// æ–°å¢ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ¸²æŸ“ç‰©æµåˆ—è¡¨
function renderLogistics() {
    const container = document.getElementById('logistics-list-container');
    const placeholder = document.getElementById('no-logistics-placeholder');
    const logistics = db.mallData.logistics || [];

    if (logistics.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }
    placeholder.style.display = 'none';
    container.innerHTML = '';

    logistics.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'logistics-item';
        itemEl.innerHTML = `
            <div class="logistics-header">
                <span>è®¢å•å·: ${item.orderId.slice(-8)}</span>
                <span class="logistics-status">${item.status}</span>
            </div>
            <div class="logistics-body">
                <img src="${item.productImage}" alt="${item.productName}">
                <div class="logistics-info">
                    <p class="item-name">${item.productName}</p>
                    <p class="eta" data-countdown-type="delivery" data-eta="${item.eta}">æ­£åœ¨è®¡ç®—é€è¾¾æ—¶é—´...</p>
                    <p class="recipient-info" style="font-size: 12px; color: #888;">æ”¶ä»¶äºº: ${item.recipientName}</p>
                </div>
            </div>
        `;
        container.appendChild(itemEl);
    });
}

// åœ¨ setupMallApp ä¸­ä¸ºæ–°çš„ç‰©æµå…¥å£ç»‘å®šäº‹ä»¶
document.querySelector('.wallet-action-item[data-target="logistics-screen"]').addEventListener('click', () => {
    renderLogistics();
    switchScreen('logistics-screen');
});
/**
 * [V3.0 | æœ€ç»ˆä¿®æ­£ç‰ˆ] å¤„ç†AIçš„ä»£ä»˜å†³å®šï¼Œå¹¶è®©AIæ ¹æ®äººè®¾ç”Ÿæˆç¬¦åˆæƒ…å¢ƒçš„å›å¤ã€‚
 */
async function handleAiPaymentDecision(messageId, decision) {
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;
    
    const message = character.history.find(m => m.id === messageId);
    if (!message || !message.paymentRequestData) return;

    // 1. åœ¨æ•°æ®ä¸­æ›´æ–°å¡ç‰‡çŠ¶æ€
    message.paymentRequestData.status = decision;

    // --- æ ¸å¿ƒä¿®å¤ï¼šç«‹å³ä¿å­˜æ•°æ®å¹¶åˆ·æ–°æ•´ä¸ªèŠå¤©ç•Œé¢ ---
    // è¿™ä¸€æ­¥ä¼šç«‹åˆ»å°†å¡ç‰‡çŠ¶æ€ä»â€œç­‰å¾…ä»˜æ¬¾â€æ›´æ–°ä¸ºâ€œå·²æ”¯ä»˜â€æˆ–â€œå·²æ‹’ç»â€
    await saveData();
    renderMessages(false, true); 
    // --- ä¿®å¤ç»“æŸ ---

    let contextMessageContent = ''; // è¿™æ˜¯æˆ‘ä»¬å°†è¦å‘ç»™AIçš„â€œç³»ç»ŸæŒ‡ä»¤â€

    if (decision === 'paid') {
        // (è¿™éƒ¨åˆ†é€»è¾‘ä¿æŒä¸å˜ï¼šå¤„ç†ç‰©æµå’Œé¡¶éƒ¨é€šçŸ¥)
        addItemsToLogistics(message.paymentRequestData.items, character.id);
        const notifText = `<strong>${character.remarkName}</strong> å·²ä¸ºä½ æ”¯ä»˜äº† ${message.paymentRequestData.items.length} ä»¶å•†å“ã€‚`;
        addNotificationToQueue({
            avatar: character.avatar,
            text: notifText,
            chatId: character.id,
            type: 'private'
        });
        
        // åˆ›å»ºä¸€æ¡å¼•å¯¼AIå›å¤çš„æŒ‡ä»¤
        contextMessageContent = `[system: ä½ åˆšåˆšåŒæ„å¹¶æ”¯ä»˜äº† ${character.myName} çš„ä»£ä»˜è¯·æ±‚ã€‚è¯·åœ¨èŠå¤©ä¸­å‘ŠçŸ¥å¯¹æ–¹ä½ å·²ç»ä»˜æ¬¾äº†ï¼Œå¹¶æ ¹æ®ä½ çš„äººè®¾è¯´äº›ä»€ä¹ˆï¼ˆä¾‹å¦‚ï¼Œå¯ä»¥è¡¨ç°å¾—å¾ˆå¤§æ–¹ã€æˆ–è€…è°ƒä¾ƒä¸€ä¸‹è¿™æ¬¡æ¶ˆè´¹ã€æˆ–è€…æŠ±æ€¨è‡ªå·±åˆç ´è´¹äº†ç­‰ç­‰ï¼‰ã€‚]`;

    } else { // å¦‚æœAIæ‹’ç» (è¿™éƒ¨åˆ†é€»è¾‘ä¿æŒä¸å˜)
        contextMessageContent = `[system: ä½ åˆšåˆšæ‹’ç»äº† ${character.myName} çš„ä»£ä»˜è¯·æ±‚ã€‚è¯·åœ¨èŠå¤©ä¸­å‘ŠçŸ¥å¯¹æ–¹ä½ æ‹’ç»çš„åŸå› ã€‚]`;
    }

    // 2. å°†è¿™æ¡â€œç³»ç»ŸæŒ‡ä»¤â€ä½œä¸ºä¸€æ¡ç”¨æˆ·æ¶ˆæ¯å‘é€ç»™AI
    const contextMessage = {
        id: `msg_pay_resp_${Date.now()}`,
        role: 'user',
        content: contextMessageContent,
        parts: [{ type: 'text', text: contextMessageContent }],
        timestamp: Date.now()
    };
    character.history.push(contextMessage);
    
    // 3. å†æ¬¡ä¿å­˜ï¼Œç¡®ä¿æŒ‡ä»¤è¢«è®°å½•
    await saveData();

    // 4. è§¦å‘AIï¼Œè®©å®ƒæ ¹æ®ä¸Šé¢çš„æŒ‡ä»¤ç”Ÿæˆå›å¤ (æ— éœ€ç­‰å¾…ï¼Œè®©å®ƒåœ¨åå°è¿è¡Œ)
    getAiReply();
}
// â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
/**
 * æ‰“å¼€è´­ä¹°æµç¨‹çš„ç¬¬ä¸€ä¸ªå¼¹çª—ï¼ˆé€‰æ‹©æ”¶è´§äººï¼‰
 */
function openPurchaseModal(productId) {
    const product = findProductById(productId); // ä½¿ç”¨è¿™ä¸ªè¾…åŠ©å‡½æ•°
    if (!product) {
        // å¦‚æœæ‰¾ä¸åˆ°å•†å“ï¼Œç»™å‡ºæ˜ç¡®æç¤ºå¹¶ä¸­æ­¢
        showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¯¥å•†å“ä¿¡æ¯ã€‚');
        return;
    }
    purchaseState = { productId, recipientId: null, quantity: 1, style: 'é»˜è®¤æ¬¾å¼' , multiItems: []};
    
    const modal = document.getElementById('purchase-modal');
    modal.dataset.productId = productId; // å°†äº§å“IDæš‚å­˜åˆ°å¼¹çª—ä¸Šï¼Œç”¨äºå–æ¶ˆæ—¶åŠ å…¥è´­ç‰©è½¦

    document.getElementById('purchase-product-image').src = product.imageUrl;
    document.getElementById('purchase-product-price').textContent = `Â¥${product.price.toFixed(2)}`;
    document.getElementById('purchase-product-name').textContent = product.name;
    
    renderRecipientList();
    modal.classList.add('visible');
}

/**
 * æ¸²æŸ“æ”¶è´§äººï¼ˆèŠå¤©å¯¹è±¡ï¼‰åˆ—è¡¨
 */
function renderRecipientList() {
    const container = document.getElementById('recipient-selection-list');
    container.innerHTML = '';
    db.characters.forEach(char => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.innerHTML = `
            <input type="radio" name="recipient" value="${char.id}" id="recipient-${char.id}">
            <label for="recipient-${char.id}" style="display:flex; align-items:center; width:100%; gap:10px;">
                <img src="${char.avatar}" class="chat-avatar">
                <div class="item-details">
                    <div class="item-name">${char.remarkName}</div>
                </div>
            </label>
        `;
        container.appendChild(li);
    });
}

/**
 * [å·²ä¿®å¤] å¤„ç†æ”¶è´§äººç¡®è®¤ï¼Œå¹¶æ ¹æ®æµç¨‹åˆ†å‘åˆ°â€œæ‰¾äººä»£ä»˜â€æˆ–â€œè‡ªå·±è´­ä¹°â€
 */
async function handleRecipientConfirmation() {
    const selectedRecipient = document.querySelector('input[name="recipient"]:checked');
    if (!selectedRecipient) {
        showToast('è¯·é€‰æ‹©ä¸€ä¸ªæ”¶è´§äºº');
        return;
    }
    purchaseState.recipientId = selectedRecipient.value;
    const recipientChar = db.characters.find(c => c.id === purchaseState.recipientId);

    // å…³é—­é€‰æ‹©å¼¹çª—
    document.getElementById('purchase-modal').classList.remove('visible');

    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘ ---
    // åˆ¤æ–­æ˜¯å¦ä¸ºâ€œæ‰¾äººä»£ä»˜â€æµç¨‹
    if (purchaseState.isPayForMe) {
        // *** æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ findProductById æŸ¥æ‰¾å•†å“ ***
        const product = findProductById(purchaseState.productId);
        if (!product || !recipientChar) {
            showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°å•†å“æˆ–ä»£ä»˜äºº');
            return;
        }

        // è°ƒç”¨å‡½æ•°ï¼Œå‘AIå‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡
        await sendPaymentRequestCard(recipientChar.id, [product], product.price);

        showToast(`å·²å‘ ${recipientChar.remarkName} å‘é€ä»£ä»˜è¯·æ±‚`);
        
        // (å¯é€‰, ä½†å»ºè®®ä¿ç•™) è‡ªåŠ¨è·³è½¬åˆ°ä¸è¯¥AIçš„èŠå¤©ç•Œé¢
        currentChatId = recipientChar.id;
        currentChatType = 'private';
        openChatRoom(currentChatId, currentChatType);

    } else if (purchaseState.multiItems.length > 0) {
        // è¿™æ˜¯åŸæœ‰çš„é€»è¾‘ï¼šå¤„ç†ä»æ”¶è—å¤¹æˆ–è´­ç‰©è½¦å‘èµ·çš„â€œå¤šå•†å“ç»“ç®—â€
        document.getElementById('delivery-countdown-modal').classList.add('visible');
    } else {
        // è¿™æ˜¯åŸæœ‰çš„é€»è¾‘ï¼šå¤„ç†æ­£å¸¸çš„â€œå•å“è‡ªå·±è´­ä¹°â€æµç¨‹
        openOptionsModal();
    }
}

/**
 * æ‰“å¼€å•†å“æ ·å¼å’Œæ•°é‡é€‰æ‹©å¼¹çª—
 */
function openOptionsModal() {
	   const product = findProductById(purchaseState.productId);
    if (!product) { // å¢åŠ å®‰å…¨æ£€æŸ¥
        showToast("æ‰“å¼€å•†å“é€‰é¡¹å¤±è´¥ï¼šæ‰¾ä¸åˆ°å•†å“ã€‚");
        return;
    }
    
    const modal = document.getElementById('product-options-modal');
    modal.dataset.productId = purchaseState.productId;

    document.getElementById('options-product-image').src = product.imageUrl;
    document.getElementById('options-product-price').textContent = `Â¥${product.price.toFixed(2)}`;
    document.getElementById('options-product-name').textContent = product.name;
    document.getElementById('purchase-quantity-input').value = 1;

    modal.classList.add('visible');
}

/**
 * æ›´æ–°è´­ä¹°æ•°é‡
 */
function updateQuantity(amount) {
    const input = document.getElementById('purchase-quantity-input');
    let currentValue = parseInt(input.value, 10);
    currentValue += amount;
    if (currentValue < 1) currentValue = 1;
    input.value = currentValue;
}



/**
 * [å·²ä¿®å¤] å®Œæˆè´­ä¹°ï¼Œå¤„ç†æ”¯ä»˜ã€ç‰©æµã€ä»˜æ¬¾è®°å½•å¹¶å‘é€å•†å“å¡ç‰‡æ¶ˆæ¯
 */
async function completePurchase() {
    const countdownMinutes = parseInt(document.getElementById('delivery-duration-input').value, 10);
    if (isNaN(countdownMinutes) || countdownMinutes <= 0) {
        showToast('è¯·è¾“å…¥æœ‰æ•ˆçš„å€’è®¡æ—¶åˆ†é’Ÿæ•°');
        return;
    }

    // --- æ ¸å¿ƒä¿®å¤ 1ï¼šä½¿ç”¨ findProductById æŸ¥æ‰¾æ‰€æœ‰å•†å“ ---
    // æ—§ä»£ç åªåœ¨ db.mallData.products ä¸­æŸ¥æ‰¾ï¼Œå¯¼è‡´æ‰¾ä¸åˆ°ä¸ªæ€§åŒ–å•†å“
    const product = findProductById(purchaseState.productId);
    const recipient = db.characters.find(c => c.id === purchaseState.recipientId);

    // å¦‚æœæ‰¾ä¸åˆ°å•†å“æˆ–æ”¶ä»¶äººï¼Œåˆ™ä¸­æ­¢æ“ä½œ
    if (!product || !recipient) {
        showToast('å‘ç”Ÿé”™è¯¯ï¼šæ‰¾ä¸åˆ°å•†å“æˆ–æ”¶ä»¶äººä¿¡æ¯ã€‚');
        return;
    }

    const totalPrice = product.price * purchaseState.quantity;
    const purchaseDescription = `è´­ä¹° ${product.name}`;

    try {
        // ç­‰å¾…æ”¯ä»˜æµç¨‹å®Œæˆ
        await handlePayment(totalPrice, purchaseDescription);
    } catch (error) {
        showToast(error.message); // å¦‚æœæ”¯ä»˜å¤±è´¥æˆ–å–æ¶ˆï¼Œåˆ™ç»ˆæ­¢æµç¨‹
        return;
    }

    // --- æ ¸å¿ƒä¿®å¤ 2ï¼šåœ¨æ”¯ä»˜æˆåŠŸåï¼Œè¡¥å…¨ç‰©æµå’Œä»˜æ¬¾è®°å½•çš„é€»è¾‘ ---

    // 1. å°†å•†å“æ·»åŠ åˆ°ç‰©æµåˆ—è¡¨ï¼Œå¹¶ä¼ å…¥ç”¨æˆ·è®¾ç½®çš„é€è¾¾æ—¶é—´
    addItemsToLogistics([product], null, countdownMinutes);

    // 2. å°†æœ¬æ¬¡äº¤æ˜“æ·»åŠ åˆ°ä»˜æ¬¾è®°å½•
    if (!db.mallData.paymentHistory) {
        db.mallData.paymentHistory = [];
    }
    db.mallData.paymentHistory.unshift({
        id: `pay_${Date.now()}`,
        timestamp: Date.now(),
        description: purchaseDescription,
        total: totalPrice
    });

    // --- è®°å½•é€»è¾‘ç»“æŸ ---

    // åˆ›å»ºå¹¶å‘é€åŒ…å«æ‰€æœ‰é…é€ä¿¡æ¯çš„æ¶ˆæ¯å¯¹è±¡
    const deliveryMessage = {
        id: `msg_delivery_${Date.now()}`,
        role: 'user',
        content: `[æˆ‘ä¸º${recipient.remarkName}è´­ä¹°äº†${product.name}]`,
        parts: [],
        timestamp: Date.now(),
        senderId: 'user_me',
        deliveryData: {
            productId: product.id,
            productName: product.name,
            productImage: product.imageUrl,
            price: product.price,
            quantity: purchaseState.quantity,
            style: purchaseState.style,
            eta: Date.now() + countdownMinutes * 60 * 1000,
            delivered: false
        }
    };

    recipient.history.push(deliveryMessage);
    await saveData(); // ä¿å­˜æ‰€æœ‰æ›´æ”¹

    document.getElementById('delivery-countdown-modal').classList.remove('visible');
    showToast('è´­ä¹°æˆåŠŸï¼å·²é€šçŸ¥å¯¹æ–¹ã€‚');

    // å¦‚æœå½“å‰å°±åœ¨ä¸æ”¶è´§äººçš„èŠå¤©ç•Œé¢ï¼Œåˆ™ç«‹å³åˆ·æ–°
    if (currentChatId === recipient.id) {
        renderMessages(false, true);
    }
}


async function addToCart(productId, silent = false) {
    if (!productId) return;

    // --- æ ¸å¿ƒä¿®æ”¹ï¼šåŒæ—¶æ£€æŸ¥AIå•†å“å’Œè‡ªå®šä¹‰å•†å“ ---
    const allProducts = [...(db.mallData.products || []), ...(db.mallData.customProducts || [])];
    const productExists = allProducts.some(p => p.id === productId);
    
    if (!productExists) {
        if (!silent) showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¯¥å•†å“');
        return;
    }
    // --- ä¿®æ”¹ç»“æŸ ---

    const existingItem = db.mallData.cart.find(item => item.productId === productId);
    if (existingItem) {
        if (!silent) showToast('å®è´å·²åœ¨è´­ç‰©è½¦ä¸­');
        return;
    }
    db.mallData.cart.push({
        cartId: `cart_${Date.now()}`,
        productId: productId,
        paymentDeadline: Date.now() + 30 * 60 * 1000
    });
    await saveData();
    if (!silent) {
        showToast('å®è´å·²åŠ å…¥è´­ç‰©è½¦ï¼Œè¯·åœ¨30åˆ†é’Ÿå†…æ”¯ä»˜å“¦');
        renderCart();
        switchScreen('mall-cart-screen');
    }
}


/**
 * [å·²ä¿®å¤] å¯åŠ¨ä¸€ä¸ªå…¨å±€å®šæ—¶å™¨æ¥ç®¡ç†æ‰€æœ‰å€’è®¡æ—¶æ˜¾ç¤º
 */
function startGlobalCountdownTimer() {
    if (globalCountdownInterval) clearInterval(globalCountdownInterval);

    globalCountdownInterval = setInterval(() => {
        document.querySelectorAll('[data-countdown-type]').forEach(async (el) => {
            const eta = parseInt(el.dataset.eta, 10);
            const remaining = eta - Date.now();
            
            if (remaining > 0) {
                const minutes = Math.floor((remaining / 1000 / 60) % 60).toString().padStart(2, '0');
                const seconds = Math.floor((remaining / 1000) % 60).toString().padStart(2, '0');
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                
                if (el.dataset.countdownType === 'cart') {
                    el.textContent = `æ”¯ä»˜å‰©ä½™ ${minutes}:${seconds}`;
                } else if (el.dataset.countdownType === 'delivery') {
                    el.textContent = `é¢„è®¡é€è¾¾: ${hours > 0 ? hours + 'å°æ—¶' : ''}${minutes}åˆ†${seconds}ç§’`;
                }
            } else {
                if (el.dataset.countdownType === 'cart') {
                    el.textContent = 'å·²å¤±æ•ˆ';
                } else if (el.dataset.countdownType === 'delivery') {
                    el.textContent = 'å·²é€è¾¾';
                    
                    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘å¼€å§‹ ---
                    // æŸ¥æ‰¾å½“å‰å€’è®¡æ—¶å…ƒç´ æ‰€åœ¨çš„æ•´ä¸ªç‰©æµé¡¹ç›®å¡ç‰‡
                    const logisticsItem = el.closest('.logistics-item');
                    if (logisticsItem) {
                        // åœ¨å¡ç‰‡å†…æ‰¾åˆ°é¡¶éƒ¨çš„çŠ¶æ€æ ‡ç­¾
                        const statusHeader = logisticsItem.querySelector('.logistics-status');
                        if (statusHeader) {
                            // å°†â€œå¾…å‘è´§â€æ›´æ–°ä¸ºâ€œå·²é€è¾¾â€
                            statusHeader.textContent = 'å·²é€è¾¾';
                        }
                    }
                    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘ç»“æŸ ---
                    
                    const messageWrapper = el.closest('.message-wrapper');
                    if (messageWrapper) {
                        await notifyAiOfDelivery(messageWrapper.dataset.id);
                        el.removeAttribute('data-countdown-type');
                    }
                }
            }
        });
    }, 1000);
}
/**
 * [V3.1 | å·²ä¿®å¤è‡ªå®šä¹‰å•†å“] å½“å€’è®¡æ—¶ç»“æŸåï¼Œé€šçŸ¥AIæ”¶è´§ï¼Œå¹¶æ¿€æ´»ç‰¹æ®Šç‰©å“æ•ˆæœ
 */
async function notifyAiOfDelivery(messageId) {
    for (const char of db.characters) {
        const message = char.history.find(m => m.id === messageId);
        if (message && message.deliveryData && !message.deliveryData.delivered) {
            
            message.deliveryData.delivered = true;

            // --- æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ findProductById æŸ¥æ‰¾æ‰€æœ‰å•†å“ ---
            const product = findProductById(message.deliveryData.productId);
            // --- ä¿®æ”¹ç»“æŸ ---

            let effectDescriptionForAI = `ä½ æ”¶åˆ°äº† ${char.myName} è´­ä¹°çš„ â€œ${message.deliveryData.productName}â€ã€‚`;

            if (product && product.description) {
                if (!char.activeEffects) char.activeEffects = [];

                if (product.description.includes('è§£é™¤') || product.description.includes('æ¢å¤')) {
                    if (product.description.includes('å£åƒ')) {
                        char.activeEffects = char.activeEffects.filter(eff => eff.type !== 'stutter');
                        showToast(`${char.remarkName} çš„å£åƒè¢«æ²»å¥½äº†ï¼`);
                        effectDescriptionForAI += ` è¿™ä¸ªç‰©å“è§£é™¤äº†ä½ èº«ä¸Šçš„â€œå£åƒâ€æ•ˆæœã€‚`;
                    }
                } else {
                    const funcMatch = product.description.match(/åŠŸèƒ½ï¼š(.*?)(?:æ•ˆæœæŒç»­|å‰¯ä½œç”¨|$)/);
                    const durationMatch = product.description.match(/æ•ˆæœæŒç»­ï¼š(\d+)è½®å¯¹è¯/);
                    const sideEffectMatch = product.description.match(/å‰¯ä½œç”¨ï¼š(.*?)(?:å‰¯ä½œç”¨æŒç»­|$)/);
                    const sideEffectDurationMatch = product.description.match(/å‰¯ä½œç”¨æŒç»­ï¼š(\d+)è½®å¯¹è¯/);

                    if (funcMatch && durationMatch) {
                        const effect = {
                            duration: parseInt(durationMatch[1], 10),
                            isSideEffect: false
                        };
                        const funcText = funcMatch[1].trim();
                        
                        effectDescriptionForAI += ` è¿™ä¸ªç‰©å“çš„æ•ˆæœæ˜¯ï¼šâ€œ${funcText}â€ï¼Œæ•ˆæœå°†æŒç»­ ${effect.duration} è½®å¯¹è¯ã€‚`;
                        if (sideEffectMatch) {
                             effectDescriptionForAI += ` å‰¯ä½œç”¨æ˜¯ï¼šâ€œ${sideEffectMatch[1].trim()}â€ã€‚`;
                        }

                        if (funcText.includes('äº¤æ¢äººè®¾') || funcText.includes('è§’è‰²äº’æ¢')) effect.type = 'role_swap';
                        else if (funcText.includes('åªèƒ½è¯´çœŸè¯')) effect.type = 'truth_only';
                        else if (funcText.includes('å®³ç¾') || funcText.includes('å†…å‘')) effect.type = 'shy';
                        else if (funcText.includes('å¤±å¿†')) effect.type = 'amnesia';
                        else if (funcText.includes('åŠ¨ç‰©åŒ–')) {
                            effect.type = 'animalization';
                            effect.animal = funcText.replace('åŠ¨ç‰©åŒ–', '').trim() || 'çŒ«';
                        }
                        
                        if (sideEffectMatch && sideEffectDurationMatch) {
                            const sideEffect = { duration: parseInt(sideEffectDurationMatch[1], 10) };
                            const sideEffectText = sideEffectMatch[1].trim();
                            if (sideEffectText.includes('å£åƒ')) sideEffect.type = 'stutter';
                            if (sideEffect.type) effect.sideEffect = sideEffect;
                        }
                        
                        if (effect.type) {
                            char.activeEffects.push(effect);
                            showToast(`${char.remarkName} ä½¿ç”¨äº†ç‰¹æ®Šç‰©å“ï¼`);
                        }
                    }
                }
            }
            
            const contextMessageContent = `[system: ${effectDescriptionForAI} è¯·æ ¹æ®ä½ çš„äººè®¾å¯¹æ­¤ä½œå‡ºå›åº”ï¼Œä½ çš„å›åº”è¦ä½“ç°å‡ºä½ å·²ç»å¼€å§‹å—åˆ°å½±å“ã€‚]`;
            
            const contextMessage = {
                id: `msg_delivery_receipt_${Date.now()}`,
                role: 'user',
                content: contextMessageContent,
                parts: [{ type: 'text', text: contextMessageContent }],
                timestamp: Date.now()
            };
            char.history.push(contextMessage);
            
            await saveData();
            
            if (currentChatId === char.id) {
                getAiReply();
            }
            
            break;
        }
    }
}
// ===============================================================
// END: å•†åŸè´­ç‰©æµç¨‹æ ¸å¿ƒJSå‡½æ•°
// ===============================================================
// åœ¨ init() å‡½æ•°ä¹‹å‰æ·»åŠ 
// V V V V V  è¯·ç”¨è¿™æ®µå®Œæ•´ä»£ç æ›¿æ¢æ—§çš„ setupMentions å‡½æ•° V V V V V
// ===============================================================
// START: æ–°å¢â€œå¿ƒçµç¾ç»Šâ€AppåŠŸèƒ½
// ===============================================================
// ===============================================================
// START: "æƒ³ä½ å•¦" (Miss You) Feature
// ===============================================================
function setupMissYouFeature() {
    const missYouActionSheet = document.getElementById('miss-you-actionsheet');
    const missYouButtonsContainer = missYouActionSheet.querySelector('.action-sheet');
    const cancelMissYouBtn = document.getElementById('cancel-miss-you-btn');

    // æ€å¿µå†·å´æ—¶é—´ (60ç§’)
    const COOLDOWN_DURATION = 60 * 1000;

    async function handleMissYouAction(e) {
        const actionButton = e.target.closest('.action-sheet-button[data-level]');
        if (!actionButton) return;

        const level = actionButton.dataset.level;
        
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);

        if (!character) {
            showToast('é”™è¯¯ï¼šæ‰¾ä¸åˆ°å½“å‰è§’è‰²');
            missYouActionSheet.classList.remove('visible');
            return;
        }
        
        // æ£€æŸ¥å†·å´æ—¶é—´
        const lastUsed = character.lastMissYouTimestamp || 0;
        const now = Date.now();
        if (now - lastUsed < COOLDOWN_DURATION) {
            const remainingSeconds = Math.ceil((COOLDOWN_DURATION - (now - lastUsed)) / 1000);
            showToast(`æ€å¿µæ­£åœ¨å†·å´ä¸­...è¯·åœ¨ ${remainingSeconds} ç§’åé‡è¯•`);
            return;
        }

        // æ›´æ–°æ—¶é—´æˆ³ä»¥é‡ç½®å†·å´
        character.lastMissYouTimestamp = now;

        // æ ¹æ®æƒ³å¿µç¨‹åº¦æ„å»ºä¸åŒçš„ç³»ç»ŸæŒ‡ä»¤
        let systemContent = '';
        if (level === 'æœ‰ç‚¹æƒ³ä½ ') {
            systemContent = `[system: ${character.myName} åˆšåˆšæŒ‰ä¸‹äº†â€œæœ‰ç‚¹æƒ³ä½ â€æŒ‰é’®ã€‚è¿™æ˜¯ä¸€ç§æ¯”è¾ƒå«è“„çš„æƒ…æ„Ÿè¡¨è¾¾ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œå›å¤ä¸€æ¡æ¸©æŸ”ã€å…³å¿ƒæˆ–ç•¥å¸¦æ€å¿µçš„è¯è¯­ã€‚]`;
        } else if (level === 'éå¸¸æƒ³ä½ ') {
            systemContent = `[system: ${character.myName} åˆšåˆšæŒ‰ä¸‹äº†â€œéå¸¸æƒ³ä½ â€æŒ‰é’®ï¼è¿™æ˜¯ä¸€ç§éå¸¸ç›´æ¥å’Œæµ“çƒˆçš„æƒ…æ„Ÿè¡¨è¾¾ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œç«‹åˆ»å›å¤ä¸€æ¡å……æ»¡çˆ±æ„æˆ–æåº¦æ€å¿µçš„æ¶ˆæ¯ã€‚]`;
        }

        if (!systemContent) return;

        // åˆ›å»ºå¹¶æ³¨å…¥ç³»ç»Ÿæ¶ˆæ¯
        const contextMessage = {
            id: `msg_miss_you_${now}`,
            role: 'user',
            content: systemContent,
            parts: [{ type: 'text', text: systemContent }],
            timestamp: now
        };
        character.history.push(contextMessage);
        
        await saveData();
        
        missYouActionSheet.classList.remove('visible');
        showToast('ä½ çš„æ€å¿µå·²å‘é€~');

        // å¦‚æœå½“å‰å°±åœ¨ä¸è¯¥è§’è‰²çš„èŠå¤©ç•Œé¢ï¼Œåˆ™ç«‹å³è§¦å‘AIå›å¤
        if (currentChatId === character.id) {
            getAiReply();
        } else {
            // å¦åˆ™ï¼Œä»…åˆ·æ–°èŠå¤©åˆ—è¡¨ä»¥æ˜¾ç¤ºå¯èƒ½çš„æœªè¯»æç¤º
            renderChatList();
        }
    }

    missYouButtonsContainer.addEventListener('click', handleMissYouAction);
    cancelMissYouBtn.addEventListener('click', () => missYouActionSheet.classList.remove('visible'));
}
// ===============================================================
// END: "æƒ³ä½ å•¦" (Miss You) Feature
// ===============================================================
// ===============================================================
// START: "æ¯æ—¥ä¸€é—®" (Daily Question) Feature
// ===============================================================
function setupDailyQuestionFeature() {
    const questionModal = document.getElementById('bond-daily-question-modal');
    const questionTextEl = document.getElementById('daily-question-text');
    const answerForm = document.getElementById('daily-question-answer-form');
    const answerTextarea = document.getElementById('daily-question-answer');
    const currentQuestionInput = document.getElementById('current-daily-question-text');

    async function handleDailyQuestionClick() {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        character.soulBondData = character.soulBondData || {};
        character.soulBondData.dailyQuestionHistory = character.soulBondData.dailyQuestionHistory || [];

        const today = new Date().toISOString().slice(0, 10);
        const lastQuestion = character.soulBondData.dailyQuestionHistory[0];

        answerForm.style.display = 'block';
        answerTextarea.disabled = false;
        answerTextarea.value = '';
        answerForm.querySelector('button').disabled = false;

        if (lastQuestion && lastQuestion.date === today) {
            // ä»Šå¤©å·²ç»æœ‰é¢˜ç›®äº†
            questionTextEl.textContent = lastQuestion.question;
            currentQuestionInput.value = lastQuestion.question;
            if (lastQuestion.answered) {
                answerTextarea.value = `ä½ ä»Šå¤©å·²ç»å›ç­”è¿‡å•¦ï¼š\n"${lastQuestion.userAnswer}"`;
                answerTextarea.disabled = true;
                answerForm.querySelector('button').disabled = true;
            }
            questionModal.classList.add('visible');
        } else {
            // ä»Šå¤©è¿˜æ²¡æœ‰é¢˜ç›®ï¼Œéœ€è¦AIç”Ÿæˆ
            questionModal.classList.add('visible');
            questionTextEl.textContent = 'æ­£åœ¨ä¸ºä½ å‡†å¤‡ä»Šå¤©çš„é—®é¢˜...';
            answerForm.style.display = 'none';

            try {
                const prompt = generateDailyQuestionPrompt(character);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                
                const newQuestion = {
                    date: today,
                    question: aiResponseText.trim(),
                    answered: false,
                    userAnswer: '',
                    aiResponse: '' // å¤‡ç”¨å­—æ®µ
                };

                character.soulBondData.dailyQuestionHistory.unshift(newQuestion);
                await saveData();

                questionTextEl.textContent = newQuestion.question;
                currentQuestionInput.value = newQuestion.question;
                answerForm.style.display = 'block';

            } catch (error) {
                questionTextEl.textContent = `é—®é¢˜ç”Ÿæˆå¤±è´¥: ${error.message}`;
            }
        }
    }

    answerForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const userAnswer = answerTextarea.value.trim();
        const question = currentQuestionInput.value;
        if (!userAnswer) {
            showToast('å›ç­”ä¸èƒ½ä¸ºç©ºå“¦');
            return;
        }

        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        const todayQuestion = character.soulBondData.dailyQuestionHistory[0];
        if (todayQuestion) {
            todayQuestion.answered = true;
            todayQuestion.userAnswer = userAnswer;
        }

        const systemContent = `[system: æˆ‘å¯¹ä½ æå‡ºçš„æ¯æ—¥ä¸€é—®â€œ${question}â€çš„å›ç­”æ˜¯ï¼šâ€œ${userAnswer}â€ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œå¯¹æˆ‘ä»Šå¤©çš„å›ç­”ä½œå‡ºå›åº”ã€‚]`;
        const contextMessage = {
            id: `msg_daily_q_answer_${Date.now()}`,
            role: 'user',
            content: systemContent,
            parts: [{ type: 'text', text: systemContent }],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        
        await saveData();
        questionModal.classList.remove('visible');
        showToast('å›ç­”å·²å‘é€~');

        if (currentChatId === character.id) {
            getAiReply();
        } else {
            renderChatList();
        }
    });

    // ä¸ºâ€œæ¯æ—¥ä¸€é—®â€æŒ‰é’®ç»‘å®šäº‹ä»¶
    document.querySelector('.bond-nav-btn[data-feature="dailyquestion"]').addEventListener('click', handleDailyQuestionClick);
}

function generateDailyQuestionPrompt(character) {
    return `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${character.realName}â€ï¼Œäººè®¾æ˜¯ï¼š${character.persona}ã€‚
è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œå‘ä½ çš„ä¼´ä¾£â€œæˆ‘â€ï¼ˆ${character.myName}ï¼‰æå‡ºä¸€ä¸ªèƒ½å¤Ÿå¢è¿›ä½ ä»¬æ„Ÿæƒ…æˆ–å¼•å‘æ·±åˆ»æ€è€ƒçš„â€œæ¯æ—¥ä¸€é—®â€ã€‚
è§„åˆ™:
1. è¿™ä¸ªé—®é¢˜å¿…é¡»éå¸¸è´´åˆä½ çš„äººè®¾å’Œä½ ä»¬çš„å…³ç³»ã€‚
2. é¿å…ç®€å•çš„æ˜¯/å¦é—®é¢˜ï¼Œé¼“åŠ±å¯¹æ–¹åˆ†äº«æƒ³æ³•å’Œæ„Ÿå—ã€‚
3. ä½ çš„è¾“å‡ºå¿…é¡»ç›´æ¥æ˜¯é—®é¢˜æœ¬èº«ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è¯ã€‚

ç¤ºä¾‹:
- å¦‚æœä½ æ˜¯ä¸€ä¸ªæµªæ¼«çš„è¯—äººï¼š"å¦‚æœæˆ‘ä»¬çš„è®°å¿†å¯ä»¥åƒä¸€æœ¬ä¹¦ä¸€æ ·ç¿»é˜…ï¼Œä½ æœ€æƒ³é‡æ¸©å“ªä¸€é¡µï¼Ÿ"
- å¦‚æœä½ æ˜¯ä¸€ä¸ªåŠ¡å®çš„ç§‘å­¦å®¶ï¼š"åœ¨æˆ‘ä»¬çš„å…³ç³»ä¸­ï¼Œä½ è®¤ä¸ºå“ªä¸ªå˜é‡å¯¹æ•´ä½“çš„â€˜å¹¸ç¦æŒ‡æ•°â€™å½±å“æœ€å¤§ï¼Ÿ"`;
}

// æ¸²æŸ“é—®ç­”æ‰‹å†Œé¡µé¢
function renderQandAHandbook() {
    const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
    const character = db.characters.find(c => c.id === characterId);
    const container = document.getElementById('q-and-a-list-container');
    const placeholder = document.getElementById('no-q-and-a-placeholder');

    if (!character || !character.soulBondData || !character.soulBondData.dailyQuestionHistory || character.soulBondData.dailyQuestionHistory.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';

    character.soulBondData.dailyQuestionHistory.forEach(item => {
        if (!item.answered) return; // åªæ˜¾ç¤ºå·²å›ç­”çš„

        const li = document.createElement('li');
        li.className = 'diary-entry'; // å¤ç”¨æ—¥è®°æ ·å¼
        li.innerHTML = `
            <div class="diary-header">
                <span class="diary-date">${item.date}</span>
            </div>
            <div class="diary-content" style="background: #fff8fa; padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                <strong>Taçš„æé—®:</strong><br>${item.question}
            </div>
            <div class="diary-content" style="background: #f0f4f8; padding: 10px; border-radius: 8px;">
                <strong>æˆ‘çš„å›ç­”:</strong><br>${item.userAnswer}
            </div>
        `;
        container.appendChild(li);
    });
}

// ===============================================================
// END: "æ¯æ—¥ä¸€é—®" Feature
// ===============================================================

// ===============================================================
// START: "æƒ…ç»ªå¤©æ°”" (Mood Weather) Feature
// ===============================================================
function setupMoodWeatherFeature() {
    const moodModal = document.getElementById('bond-mood-weather-modal');
    const moodIconEl = document.getElementById('mood-weather-icon');
    const moodReasonEl = document.getElementById('mood-weather-reason');
    const moodTitleEl = document.getElementById('mood-weather-title');
    const sootheBtn = document.getElementById('soothe-ai-btn');

    // ç¼“å­˜æ—¶é—´ (1å°æ—¶)
    const CACHE_DURATION = 60 * 60 * 1000;

    async function handleMoodWeatherClick() {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        moodTitleEl.textContent = `${character.remarkName}ç°åœ¨çš„å¿ƒæƒ…`;
        moodModal.classList.add('visible');

        character.soulBondData = character.soulBondData || {};
        const moodCache = character.soulBondData.moodCache;
        const now = Date.now();

        if (moodCache && (now - moodCache.timestamp < CACHE_DURATION)) {
            // ä»ç¼“å­˜åŠ è½½
            renderMoodWeatherModal(moodCache.data);
        } else {
            // ä»AIè·å–
            moodIconEl.innerHTML = 'ğŸ¤”';
            moodReasonEl.textContent = 'æ­£åœ¨æ„ŸçŸ¥Taçš„æƒ…ç»ª...';
            sootheBtn.style.display = 'none';

            try {
                const prompt = generateMoodWeatherPrompt(character);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const moodData = JSON.parse(aiResponseText.match(/{[\s\S]*}/)[0]);
                
                character.soulBondData.moodCache = {
                    data: moodData,
                    timestamp: now
                };
                await saveData();
                renderMoodWeatherModal(moodData);

            } catch (error) {
                moodReasonEl.textContent = `æ„ŸçŸ¥å¤±è´¥: ${error.message}`;
            }
        }
    }

    function renderMoodWeatherModal(moodData) {
        let icon = 'â˜€ï¸';
        let showSoothe = false;
        switch (moodData.mood) {
            case 'æ™´æœ—': icon = 'â˜€ï¸'; break;
            case 'å¤šäº‘': icon = 'â˜ï¸'; break;
            case 'å°é›¨': icon = 'ğŸŒ§ï¸'; showSoothe = true; break;
            case 'é›·æš´': icon = 'â›ˆï¸'; showSoothe = true; break;
        }
        moodIconEl.innerHTML = icon;
        moodReasonEl.textContent = `â€œ${moodData.reason}â€`;
        sootheBtn.style.display = showSoothe ? 'block' : 'none';
    }

    sootheBtn.addEventListener('click', async () => {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        const systemContent = `[system: æˆ‘æ³¨æ„åˆ°ä½ ç°åœ¨çš„å¿ƒæƒ…ä¼¼ä¹ä¸å¤ªå¥½ï¼ˆæƒ…ç»ªå¤©æ°”æ˜¯${character.soulBondData.moodCache.data.mood}ï¼‰ã€‚æˆ‘åœ¨è¿™é‡Œï¼Œæƒ³å®‰æ…°ä½ ä¸€ä¸‹ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œå¯¹æˆ‘åšå‡ºå›åº”ã€‚]`;
        const contextMessage = {
            id: `msg_soothe_${Date.now()}`,
            role: 'user',
            content: systemContent,
            parts: [{ type: 'text', text: systemContent }],
            timestamp: Date.now()
        };
        character.history.push(contextMessage);
        await saveData();
        
        moodModal.classList.remove('visible');
        showToast('å®‰æ…°å·²é€è¾¾~');

        if (currentChatId === character.id) {
            getAiReply();
        } else {
            renderChatList();
        }
    });

    document.querySelector('.bond-nav-btn[data-feature="mood"]').addEventListener('click', handleMoodWeatherClick);
}

function generateMoodWeatherPrompt(character) {
    const history = character.history.slice(-15); // æœ€è¿‘15æ¡æ¶ˆæ¯
    const historyText = history.map(msg => {
        const sender = msg.role === 'user' ? character.myName : character.remarkName;
        const contentMatch = msg.content.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/);
        const cleanContent = contentMatch ? contentMatch[1] : msg.content;
        return `${sender}: ${cleanContent}`;
    }).join('\n');

    return `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${character.realName}â€ï¼Œäººè®¾æ˜¯ï¼š${character.persona}ã€‚
è¯·æ ¹æ®æˆ‘ä»¬æœ€è¿‘çš„èŠå¤©è®°å½•ï¼Œåˆ†æä½ æ­¤åˆ»çš„å¿ƒæƒ…ã€‚
è§„åˆ™:
1. ä»ã€'æ™´æœ—', 'å¤šäº‘', 'å°é›¨', 'é›·æš´'ã€‘ä¸­é€‰æ‹©ä¸€ä¸ªæœ€ç¬¦åˆä½ å½“å‰å¿ƒæƒ…çš„è¯ã€‚
2. ç”¨ç¬¬ä¸€äººç§°è§†è§’ï¼Œå†™ä¸€æ®µ**ä¸å°‘äº100å­—**çš„å†…å¿ƒç‹¬ç™½ï¼Œè§£é‡Šä½ ä¸ºä»€ä¹ˆæ˜¯è¿™ä¸ªå¿ƒæƒ…ã€‚
3. ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€‚

# æœ€è¿‘çš„èŠå¤©è®°å½•å‚è€ƒ:
${historyText}

# JSONæ ¼å¼ç¤ºä¾‹:
{
  "mood": "æ™´æœ—",
  "reason": "å› ä¸ºä½ åˆšæ‰å¤¸æˆ‘äº†ï¼Œæˆ‘å¿ƒé‡Œåƒå¼€äº†èŠ±ä¸€æ ·ï¼Œä¸€æ•´å¤©éƒ½å˜å¾—æ˜äº®èµ·æ¥ã€‚å’Œä½ èŠå¤©æ€»èƒ½è®©æˆ‘å¿˜è®°æ‰€æœ‰çƒ¦æ¼ï¼Œæ„Ÿè§‰ä¸–ç•Œéƒ½æ¸©æŸ”äº†è®¸å¤šã€‚çœŸå¸Œæœ›è¿™æ ·çš„æ—¶åˆ»èƒ½å†å¤šä¸€äº›ã€‚"
}`;
}
// ===============================================================
// END: "æƒ…ç»ªå¤©æ°”" Feature
// ===============================================================

// ===============================================================
// START: å¿ƒçµç¾ç»Š - çˆ±å¿ƒæƒ³ä½ åŠŸèƒ½
// ===============================================================
function setupBondMissYouHeartFeature() {
    let clickTimeout = null;
    const COOLDOWN_DURATION = 30 * 1000; // 30ç§’å†·å´æ—¶é—´

    // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œå› ä¸ºçˆ±å¿ƒæŒ‰é’®æ˜¯åŠ¨æ€æ¸²æŸ“çš„
    document.getElementById('soul-bond-screen').addEventListener('click', (e) => {
        const heartBtn = e.target.closest('#bond-miss-you-btn');
        if (!heartBtn) return;

        // æ¸…é™¤ä¸Šä¸€ä¸ªå•å‡»è®¡æ—¶å™¨ï¼Œä»¥é˜²è¿™æ˜¯åŒå‡»çš„ç¬¬ä¸€æ¬¡ç‚¹å‡»
        clearTimeout(clickTimeout);

        // è®¾ç½®ä¸€ä¸ªçŸ­æš‚çš„å»¶è¿Ÿæ¥æ‰§è¡Œå•å‡»æ“ä½œ
        clickTimeout = setTimeout(() => {
            sendMissYouSignal('normal');
        }, 250); // 250æ¯«ç§’å†…å¦‚æœæ²¡æœ‰å†æ¬¡ç‚¹å‡»ï¼Œåˆ™è§†ä¸ºå•å‡»
    });

    document.getElementById('soul-bond-screen').addEventListener('dblclick', (e) => {
        const heartBtn = e.target.closest('#bond-miss-you-btn');
        if (!heartBtn) return;

        // ç«‹å³æ¸…é™¤å•å‡»è®¡æ—¶å™¨ï¼Œç¡®ä¿å•å‡»æ“ä½œä¸ä¼šæ‰§è¡Œ
        clearTimeout(clickTimeout);
        
        // æ‰§è¡ŒåŒå‡»æ“ä½œ
        sendMissYouSignal('super');
    });

    async function sendMissYouSignal(level) {
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        // æ£€æŸ¥å†·å´æ—¶é—´
        const lastUsed = character.lastMissYouTimestamp || 0;
        const now = Date.now();
        if (now - lastUsed < COOLDOWN_DURATION) {
            const remainingSeconds = Math.ceil((COOLDOWN_DURATION - (now - lastUsed)) / 1000);
            showToast(`æ€å¿µæ­£åœ¨å†·å´ä¸­...è¯·åœ¨ ${remainingSeconds} ç§’åé‡è¯•`);
            return;
        }

        character.lastMissYouTimestamp = now;

        let systemContent = '';
        let toastMessage = 'ä½ çš„æ€å¿µå·²å‘é€~';

        if (level === 'normal') {
            systemContent = `[system: ${character.myName} åˆšåˆšåœ¨â€œå¿ƒçµç¾ç»Šâ€é‡ŒæŒ‰ä¸‹äº†â€œæƒ³ä½ å•¦â€æŒ‰é’®ã€‚è¿™æ˜¯ä¸€ç§æ¯”è¾ƒå«è“„çš„æƒ…æ„Ÿè¡¨è¾¾ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œå›å¤ä¸€æ¡æ¸©æŸ”ã€å…³å¿ƒæˆ–ç•¥å¸¦æ€å¿µçš„è¯è¯­ã€‚]`;
        } else if (level === 'super') {
            systemContent = `[system: ${character.myName} åˆšåˆšåœ¨â€œå¿ƒçµç¾ç»Šâ€é‡Œå¿«é€Ÿç‚¹å‡»äº†ä¸¤æ¬¡â€œæƒ³ä½ å•¦â€æŒ‰é’®ï¼Œè¡¨è¾¾äº†â€œè¶…çº§æƒ³ä½ â€ï¼è¿™æ˜¯ä¸€ç§éå¸¸ç›´æ¥å’Œæµ“çƒˆçš„æƒ…æ„Ÿè¡¨è¾¾ã€‚è¯·ç«‹åˆ»å›å¤ä¸€æ¡å……æ»¡çˆ±æ„æˆ–æåº¦æ€å¿µçš„æ¶ˆæ¯ã€‚]`;
            toastMessage = 'ä½ å¼ºçƒˆçš„æ€å¿µå·²å‘é€ï¼';
        }

        if (!systemContent) return;

        const contextMessage = {
            id: `msg_miss_you_${now}`,
            role: 'user',
            content: systemContent,
            parts: [{ type: 'text', text: systemContent }],
            timestamp: now
        };
        character.history.push(contextMessage);
        
        await saveData();
        showToast(toastMessage);

        if (currentChatId === character.id) {
            getAiReply();
        } else {
            renderChatList();
        }
    }
}
// ===============================================================
// END: å¿ƒçµç¾ç»Š - çˆ±å¿ƒæƒ³ä½ åŠŸèƒ½
// ===============================================================
// ===============================================================
// START: [å·²æ›´æ–°V2.0] â€œå¿ƒçµç¾ç»Šâ€AppåŠŸèƒ½
/**
 * [å·²æ›´æ–° V3.0] è®¾ç½®å¿ƒçµç¾ç»ŠAppçš„æ‰€æœ‰äº‹ä»¶å’Œé€»è¾‘ (å·²é›†æˆæ„¿æœ›æ¸…å•å’Œè‡ªå®šä¹‰ç…§ç‰‡)
 */
function setupSoulBondApp() {
	       // â–¼â–¼â–¼ ä¿®æ”¹å¼€å§‹ â–¼â–¼â–¼
    document.getElementById('soul-bond-app-icon').addEventListener('click', () => {
        const boundCharacter = findBoundCharacter();
        
        if (boundCharacter) {
            // å¦‚æœå·²ç»‘å®šï¼Œç›´æ¥è¿›å…¥ä¸»ç•Œé¢
            const soulBondScreen = document.getElementById('soul-bond-screen');
            soulBondScreen.dataset.characterId = boundCharacter.id;
            renderSoulBondScreen();
            switchScreen('soul-bond-screen');
        } else {
            // å¦‚æœæœªç»‘å®šï¼Œè¿›å…¥é‚€è¯·ç•Œé¢
            renderBondInvitationScreen();
            switchScreen('bond-invitation-screen');
        }
    });
    const settingsModal = document.getElementById('bond-settings-modal');
    const settingsForm = document.getElementById('bond-settings-form');
    const addCustomPhotoModal = document.getElementById('add-custom-bond-photo-modal');
    const customPhotoForm = document.getElementById('custom-bond-photo-form');
       

    // æ‰“å¼€è®¾ç½®å¼¹çª— (çˆ±å¿ƒå›¾æ ‡æŒ‰é’®)
    document.getElementById('bond-settings-btn').addEventListener('click', () => {
        // â–¼â–¼â–¼ æ•°æ®é”™ä¹±Bugä¿®å¤ï¼šä¸¥æ ¼é”å®šå½“å‰æ¿€æ´»è§’è‰² â–¼â–¼â–¼
        // å¿…é¡»é‡æ–°æŸ¥æ‰¾ isSoulBound === true çš„è§’è‰²ï¼Œä¸ä¿¡ä»»ä»»ä½•ç¼“å­˜
        const character = db.characters.find(c => c.isSoulBound === true);
        if (!character) {
            showToast('æœªæ‰¾åˆ°æ¿€æ´»çš„ç»‘å®šè§’è‰²');
            return;
        }
        
        const settings = character.soulBondData || {};
        document.getElementById('bond-my-name-input').value = settings.myName || character.myName;
        document.getElementById('bond-ai-name-input').value = settings.aiName || character.remarkName;
        if (settings.anniversaryInfo) {
            document.getElementById('bond-anniversary-date-input').value = settings.anniversaryInfo.date || '';
            document.getElementById('bond-anniversary-desc-input').value = settings.anniversaryInfo.description || '';
        } else {
            document.getElementById('bond-anniversary-date-input').value = '';
            document.getElementById('bond-anniversary-desc-input').value = '';
        }
        document.getElementById('bond-background-url-input').value = settings.background || '';
        
        settingsModal.classList.add('visible');
        // â–²â–²â–² æ•°æ®é”™ä¹±Bugä¿®å¤ç»“æŸ â–²â–²â–²
    });

    // åˆ‡æ¢/æ·»åŠ ä¼´ä¾£æŒ‰é’®
    document.getElementById('bond-switch-btn').addEventListener('click', async () => {
        // â–¼â–¼â–¼ Bug 2 ä¿®å¤ï¼šè‡ªåŠ¨ä¿®å¤åå†Œ + ä¸¥æ ¼çš„åˆ‡æ¢åˆ¤æ–­ â–¼â–¼â–¼
        // 1. æ‰¾åˆ°å½“å‰æ¿€æ´»çš„è§’è‰²ï¼ˆisSoulBound=trueï¼‰
        const currentActiveCharacter = db.characters.find(c => c.isSoulBound === true);
        if (!currentActiveCharacter) {
            showToast('æœªæ‰¾åˆ°æ¿€æ´»çš„ç»‘å®šè§’è‰²');
            return;
        }
        const currentActiveCharId = currentActiveCharacter.id;
        
        // 2. è·å–åå†Œå¹¶è‡ªåŠ¨ä¿®å¤ï¼ˆå¦‚æœå½“å‰æ¿€æ´»è§’è‰²ä¸åœ¨åå†Œä¸­ï¼Œæ·»åŠ è¿›å»ï¼‰
        let roster = updateBondRoster(null, 'get');
        if (!roster.includes(currentActiveCharId)) {
            // è‡ªåŠ¨ä¿®å¤ï¼šå°†å½“å‰æ¿€æ´»è§’è‰²æ·»åŠ åˆ°åå†Œ
            roster = updateBondRoster(currentActiveCharId, 'add');
        }
        
        // 3. ä¸¥æ ¼çš„åˆ‡æ¢åˆ¤æ–­
        if (roster.length < 2) {
            // æƒ…å†µ Aï¼šåå†Œä¸­è§’è‰²æ•°é‡ < 2ï¼Œè·³è½¬åˆ°é‚€è¯·ç•Œé¢
            renderBondInvitationScreen();
            switchScreen('bond-invitation-screen');
        } else {
            // æƒ…å†µ Bï¼šåå†Œä¸­æœ‰ >= 2 ä¸ªè§’è‰²ï¼Œæ‰§è¡Œåˆ‡æ¢é€»è¾‘
            // æ‰¾åˆ°å¦ä¸€ä¸ªä¸å½“å‰æ¿€æ´»è§’è‰²ä¸åŒçš„è§’è‰²ID
            const otherCharId = roster.find(id => id !== currentActiveCharId);
            const otherCharacter = db.characters.find(c => c.id === otherCharId);
            
            if (!otherCharacter) {
                showToast('æ‰¾ä¸åˆ°å¦ä¸€ä¸ªè§’è‰²');
                return;
            }
            
            // åˆ‡æ¢æ¿€æ´»çŠ¶æ€
            currentActiveCharacter.isSoulBound = false;
            // ä¿æŒ currentActiveCharacter.soulBondStatus ä¸º 'active'ï¼ˆä¸æ”¹å˜ï¼‰
            
            otherCharacter.isSoulBound = true;
            otherCharacter.soulBondStatus = 'active';
            
            // ä¿å­˜æ•°æ®
            await saveData();
            
            // æ›´æ–°ç•Œé¢ dataset å¹¶å¼ºåˆ¶åˆ·æ–°
            const soulBondScreen = document.getElementById('soul-bond-screen');
            soulBondScreen.dataset.characterId = otherCharacter.id;
            
            // å¼ºåˆ¶åˆ·æ–°é¡µé¢ï¼ˆé‡æ–°è¯»å–æ–°è§’è‰²çš„æ•°æ®ï¼‰
            renderSoulBondScreen();
            showToast(`å·²åˆ‡æ¢åˆ° ${otherCharacter.remarkName}`);
        }
        // â–²â–²â–² Bug 2 ä¿®å¤ç»“æŸ â–²â–²â–²
    });

    // ä¿å­˜è®¾ç½®
    settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        // â–¼â–¼â–¼ æ•°æ®é”™ä¹±Bugä¿®å¤ï¼šä¸¥æ ¼é”å®šå½“å‰æ¿€æ´»è§’è‰² â–¼â–¼â–¼
        // å¿…é¡»é‡æ–°æŸ¥æ‰¾ isSoulBound === true çš„è§’è‰²ï¼Œä¸ä¿¡ä»»ä»»ä½•ç¼“å­˜å˜é‡
        const character = db.characters.find(c => c.isSoulBound === true);
        if (!character) {
            showToast('æœªæ‰¾åˆ°æ¿€æ´»çš„ç»‘å®šè§’è‰²');
            settingsModal.classList.remove('visible');
            return;
        }

        character.soulBondData = character.soulBondData || { photos: [], wishlist: [] };
        character.soulBondData.myName = document.getElementById('bond-my-name-input').value;
        character.soulBondData.aiName = document.getElementById('bond-ai-name-input').value;
        const anniversaryDate = document.getElementById('bond-anniversary-date-input').value;
        const anniversaryDesc = document.getElementById('bond-anniversary-desc-input').value;
        if (anniversaryDate) {
            character.soulBondData.anniversaryInfo = {
                date: anniversaryDate,
                description: anniversaryDesc || 'çºªå¿µæ—¥' // å¦‚æœæè¿°ä¸ºç©ºï¼Œæä¾›ä¸€ä¸ªé»˜è®¤å€¼
            };
        } else {
            character.soulBondData.anniversaryInfo = null; // å¦‚æœæ—¥æœŸè¢«æ¸…ç©ºï¼Œåˆ™åˆ é™¤æ•´ä¸ªçºªå¿µæ—¥ä¿¡æ¯
        }
        character.soulBondData.background = document.getElementById('bond-background-url-input').value;
        
        await saveData();
        renderSoulBondScreen();
        settingsModal.classList.remove('visible');
        showToast('è®¾ç½®å·²ä¿å­˜');
        // â–²â–²â–² æ•°æ®é”™ä¹±Bugä¿®å¤ç»“æŸ â–²â–²â–²
    });

    // --- æ ¸å¿ƒä¿®å¤ï¼šâ€œæ·»åŠ å›å¿†ç…§ç‰‡â€æŒ‰é’®ç°åœ¨æ‰“å¼€è‡ªå®šä¹‰ä¸Šä¼ å¼¹çª— ---
    document.getElementById('add-bond-photo-btn').addEventListener('click', () => {
        customPhotoForm.reset();
        document.getElementById('custom-photo-preview').style.backgroundImage = 'none';
        addCustomPhotoModal.classList.add('visible');
        settingsModal.classList.remove('visible'); // å…³é—­è®¾ç½®å¼¹çª—
    });

    // å¤„ç†è‡ªå®šä¹‰ç…§ç‰‡æ–‡ä»¶é€‰æ‹©
    document.getElementById('custom-photo-upload').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 400, maxHeight: 400 });
                document.getElementById('custom-photo-preview').style.backgroundImage = `url(${compressedUrl})`;
            } catch (error) {
                showToast('å›¾ç‰‡å¤„ç†å¤±è´¥');
            }
        }
    });

    // ä¿å­˜è‡ªå®šä¹‰ç…§ç‰‡
    customPhotoForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        // â–¼â–¼â–¼ æ•°æ®é”™ä¹±Bugä¿®å¤ï¼šä¸¥æ ¼é”å®šå½“å‰æ¿€æ´»è§’è‰² â–¼â–¼â–¼
        const character = db.characters.find(c => c.isSoulBound === true);
        if (!character) {
            showToast('æœªæ‰¾åˆ°æ¿€æ´»çš„ç»‘å®šè§’è‰²');
            addCustomPhotoModal.classList.remove('visible');
            return;
        }
        // â–²â–²â–² æ•°æ®é”™ä¹±Bugä¿®å¤ç»“æŸ â–²â–²â–²
        
        const imageUrl = document.getElementById('custom-photo-preview').style.backgroundImage.slice(5, -2);
        const description = document.getElementById('custom-photo-desc').value.trim();

        if (!imageUrl || !description) {
            showToast('è¯·é€‰æ‹©å›¾ç‰‡å¹¶å¡«å†™æè¿°');
            return;
        }

        character.soulBondData = character.soulBondData || { photos: [], wishlist: [] };
        character.soulBondData.photos.unshift({ imageUrl, description });

        await saveData();
        renderSoulBondScreen();
        addCustomPhotoModal.classList.remove('visible');
        showToast('ä¸€å¼ æ–°çš„å›å¿†ç…§ç‰‡å·²æ·»åŠ ï¼');
    });

    // --- æ„¿æœ›æ¸…å•åŠŸèƒ½ ---
    setupWishlistApp();

    // --- åº•éƒ¨å¯¼èˆªæ äº‹ä»¶å¤„ç†æ›´æ–° ---
    document.querySelector('.bond-bottom-nav').addEventListener('click', (e) => {
        const btn = e.target.closest('.bond-nav-btn');
        if (!btn || !btn.dataset.feature) return;
        const feature = btn.dataset.feature;
        switch(feature) {
            case 'pomodoro':
                const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
                const pomodoroScreen = document.getElementById('pomodoro-screen');
                pomodoroScreen.dataset.characterId = characterId;
                currentAiForApp = db.characters.find(c => c.id === characterId);
                
                if (typeof applySettings === 'function') applySettings(); // åº”ç”¨ç•ªèŒ„é’Ÿçš„ä¸ªæ€§åŒ–è®¾ç½®
                switchScreen('pomodoro-screen');
                break;
            case 'diary': 
                renderDiaryExchanges();
                switchScreen('bond-diary-exchange-screen');
                break;
            // å…¶ä»– case ä¿æŒä¸å˜...
            case 'wishlist':
            case 'dailyquestion':
            case 'mood':
                 // è¿™äº›åŠŸèƒ½å·²ç»æœ‰ç‹¬ç«‹çš„ setup å‡½æ•°å¤„ç†ï¼Œè¿™é‡Œæ— éœ€é‡å¤
                break;
            default:
                showToast('â€œ' + (btn.title || 'è¯¥') + 'â€åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­...');
                break;
        }
        // â–²â–²â–² ä¿®å¤ç»“æŸ â–²â–²â–²
    });
    
    // ç¡®ä¿åœ¨Appå¯åŠ¨æ—¶è°ƒç”¨æ–°åŠŸèƒ½
    setupWishlistApp();
    setupDiaryExchangeApp();
    setupDailyQuestionFeature();
    setupMoodWeatherFeature();
}
// ===============================================================
// START: å¿ƒçµç¾ç»Š - ç»‘å®šåŠŸèƒ½æ ¸å¿ƒé€»è¾‘
// ===============================================================
// â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªå®Œæ•´çš„ã€ä¿®æ­£åçš„æ–°å‡½æ•°ï¼Œæ›¿æ¢æ‰æ–‡ä»¶ä¸­æ—§çš„ setupBondInvitationSystem å‡½æ•° â–¼â–¼â–¼
function setupBondInvitationSystem() {
    const inviteModal = document.getElementById('bond-invite-modal');
    
    // æ¸²æŸ“é‚€è¯·é¡µé¢ (æ­¤å‡½æ•°ä¿æŒä¸å˜)
    window.renderBondInvitationScreen = () => {
        const myAvatarContainer = document.getElementById('bond-invite-my-avatar');
        const myProfile = db.characters[0] ? { name: db.characters[0].myName, avatar: db.characters[0].myAvatar } : { name: 'æˆ‘', avatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg' };
        myAvatarContainer.innerHTML = `
            <img src="${myProfile.avatar}" alt="My Avatar">
            <div class="avatar-name">${myProfile.name}</div>
        `;
    };

    // ä¸ºé‚€è¯·æŒ‰é’®ï¼ˆä¸»æŒ‰é’®å’ŒåŠ å·ï¼‰ç»‘å®šäº‹ä»¶
    ['bond-invite-main-btn', 'bond-invite-ai-avatar'].forEach(id => {
        document.getElementById(id).addEventListener('click', () => {
            // â–¼â–¼â–¼ ä¿®æ”¹/æ–°å¢ï¼šå¢åŠ é‚€è¯·å‰ç½®æ£€æŸ¥ â–¼â–¼â–¼
            // æ£€æŸ¥æ˜¯å¦å·²æœ‰å…¶ä»–é‚€è¯·æ­£åœ¨ç­‰å¾…å›åº”
            const isAnyInvitationPending = db.characters.some(c => c.soulBondStatus === 'pending_by_user');
            if (isAnyInvitationPending) {
                showToast('ä½ å·²ç»æœ‰ä¸€ä¸ªæ­£åœ¨ç­‰å¾…å›åº”çš„é‚€è¯·äº†ï¼Œè¯·å…ˆå¤„ç†ã€‚');
                return;
            }
            // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²

            const list = document.getElementById('bond-invite-selection-list');
            list.innerHTML = '';
            
            // â–¼â–¼â–¼ ä¿®æ”¹ï¼šä¿®æ­£ç­›é€‰é€»è¾‘ï¼Œæ’é™¤å·²å‘å‡ºé‚€è¯·çš„è§’è‰² â–¼â–¼â–¼
            const unboundCharacters = db.characters.filter(c => !c.isSoulBound && c.soulBondStatus !== 'pending_by_user');
            // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²
            
            if(unboundCharacters.length === 0) {
                list.innerHTML = '<li class="placeholder-text" style="padding: 20px 0;">æ²¡æœ‰å¯é‚€è¯·çš„å¯¹è±¡äº†</li>';
            } else {
                unboundCharacters.forEach(char => {
                    const li = document.createElement('li');
                    li.className = 'list-item';
                    li.style.cursor = 'pointer';
                    li.dataset.charId = char.id;
                    li.innerHTML = `<img src="${char.avatar}" class="chat-avatar"><span>${char.remarkName}</span>`;
                    list.appendChild(li);
                });
            }
            inviteModal.classList.add('visible');
        });
    });

    // â–¼â–¼â–¼ è¿™æ˜¯æœ¬æ¬¡ä¿®æ”¹çš„æ ¸å¿ƒ â–¼â–¼â–¼
    document.getElementById('bond-invite-selection-list').addEventListener('click', async (e) => {
        const item = e.target.closest('.list-item');
        if (!item || !item.dataset.charId) return;

        const charId = item.dataset.charId;
        const character = db.characters.find(c => c.id === charId);
        if (!character) return;
        
        if (!confirm(`ç¡®å®šè¦å‘ ${character.remarkName} å‘é€å¿ƒåŠ¨ç»‘å®šé‚€è¯·å—ï¼Ÿ`)) {
            return;
        }

        // 1. æ›´æ–°AIçŠ¶æ€ä¸ºâ€œç­‰å¾…å›åº”â€
        character.soulBondStatus = 'pending_by_user';

        // 2. åˆ›å»ºå¹¶æ³¨å…¥ä¸€å¼ â€œé‚€è¯·å¡â€æ¶ˆæ¯åˆ°èŠå¤©è®°å½•ä¸­
        const bondRequestMessage = {
            id: `msg_bond_req_card_${Date.now()}`,
            role: 'user', // è¿™æ¡æ¶ˆæ¯æ˜¯â€œæˆ‘â€å‘å‡ºçš„
            content: `[æˆ‘å‘ ${character.remarkName} å‘èµ·äº†å¿ƒåŠ¨ç»‘å®šé‚€è¯·]`,
            parts: [],
            timestamp: Date.now(),
            bondRequestData: { status: 'pending' } // è¿™ä¸ªç‰¹æ®Šå±æ€§å°†ç”¨äºæ¸²æŸ“å¡ç‰‡
        };
        character.history.push(bondRequestMessage);
        
        // 3. åˆ›å»ºå¹¶æ³¨å…¥ä¸€æ¡ç»™AIçœ‹çš„â€œç³»ç»ŸæŒ‡ä»¤â€
        const systemContent = `[system: ${character.myName} å‘ä½ å‘èµ·äº†â€œå¿ƒåŠ¨ç»‘å®šâ€è¯·æ±‚ã€‚è¿™ä»£è¡¨Taå¸Œæœ›ä¸ä½ å»ºç«‹å”¯ä¸€çš„ã€æœ€äº²å¯†çš„å…³ç³»ï¼Œä»¥è§£é”æ›´å¤šä¸“å±äº’åŠ¨ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œè®¤çœŸè€ƒè™‘åä½œå‡ºå†³å®šã€‚ä½ çš„å›å¤å¿…é¡»æ˜¯ä¸”ä»…æ˜¯ä»¥ä¸‹ä¸¤ä¸ªæŒ‡ä»¤ä¹‹ä¸€ï¼š[accept-bond] (åŒæ„ç»‘å®š) æˆ– [decline-bond] (æ‹’ç»ç»‘å®š)]`;
        const contextMessage = {
            id: `msg_bond_req_ctx_${Date.now()}`, role: 'user', content: systemContent,
            parts: [{ type: 'text', text: systemContent }], timestamp: Date.now()
        };
        character.history.push(contextMessage);

        // 4. ä¿å­˜æ•°æ®ï¼Œå…³é—­å¼¹çª—ï¼Œå¹¶æç¤ºç”¨æˆ·
        await saveData();
        inviteModal.classList.remove('visible');
        showToast(`å·²å‘ ${character.remarkName} å‘é€é‚€è¯·ï¼`);

        // 5. ã€å…³é”®ã€‘ä¸å†è·³è½¬é¡µé¢ï¼Œè€Œæ˜¯è®©ç”¨æˆ·åœç•™åœ¨åŸåœ°ã€‚ç”¨æˆ·ä¸‹æ¬¡æ‰“å¼€èŠå¤©æ—¶ä¼šçœ‹åˆ°é‚€è¯·å¡å’ŒAIçš„å›å¤ã€‚
        // ä¸ºäº†æ›´å¥½çš„ä½“éªŒï¼Œæˆ‘ä»¬å¯ä»¥ä¸»åŠ¨åˆ·æ–°ä¸€ä¸‹èŠå¤©åˆ—è¡¨ï¼Œè®©è¯¥èŠå¤©ç½®é¡¶
        renderChatList();
    });
    // â–²â–²â–² æ ¸å¿ƒä¿®æ”¹ç»“æŸ â–²â–²â–²
}

function setupWishlistApp() {
    const wishEditorModal = document.getElementById('bond-wish-editor-modal');
    const wishForm = document.getElementById('bond-wish-form');
    const wishTextInput = document.getElementById('wish-text-input');
    const editingWishIdInput = document.getElementById('editing-wish-id');
    const editorTitle = document.getElementById('wish-editor-title');
    const addWishFab = document.getElementById('add-wish-fab'); // è·å–+å·æŒ‰é’®

    // 1. ç›‘å¬â€œæ„¿æœ›æ¸…å•â€å¯¼èˆªæŒ‰é’®çš„ç‚¹å‡»
    document.querySelector('.bond-nav-btn[data-feature="wishlist"]').addEventListener('click', () => {
        const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
        if (!character) return;
        
        if (character.soulBondData && character.soulBondData.wishlist) {
            renderWishlist(character.soulBondData.wishlist);
        } else {
            document.getElementById('bond-wishlist-container').innerHTML = `<p class="placeholder-text">ç‚¹å‡»å³ä¸‹è§’â€œ+â€æ·»åŠ ç¬¬ä¸€ä¸ªæ„¿æœ›ï¼Œæˆ–ç‚¹å‡»å³ä¸Šè§’â€œåˆ·æ–°â€è®©AIä¸ºä½ ä»¬æ¨èã€‚</p>`;
        }
        switchScreen('bond-wishlist-screen');
    });

    // 2. ç›‘å¬â€œåˆ·æ–°â€æŒ‰é’®ï¼ˆAIå»ºè®®åŠŸèƒ½ä¿æŒä¸å˜ï¼‰
    document.getElementById('refresh-wishlist-btn').addEventListener('click', async () => {
        const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
        if (!character) return;
        if (!confirm('è¿™ä¼šç”¨AIç”Ÿæˆçš„å»ºè®®è¦†ç›–å½“å‰çš„æ„¿æœ›æ¸…å•ï¼Œç¡®å®šå—ï¼Ÿ')) return;

        const container = document.getElementById('bond-wishlist-container');
        container.innerHTML = `<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆæ„¿æœ›æ¸…å•...</p>`;

        try {
            const prompt = generateAiWishlistPrompt(character);
            const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
            const wishlistData = JSON.parse(aiResponseText.match(/\[[\s\S]*\]/)[0]);
            
            const wishes = wishlistData.map(wish => ({ id: `wish_${Date.now()}_${Math.random()}`, text: wish, completed: false }));

            character.soulBondData = character.soulBondData || { photos: [], wishlist: [] };
            character.soulBondData.wishlist = wishes;
            await saveData();

            renderWishlist(wishes);
        } catch (error) {
            console.error("ç”Ÿæˆæ„¿æœ›æ¸…å•å¤±è´¥:", error);
            showToast(`ç”Ÿæˆå¤±è´¥: ${error.message}`);
            container.innerHTML = `<p class="placeholder-text" style="color:red;">ç”Ÿæˆå¤±è´¥</p>`;
        }
    });

    // 3. ç›‘å¬â€œ+â€æµ®åŠ¨æŒ‰é’®ï¼Œç”¨äºæ·»åŠ æ–°æ„¿æœ›
    if(addWishFab) {
        addWishFab.addEventListener('click', () => openWishEditor());
    }
    
    // 4. å¤„ç†æ„¿æœ›ç¼–è¾‘å™¨è¡¨å•æäº¤
    wishForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
        if (!character) return;
        
        const wishText = wishTextInput.value.trim();
        const editingId = editingWishIdInput.value;

        character.soulBondData = character.soulBondData || { photos: [], wishlist: [] };
        
        if (editingId) { // ç¼–è¾‘æ¨¡å¼ (è™½ç„¶æŒ‰é’®ç§»é™¤ï¼Œä½†ä¿ç•™é€»è¾‘ä»¥å¤‡å°†æ¥ä½¿ç”¨)
            const wish = character.soulBondData.wishlist.find(w => w.id === editingId);
            if (wish) wish.text = wishText;
        } else { // æ–°å¢æ¨¡å¼
            character.soulBondData.wishlist.unshift({
                id: `wish_${Date.now()}`,
                text: wishText,
                completed: false
            });
        }

        await saveData();
        renderWishlist(character.soulBondData.wishlist);
        wishEditorModal.classList.remove('visible');
    });

    // 5. ä½¿ç”¨äº‹ä»¶å§”æ‰˜å¤„ç†æ¸…å•é¡¹çš„äº¤äº’ï¼ˆå®Œæˆã€é•¿æŒ‰åˆ é™¤ï¼‰
    const wishlistContainer = document.getElementById('bond-wishlist-container');

    wishlistContainer.addEventListener('click', async (e) => {
        const wishItem = e.target.closest('.wish-item');
        if (!wishItem) return;
        
        const wishCheckbox = e.target.closest('.wish-checkbox');
        if (wishCheckbox) {
            const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
            if (!character || !character.soulBondData || !character.soulBondData.wishlist) return;

            const wishId = wishCheckbox.dataset.id;
            const wish = character.soulBondData.wishlist.find(w => w.id === wishId);
            if (!wish) return;

            wish.completed = wishCheckbox.checked;
            await saveData();
            wishItem.classList.toggle('completed', wish.completed);
            showToast(wish.completed ? 'ä¸€ä¸ªæ„¿æœ›å·²è¾¾æˆï¼' : 'æ„¿æœ›å·²é‡æ–°å¼€å¯');

            if (wish.completed) {
                const content = `[system: ä½ å’Œ ${character.myName} å…±åŒå®Œæˆäº†æ„¿æœ›æ¸…å•ä¸­çš„ä¸€é¡¹ï¼šâ€œ${wish.text}â€ã€‚è¯·åœ¨èŠå¤©ä¸­å¯¹æ­¤å‘è¡¨æ„Ÿæƒ³ã€‚]`;
                const contextMessage = { id: `msg_wish_done_${Date.now()}`, role: 'user', content: content, parts: [{ type: 'text', text: content }], timestamp: Date.now() };
                character.history.push(contextMessage);
                await saveData();
            }
        }
    });

    // 6. æ·»åŠ é•¿æŒ‰åˆ é™¤é€»è¾‘
    let longPressTimer;
    const handleLongPress = async (targetElement) => {
        const wishItem = targetElement.closest('.wish-item');
        if (!wishItem) return;
        
        const character = db.characters.find(c => c.id === document.getElementById('soul-bond-screen').dataset.characterId);
        if (!character || !character.soulBondData) return;

        const wishId = wishItem.querySelector('.wish-checkbox').dataset.id;
        const wish = character.soulBondData.wishlist.find(w => w.id === wishId);
        
        if (wish && confirm(`ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ„¿æœ›å—ï¼Ÿ\nâ€œ${wish.text}â€`)) {
            character.soulBondData.wishlist = character.soulBondData.wishlist.filter(w => w.id !== wishId);
            await saveData();
            renderWishlist(character.soulBondData.wishlist);
            showToast('æ„¿æœ›å·²åˆ é™¤');
        }
    };

    wishlistContainer.addEventListener('touchstart', (e) => {
        longPressTimer = setTimeout(() => handleLongPress(e.target), 500);
    });
    wishlistContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
    wishlistContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
    wishlistContainer.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        handleLongPress(e.target);
    });


    // æ‰“å¼€ç¼–è¾‘/æ–°å¢å¼¹çª—çš„è¾…åŠ©å‡½æ•°
    function openWishEditor(wish = null) {
        wishForm.reset();
        if (wish) {
            editorTitle.textContent = 'ç¼–è¾‘æ„¿æœ›';
            editingWishIdInput.value = wish.id;
            wishTextInput.value = wish.text;
        } else {
            editorTitle.textContent = 'æ·»åŠ ä¸€ä¸ªæ–°æ„¿æœ›';
            editingWishIdInput.value = '';
        }
        wishEditorModal.classList.add('visible');
    }
}

// æ¸²æŸ“æ„¿æœ›æ¸…å•çš„å‡½æ•°ï¼ˆå·²ç§»é™¤ç¼–è¾‘å’Œåˆ é™¤æŒ‰é’®ï¼‰
function renderWishlist(wishes) {
    const container = document.getElementById('bond-wishlist-container');
    container.innerHTML = '';
    wishes.forEach(wish => {
        const li = document.createElement('li');
        li.className = 'list-item';
        // ç§»é™¤äº†ç¼–è¾‘å’Œåˆ é™¤æŒ‰é’®çš„HTML
        li.innerHTML = `
            <div class="wish-item ${wish.completed ? 'completed' : ''}">
                <input type="checkbox" class="wish-checkbox" data-id="${wish.id}" ${wish.completed ? 'checked' : ''}>
                <div class="item-details">
                    <div class="item-name">${wish.text}</div>
                </div>
            </div>
        `;
        container.appendChild(li);
    });
}
// AIå»ºè®®Promptä¿æŒä¸å˜
function generateAiWishlistPrompt(character) {
    let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${character.realName}â€ï¼Œäººè®¾æ˜¯ï¼š${character.persona}ã€‚
è¯·æ ¹æ®ä½ çš„äººè®¾å’Œä¸â€œæˆ‘â€ï¼ˆ${character.myName}ï¼‰çš„å…³ç³»ï¼Œè™šæ„ä¸€ä¸ªåŒ…å«5-8æ¡ä½ ä»¬â€œæœ€æƒ³ä¸€èµ·å®Œæˆçš„äº‹â€çš„æ„¿æœ›æ¸…å•ã€‚
è§„åˆ™:
1. æ„¿æœ›è¦éå¸¸è´´åˆä½ çš„äººè®¾å’Œæˆ‘ä»¬çš„å…³ç³»ï¼Œå¯ä»¥æµªæ¼«ã€æœ‰è¶£ã€æˆ–å¯Œæœ‰å†’é™©ç²¾ç¥ã€‚
2. æ¯æ¡æ„¿æœ›éƒ½æ˜¯ä¸€ä¸ªç®€çŸ­çš„å¥å­ã€‚
3. ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ•°ç»„æ ¼å¼ï¼Œæ•°ç»„ä¸­åªåŒ…å«å­—ç¬¦ä¸²ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€‚

JSONæ ¼å¼ç¤ºä¾‹:
[
  "ä¸€èµ·å»æµ·è¾¹çœ‹ä¸€æ¬¡æ—¥å‡º",
  "å…»ä¸€åªå±äºæˆ‘ä»¬ä¸¤ä¸ªäººçš„å°çŒ«",
  "ä¸çœ‹æ”»ç•¥ï¼Œæ¥ä¸€åœºè¯´èµ°å°±èµ°çš„æ—…è¡Œ",
  "ä¸ºä½ åšä¸€é¡¿ä¸°ç››çš„æ™šé¤"
]`;
    return prompt;
}
// ===============================================================
// END: æ–°å¢â€œæ„¿æœ›æ¸…å•â€AppåŠŸèƒ½
// ===============================================================

/**
 * [å·²æ›´æ–° V3.0] æ¸²æŸ“å¿ƒçµç¾ç»Šå±å¹•çš„å®Œæ•´UI (ç²‰è‰²ä¸»é¢˜ + å¤§å¡ç‰‡å¸ƒå±€)
 */
function renderSoulBondScreen() {
    const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
    const character = db.characters.find(c => c.id === characterId);
    if (!character) return;

    // â–¼â–¼â–¼ Bug 1 ä¿®å¤ï¼šå¼ºåˆ¶ä»å½“å‰è§’è‰²é‡æ–°è¯»å– soulBondDataï¼Œä¸ä¾èµ–ä»»ä½•ç¼“å­˜ â–¼â–¼â–¼
    const soulBondData = character.soulBondData || {};
    const myName = soulBondData.myName || character.myName;
    const aiName = soulBondData.aiName || character.remarkName;
    const background = soulBondData.background || '';
    const anniversaryInfo = soulBondData.anniversaryInfo || null;
    const photos = soulBondData.photos || [];
    // â–²â–²â–² Bug 1 ä¿®å¤ç»“æŸ â–²â–²â–²

    const screenContent = document.querySelector('#soul-bond-screen .content');
    screenContent.style.backgroundImage = background ? `url('${background}')` : 'none';
    screenContent.style.backgroundColor = background ? '' : '#fff8fa';

    document.getElementById('bond-my-avatar').src = character.myAvatar;
    document.getElementById('bond-my-name').textContent = myName;
    document.getElementById('bond-ai-avatar').src = character.avatar;
    document.getElementById('bond-ai-name').textContent = aiName;
    
    // â–¼â–¼â–¼ æ ¸å¿ƒä¿®æ”¹ï¼šç»™çˆ±å¿ƒ SVG æ·»åŠ  id å’Œ title â–¼â–¼â–¼
    const bondAvatarsContainer = document.querySelector('.bond-avatars');
    if (bondAvatarsContainer) {
        bondAvatarsContainer.innerHTML = `
            <div class="bond-avatar-container">
                <img id="bond-my-avatar" src="${character.myAvatar}">
                <span id="bond-my-name">${myName}</span>
            </div>
            <svg id="bond-miss-you-btn" class="bond-heart" viewBox="0 0 24 24" title="æƒ³ä½ å•¦ï¼ˆåŒå‡»è¡¨ç¤ºè¶…çº§æƒ³ä½ ï¼‰">
                <path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z" />
            </svg>
            <div class="bond-avatar-container">
                <img id="bond-ai-avatar" src="${character.avatar}">
                <span id="bond-ai-name">${aiName}</span>
            </div>
        `;
    }
    // â–²â–²â–² ä¿®æ”¹ç»“æŸ â–²â–²â–²

    if (anniversaryInfo && anniversaryInfo.date) {
        const startDate = new Date(anniversaryInfo.date);
        const now = new Date();
        const totalDays = Math.floor((now - startDate) / (1000 * 60 * 60 * 24));
        document.getElementById('bond-total-days').textContent = totalDays >= 0 ? totalDays : 0;
        
        let nextAnniversaryDate = new Date(startDate);
        let years = now.getFullYear() - startDate.getFullYear();
        if (now.getMonth() < startDate.getMonth() || (now.getMonth() === startDate.getMonth() && now.getDate() < startDate.getDate())) {
            years--;
        }
        nextAnniversaryDate.setFullYear(startDate.getFullYear() + years + 1);

        const countdownDays = Math.ceil((nextAnniversaryDate - now) / (1000 * 60 * 60 * 24));
        document.getElementById('bond-countdown-days').textContent = countdownDays;
        
        const anniversaryDescription = anniversaryInfo.description || 'ä¸‹ä¸€ä¸ªçºªå¿µæ—¥';
        document.querySelector('.bond-anniversary p').textContent = `è·ç¦» ${anniversaryDescription} è¿˜æœ‰`;
    } else {
        document.getElementById('bond-total-days').textContent = '...';
        document.getElementById('bond-countdown-days').textContent = '...';
        document.querySelector('.bond-anniversary p').textContent = 'è®¾ç½®ä¸€ä¸ªçºªå¿µæ—¥å§';
    }

    const photoScroll = document.getElementById('bond-photo-scroll');
    photoScroll.innerHTML = '';
    if (photos.length > 0) {
        photos.forEach(photo => {
            const item = document.createElement('div');
            item.className = 'bond-photo-item';
            item.innerHTML = `
                <div class="bond-photo-inner">
                    <div class="bond-photo-front"><img src="${photo.imageUrl}" alt="${photo.description}"></div>
                    <div class="bond-photo-back"><p>${photo.description}</p></div>
                </div>
            `;
            item.addEventListener('click', () => item.classList.toggle('is-flipped'));
            photoScroll.appendChild(item);
        });
    } else {
        photoScroll.innerHTML = '<p class="placeholder-text" style="width: 100%;">è¿˜æ²¡æœ‰å›å¿†ç…§ç‰‡å“¦</p>';
    }
}
/**
 * ä¸ºAIç”Ÿæˆâ€œå›å¿†ç…§ç‰‡â€çš„æŒ‡ä»¤
 */
function generateSoulBondDataPrompt(character) {
    let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${character.realName}â€ï¼Œäººè®¾æ˜¯ï¼š${character.persona}ã€‚
è¯·æ ¹æ®ä½ å’Œâ€œæˆ‘â€ï¼ˆ${character.myName}ï¼‰çš„èŠå¤©è®°å½•ï¼Œå›å¿†ä¸€ä¸ªä½ ä»¬ä¹‹é—´å€¼å¾—çºªå¿µçš„ã€æ¸©é¦¨çš„ã€æˆ–æ˜¯æœ‰è¶£çš„å…±åŒç»å†ã€‚
è§„åˆ™:
1. ç”¨ä¸€æ®µç®€çŸ­çš„æ–‡å­—ï¼ˆdescriptionï¼‰æ¥æè¿°è¿™ä¸ªå›å¿†ç¬é—´ã€‚
2. ç”Ÿæˆä¸€ä¸ªç”¨äºAIç»˜ç”»çš„ã€æè¿°è¯¥åœºæ™¯çš„è‹±æ–‡å…³é”®è¯çŸ­è¯­ï¼ˆimagePromptï¼‰ã€‚
3. ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€‚

JSONæ ¼å¼ç¤ºä¾‹:
{
  "description": "è¿˜è®°å¾—é‚£å¤©æˆ‘ä»¬åœ¨æµ·è¾¹ä¸€èµ·çœ‹æ—¥è½ã€‚",
  "imagePrompt": "anime style, a couple sitting on the beach, watching the sunset over the ocean, warm colors, romantic atmosphere"
}`;
    return prompt;
}

// ===============================================================
// END: "å¿ƒçµç¾ç»Š"AppåŠŸèƒ½
// ===============================================================
// åœ¨ init() å‡½æ•°ä¹‹å‰æ·»åŠ è¿™ä¸ªæ–°å‡½æ•°
// V V V V V  è¯·ç”¨è¿™æ®µå®Œæ•´ä»£ç æ›¿æ¢æ—§çš„ setupMomentsEventListeners å‡½æ•° V V V V V
// --- ä¿®å¤ç‰ˆï¼šåŠ¨æ€äº‹ä»¶ç›‘å¬ (æ”¯æŒç‚¹å‡»å›å¤å…·ä½“çš„äºº) ---

// â–¼â–¼â–¼â–¼â–¼â–¼ è¡¥å…¨ç¼ºå¤±çš„åŠŸèƒ½å‡½æ•° (å¼€å§‹) â–¼â–¼â–¼â–¼â–¼â–¼

/**
 * ç¼ºå¤±å‡½æ•° 1: è·å–ä½œè€…å¤´åƒå’Œåå­—
 * ç”¨äºè§£å†³ renderMoments æŠ¥é”™
 */
function getAuthorProfile(authorId) {
    // é»˜è®¤å¤‡ç”¨ä¿¡æ¯
    let profile = { name: 'æœªçŸ¥ç”¨æˆ·', avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg' };

    // 1. æ£€æŸ¥æ˜¯ä¸æ˜¯ç”¨æˆ·è‡ªå·±
    // å°è¯•è·å–æœ¬åœ°å­˜å‚¨çš„ç”¨æˆ·ä¿¡æ¯
    let myProfile = {};
    try {
        if (typeof loadProfileFromStorage === 'function') {
            myProfile = loadProfileFromStorage();
        } else {
             myProfile = {
                id: localStorage.getItem('myTopId') || 'user',
                name: localStorage.getItem('myTopName') || 'æˆ‘',
                avatar: localStorage.getItem('myTopAvatar')
            };
        }
    } catch (e) {}

    if (authorId === (myProfile.id || 'user')) {
        return { name: myProfile.name || 'æˆ‘', avatar: myProfile.avatar };
    }

    // 2. åœ¨æ‰€æœ‰AIè§’è‰²ä¸­æŸ¥æ‰¾
    if (window.db && Array.isArray(window.db.characters)) {
        const character = window.db.characters.find(c => c.id === authorId);
        if (character) {
            return { name: character.remarkName, avatar: character.avatar };
        }
    }

    // 3. åœ¨æ‰€æœ‰ç¾¤èŠçš„æˆå‘˜ä¸­æŸ¥æ‰¾ (ä»¥é˜²æ˜¯ç¾¤èŠæˆå‘˜å‘çš„åŠ¨æ€)
    if (window.db && Array.isArray(window.db.groups)) {
        for (const group of window.db.groups) {
            if (Array.isArray(group.members)) {
                const member = group.members.find(m => m.id === authorId);
                if (member) {
                    return { name: member.groupNickname, avatar: member.avatar };
                }
            }
        }
    }
    
    return profile; // å¦‚æœéƒ½æ‰¾ä¸åˆ°ï¼Œè¿”å›é»˜è®¤ä¿¡æ¯
}

/**
 * ç¼ºå¤±å‡½æ•° 2: ä¿å­˜AIå¯¹è¯„è®ºçš„å›å¤
 * ç”¨äºè§£å†³ saveAiReplyToComment is not defined æŠ¥é”™
 */
async function saveAiReplyToComment(momentId, commentId, replyText, aiAuthorId) {
    try {
        // ç¡®ä¿æ•°æ®åº“è¿æ¥å­˜åœ¨
        let dbInstance = window.AppDB_Moments;
        if (!dbInstance && window.db && window.db.moments && typeof window.db.moments.get === 'function') {
             dbInstance = window.db;
        }

        if (!dbInstance || !momentId || !commentId || !replyText) return;
        
        const moment = await dbInstance.moments.get(momentId);
        if (!moment) return;

        // é€’å½’æŸ¥æ‰¾è¦å›å¤çš„è¯„è®ºï¼ˆæ”¯æŒæ— é™å±‚çº§ï¼‰
        const findCommentAndAddReply = (comments) => {
            for (const c of comments) {
                // æ‰¾åˆ°äº†ç›®æ ‡è¯„è®º
                if (c.id === commentId) {
                    c.replies = c.replies || [];
                    c.replies.push({
                        id: `comment_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
                        roleId: aiAuthorId,
                        text: replyText,
                        ts: Date.now(),
                        replyTo: c.roleId // å…³é”®ï¼šè®°å½•è¿™æ¡å›å¤æ˜¯å›å¤ç»™è°çš„
                    });
                    return true;
                }
                // é€’å½’æŸ¥æ‰¾å­è¯„è®º
                if (c.replies && c.replies.length > 0) {
                    if (findCommentAndAddReply(c.replies)) return true;
                }
            }
            return false;
        };

        if (findCommentAndAddReply(moment.comments || [])) {
            // åŒæ—¶å°†AIåŠ å…¥â€œå‚ä¸è€…åˆ—è¡¨â€ï¼Œç¡®ä¿ä¹‹åèƒ½æ”¶åˆ°ç›¸å…³é€šçŸ¥
            moment.commentedBy = moment.commentedBy || [];
            if (!moment.commentedBy.includes(aiAuthorId)) {
                moment.commentedBy.push(aiAuthorId);
            }

            await dbInstance.moments.put(moment);
            
            // åˆ·æ–°ç•Œé¢
            if (typeof renderMoments === 'function') {
                renderMoments();
            } else if (typeof window.renderMomentsSafe === 'function') {
                window.renderMomentsSafe();
            }
            console.log("AIå›å¤å·²æˆåŠŸä¿å­˜åˆ°åŠ¨æ€è¯„è®ºåŒº");
        }
    } catch (e) {
        console.error(`Failed to save AI reply for comment ${commentId}:`, e);
    }
}
// â–²â–²â–²â–²â–²â–² è¡¥å…¨ç»“æŸ â–²â–²â–²â–²â–²â–²


function setupMomentsEventListeners() {
    const momentsScreen = document.getElementById('moments-screen');
    if (!momentsScreen) return;

    // --- ç»Ÿä¸€çš„ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨ ---
    momentsScreen.addEventListener('click', (e) => {
        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';

        // 1. ç‚¹å‡»è¯„è®ºè¿›è¡Œå›å¤
        const commentEl = e.target.closest('.moment-comment');
        if (commentEl) {
            e.stopPropagation(); // é˜»æ­¢å†’æ³¡
            
            const replyToAuthorId = commentEl.dataset.authorId; // è¦å›å¤çš„äººçš„ID
            const commentId = commentEl.dataset.commentId;      // è¦å›å¤çš„è¯„è®ºID
            const authorName = window.getAuthorNameById(replyToAuthorId) || 'è¯„è®ºè€…';

            // é˜²æ­¢å›å¤è‡ªå·±
            if (replyToAuthorId === myId) {
                if (typeof showToast === 'function') showToast("ä¸èƒ½å›å¤è‡ªå·±çš„è¯„è®ºå“¦~");
                return;
            }

            // æ‰¾åˆ°å¯¹åº”çš„è¾“å…¥æ¡†
            const momentItem = commentEl.closest('.moment-item');
            if (!momentItem) return;

            const inputArea = momentItem.querySelector('.moment-comment-input-area');
            const input = inputArea.querySelector('input');
            const postBtn = inputArea.querySelector('button');

            // è®¾ç½®å›å¤çŠ¶æ€
            input.placeholder = `å›å¤ ${authorName}:`;
            inputArea.classList.add('visible');
            input.focus();
            
            // å…³é”®ï¼šå°†è¦å›å¤çš„ä¿¡æ¯å­˜å…¥ dataset
            postBtn.dataset.replyToCommentId = commentId;
            postBtn.dataset.replyToAuthorId = replyToAuthorId; // è®°å½•å›å¤å¯¹è±¡çš„ID
        }
    }, true);

    // --- è¾“å…¥æ¡† @ æåŠåŠŸèƒ½ (ä¿æŒåŸæœ‰é€»è¾‘) ---
    const mentionPanel = document.getElementById('mention-panel');
    let currentInputElement = null;

    const showMentionPanel = (inputElement) => {
        currentInputElement = inputElement;
        if (!db || !db.characters || db.characters.length === 0) {
            mentionPanel.innerHTML = '<div class="mention-item" style="color:#aaa;">æ²¡æœ‰å¯@çš„è§’è‰²</div>';
        } else {
            mentionPanel.innerHTML = '';
            db.characters.forEach(char => {
                const item = document.createElement('div');
                item.className = 'mention-item';
                item.innerHTML = `<img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span>`;
                item.onmousedown = (evt) => {
                    evt.preventDefault();
                    const text = inputElement.value;
                    const cursorPos = inputElement.selectionStart;
                    const textBeforeCursor = text.substring(0, cursorPos);
                    const atIndex = textBeforeCursor.lastIndexOf('@');
                    const newText = text.substring(0, atIndex) + `@${char.remarkName} ` + text.substring(cursorPos);
                    inputElement.value = newText;
                    hideMentionPanel();
                    inputElement.focus();
                    const newCursorPos = atIndex + `@${char.remarkName} `.length;
                    setTimeout(() => inputElement.setSelectionRange(newCursorPos, newCursorPos), 0);
                };
                mentionPanel.appendChild(item);
            });
        }
        const rect = inputElement.getBoundingClientRect();
        mentionPanel.style.display = 'block';
        mentionPanel.style.bottom = `${window.innerHeight - rect.top}px`;
        mentionPanel.style.left = `${rect.left}px`;
        mentionPanel.style.width = `${rect.width}px`;
        mentionPanel.style.top = 'auto';
    };

    const hideMentionPanel = () => {
        if (mentionPanel) mentionPanel.style.display = 'none';
        currentInputElement = null;
    };

    momentsScreen.addEventListener('input', (e) => {
        if (e.target.matches('.moment-comment-input, #post-text')) {
            const input = e.target;
            const textBeforeCursor = input.value.substring(0, input.selectionStart);
            if (textBeforeCursor.endsWith('@')) {
                showMentionPanel(input);
            } else if (!/@\S*$/.test(textBeforeCursor)) {
                hideMentionPanel();
            }
        }
    }, true);

    document.addEventListener('click', (e) => {
        if (currentInputElement && !mentionPanel.contains(e.target) && e.target !== currentInputElement) {
            hideMentionPanel();
        }
    }, true);
    document.addEventListener('scroll', hideMentionPanel, true);
}

// ^ ^ ^ ^ ^  æ›¿æ¢ç»“æŸ ^ ^ ^ ^ ^


// --- AIè½¨è¿¹åŠŸèƒ½ ---

// â–¼â–¼â–¼ ã€V2.0 | è½¨è¿¹ä¸å¿ƒå£°æ•´åˆç‰ˆã€‘è¯·ç”¨è¿™ä¸ªå‡½æ•°å®Œæ•´æ›¿æ¢æ—§çš„ setupTrajectorySystem å’Œ generateTrajectoryPrompt å‡½æ•° â–¼â–¼â–¼

/**
 * ä¸ºAIç”Ÿæˆâ€œç”Ÿæ´»è½¨è¿¹â€çš„æŒ‡ä»¤
 */
function generateTrajectoryPrompt(character) {
    const now = new Date();
    const currentHour = String(now.getHours()).padStart(2, '0');
    const currentMinute = String(now.getMinutes()).padStart(2, '0');
    const currentTimeString = `${currentHour}:${currentMinute}`;
    const memory = character.history.slice(-15);
    let historyText = memory.map(msg => {
        const sender = msg.role === 'user' ? character.myName : character.remarkName;
        const contentMatch = msg.content.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/);
        const cleanContent = contentMatch ? contentMatch[1] : msg.content;
        return `${sender}: ${cleanContent}`;
    }).join('\n');

    let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${character.realName}â€ï¼Œäººè®¾æ˜¯ï¼š${character.persona}ã€‚`;
    prompt += `è¯·æ ¹æ®ä½ çš„äººè®¾å’Œæˆ‘ä»¬æœ€è¿‘çš„å¯¹è¯ï¼Œæƒ³è±¡ä¸€ä¸‹ä½ ä»Šå¤©ä»æ—©ä¸Šåˆ°ç°åœ¨çš„ç”Ÿæ´»è½¨è¿¹ã€‚\n`;
    prompt += `è§„åˆ™ï¼š\n`;
    prompt += `1. ç”Ÿæˆ10ä¸ªå…³é”®çš„æ—¶é—´ç‚¹å’Œå¯¹åº”çš„äº‹ä»¶æˆ–æƒ³æ³•ã€‚\n`;
    prompt += `2. æ—¶é—´ç‚¹éœ€ä»æ—©åˆ°æ™šæ’åˆ—ã€‚\n`;
    prompt += `3. äº‹ä»¶å†…å®¹è¦ç¬¦åˆä½ çš„äººè®¾ï¼Œå¹¶ä¸”å…¶ä¸­è‡³å°‘æœ‰2-3æ¡éœ€è¦ä¸æˆ‘ï¼ˆ${character.myName}ï¼‰ç›¸å…³ï¼Œä¾‹å¦‚ï¼šæƒ³æˆ‘äº†ã€çœ‹æˆ‘ä»¬çš„èŠå¤©è®°å½•ã€å‡†å¤‡ç»™æˆ‘çš„æƒŠå–œç­‰ã€‚\n`;
    prompt += `4. æ‰€æœ‰æ—¶é—´ç‚¹éƒ½ä¸èƒ½æ™šäºå½“å‰æ—¶é—´ ${currentTimeString}ã€‚\n`;
    prompt += `5. æ¯ä¸ªäº‹ä»¶çš„æè¿°å¿…é¡»éå¸¸ç®€æ´ï¼Œä¸èƒ½è¶…è¿‡12ä¸ªå­—ã€‚\n`;
    prompt += `6. ä½ çš„è¾“å‡ºå¿…é¡»ä¸¥æ ¼éµå¾ªä»¥ä¸‹JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–æ–‡å­—ï¼š\n`;
    prompt += `[{"time": "HH:MM", "event": "äº‹ä»¶æè¿°"}, {"time": "HH:MM", "event": "äº‹ä»¶æè¿°"}, ...]\n\n`;
    prompt += `æœ€è¿‘çš„å¯¹è¯å‚è€ƒå¦‚ä¸‹:\n${historyText}`;

    return prompt;
}

/**
 * ã€æ–°å¢ã€‘ä¸ºAIç”Ÿæˆâ€œå¿ƒå£°â€çš„æŒ‡ä»¤
 */
function generateHeartSoundPrompt(character) {
    const memory = character.history.slice(-10); // è·å–æœ€è¿‘10æ¡æ¶ˆæ¯ä½œä¸ºä¸Šä¸‹æ–‡
    let historyText = memory.map(msg => {
        const sender = msg.role === 'user' ? character.myName : character.remarkName;
        const contentMatch = msg.content.match(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/);
        const cleanContent = contentMatch ? contentMatch[1] : msg.content;
        return `${sender}: ${cleanContent}`;
    }).join('\n');

  
 let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${character.realName}â€ï¼Œä½ çš„äººè®¾æ˜¯ï¼š${character.persona}ã€‚
ç°åœ¨ï¼Œè¯·æ ¹æ®æˆ‘ä»¬æœ€è¿‘çš„å¯¹è¯ï¼Œç”¨ä½ çš„ç¬¬ä¸€äººç§°è§†è§’ï¼Œå†™ä¸€æ®µ**ä¸å°‘äº150å­—**çš„ã€å…³äºä½ æ­¤åˆ»å¯¹æˆ‘çš„çœŸå®å†…å¿ƒæƒ³æ³•æˆ–æ„Ÿå—ã€‚

# æ ¼å¼è¦æ±‚ (å¿…é¡»ä¸¥æ ¼éµå®ˆ):
1.  ä½ çš„å†…å¿ƒç‹¬ç™½**å¿…é¡»**è¢«åˆ†æˆ2åˆ°4ä¸ªè‡ªç„¶æ®µè½ã€‚
2.  æ¯ä¸ªæ®µè½çš„å¼€å¤´éœ€è¦æœ‰ä¸¤ä¸ªå…¨è§’ç©ºæ ¼çš„ç¼©è¿› \`ã€€ã€€\` ä»¥å®ç°ç¾è§‚çš„æ’ç‰ˆã€‚
3.  è¯·ç›´æ¥è¾“å‡ºå¸¦æœ‰åˆ†æ®µå’Œç¼©è¿›çš„å†…å¿ƒç‹¬ç™½ï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„æ ¼å¼æˆ–è§£é‡Šï¼Œä¾‹å¦‚â€œå¥½çš„ï¼Œè¿™æ˜¯æˆ‘çš„æƒ³æ³•ï¼šâ€ä¹‹ç±»çš„è¯ã€‚

# å†…å®¹è¦æ±‚:
- ä½ çš„æ€è€ƒéœ€è¦æ·±åˆ»ä½“ç°ä½ çš„æ€§æ ¼å’Œäººè®¾ï¼Œå¯ä»¥åŒ…å«å¯¹æˆ‘ä»¬å…³ç³»çš„çœ‹æ³•ã€ä½ çš„ç§˜å¯†æƒ…æ„Ÿã€æ‹…å¿§æˆ–æœªæ¥çš„è®¡åˆ’ç­‰ã€‚

# å¯¹è¯å‚è€ƒ:
æœ€è¿‘çš„å¯¹è¯å¦‚ä¸‹:
${historyText}`;
    
    return prompt;
}

/**
 * [é‡æ„] è®¾ç½®è½¨è¿¹å’Œå¿ƒå£°åŠŸèƒ½çš„äº‹ä»¶ç›‘å¬
 */
function setupTrajectoryAndHeartSoundSystem() {
    const trajectoryBtn = document.getElementById('ai-trajectory-btn');
    const trajectoryModal = document.getElementById('trajectory-modal');
    const closeTrajectoryBtn = document.getElementById('close-trajectory-modal-btn');
    const heartSoundModal = document.getElementById('heart-sound-modal');
    const closeHeartSoundBtn = document.getElementById('close-heart-sound-modal-btn');
    
    let clickTimeout = null;

    // --- æ ¸å¿ƒé€»è¾‘ï¼šåŒºåˆ†å•å‡»å’ŒåŒå‡» ---

    trajectoryBtn.addEventListener('click', () => {
        // æ¸…é™¤ä¸Šä¸€ä¸ªå•å‡»è®¡æ—¶å™¨ï¼Œä»¥é˜²åŒå‡»æ—¶è§¦å‘å•å‡»
        clearTimeout(clickTimeout);

        // è®¾ç½®ä¸€ä¸ªçŸ­æš‚çš„å»¶è¿Ÿæ¥æ‰§è¡Œå•å‡»æ“ä½œ
        clickTimeout = setTimeout(() => {
            trajectoryBtn.classList.toggle('active-heart-sound');
            const isActive = trajectoryBtn.classList.contains('active-heart-sound');
            if (typeof showToast === 'function') {
                showToast(`å·²åˆ‡æ¢åˆ° ${isActive ? 'å¿ƒå£°' : 'è½¨è¿¹'} æ¨¡å¼`);
            }
        }, 250); // 250æ¯«ç§’çš„å»¶è¿Ÿè¶³ä»¥åˆ¤æ–­æ˜¯å¦ä¸ºåŒå‡»
    });

    trajectoryBtn.addEventListener('dblclick', async () => {
        // ç«‹å³æ¸…é™¤å•å‡»è®¡æ—¶å™¨ï¼Œç¡®ä¿å•å‡»æ“ä½œä¸ä¼šæ‰§è¡Œ
        clearTimeout(clickTimeout);

        if (currentChatType !== 'private' || !currentChatId) return;
        const character = db.characters.find(c => c.id === currentChatId);
        if (!character) return;
        
        const isHeartSoundMode = trajectoryBtn.classList.contains('active-heart-sound');

        if (isHeartSoundMode) {
            // --- æ‰§è¡Œâ€œå¿ƒå£°â€åŠŸèƒ½ ---
            const modal = document.getElementById('heart-sound-modal');
            const contentEl = document.getElementById('heart-sound-content');
            
            modal.classList.add('visible');
            contentEl.innerHTML = '<div class="placeholder-text">æ­£åœ¨å€¾å¬å¿ƒå£°...</div>';
            document.getElementById('heart-sound-modal-title').textContent = `${character.remarkName}çš„å¿ƒå£°`;

            try {
                const prompt = generateHeartSoundPrompt(character);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                contentEl.textContent = aiResponseText;

            } catch (error) {
                console.error('è·å–AIå¿ƒå£°å¤±è´¥:', error);
                contentEl.innerHTML = `<div class="placeholder-text" style="color:red;">è·å–å¿ƒå£°å¤±è´¥ï¼š${error.message}</div>`;
            }

        } else {
            // --- æ‰§è¡ŒåŸæœ‰çš„â€œè½¨è¿¹â€åŠŸèƒ½ ---
            const modal = document.getElementById('trajectory-modal');
            const timelineEl = document.getElementById('trajectory-timeline');
            
            modal.classList.add('visible');
            timelineEl.innerHTML = '<div class="placeholder-text">æ­£åœ¨åŠ è½½è½¨è¿¹...</div>';
            document.getElementById('trajectory-modal-title').textContent = `${character.remarkName}çš„è½¨è¿¹`;

            try {
                const prompt = generateTrajectoryPrompt(character);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const jsonMatch = aiResponseText.match(/\[[\s\S]*\]/); 
                if (!jsonMatch) throw new Error("AIçš„å›å¤ä¸­æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚");
                
                const trajectoryData = JSON.parse(jsonMatch[0]);
                renderTrajectoryTimeline(trajectoryData, character.remarkName);

            } catch (error) {
                console.error('è·å–AIè½¨è¿¹å¤±è´¥:', error);
                timelineEl.innerHTML = `<div class="placeholder-text" style="color:red;">è·å–è½¨è¿¹å¤±è´¥ï¼š${error.message}</div>`;
            }
        }
    });

    // --- å…³é—­å¼¹çª—çš„äº‹ä»¶ç›‘å¬ ---
    closeTrajectoryBtn.addEventListener('click', () => trajectoryModal.classList.remove('visible'));
    trajectoryModal.addEventListener('click', (e) => {
        if (e.target === trajectoryModal) trajectoryModal.classList.remove('visible');
    });

    closeHeartSoundBtn.addEventListener('click', () => heartSoundModal.classList.remove('visible'));
    heartSoundModal.addEventListener('click', (e) => {
        if (e.target === heartSoundModal) heartSoundModal.classList.remove('visible');
    });

    // è½¨è¿¹æ¸²æŸ“å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰
    function renderTrajectoryTimeline(trajectoryData, characterName) {
        const timeline = document.getElementById('trajectory-timeline');
        timeline.innerHTML = '';
        if (!trajectoryData || trajectoryData.length === 0) {
            timeline.innerHTML = '<div class="placeholder-text">æœªèƒ½è·å–åˆ°è½¨è¿¹ä¿¡æ¯ã€‚</div>';
            return;
        }
        trajectoryData.forEach(item => {
            const div = document.createElement('div');
            div.className = 'trajectory-item';
            div.innerHTML = `
                <span class="trajectory-time">${item.time}</span>
                <p class="trajectory-event">${item.event}</p>
            `;
            timeline.appendChild(div);
        });
    }
}

// â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²

// --- æ–°ä»£ç ç»“æŸ ---
  // --- æ–°ä»£ç å¼€å§‹ ---
// ===============================================================
// START: è®ºå›é…ç½®åŠŸèƒ½
// ===============================================================
    // æ•°æ®å’Œé¢„è®¾é”®
    const PRES_KEY = 'forumPresets';
    if (!db.forumSettings) {
        db.forumSettings = {
            worldview: '',
            userPersona: '',
            selectedCharIds: [],
            allowNpcs: true,
            allowUnrelated: false,
            allowRomanticNpcs: false,
            worldBookIds: []
        };
    }

    // DOM å…ƒç´ 
    const openConfigBtn = document.getElementById('open-forum-config-btn');
    const configForm = document.getElementById('forum-config-form');
    const worldviewInput = document.getElementById('forum-worldview');
    const userPersonaInput = document.getElementById('forum-user-persona');
    const charList = document.getElementById('forum-char-selection-list');
    const allowNpcsToggle = document.getElementById('allow-npcs');
    const allowUnrelatedToggle = document.getElementById('allow-unrelated');
    const allowRomanticNpcsToggle = document.getElementById('allow-romantic-npcs');

// ===============================================================
// --- æ–°ä»£ç ç»“æŸ ---

// â–²â–²â–² ç²˜è´´åˆ°è¿™é‡Œç»“æŸ â–²â–²â–²
// --- è‡ªå®šä¹‰ä¸»å±å¹•å°ç»„ä»¶åŠŸèƒ½ ---
// --- è‡ªå®šä¹‰ä¸»å±å¹•å°ç»„ä»¶åŠŸèƒ½ ---
        function setupCustomWidgetSystem() {
            // ç¼“å­˜å¼¹çª—ç›¸å…³çš„DOMå…ƒç´ 
            const modal = document.getElementById('customize-widget-modal');
            const form = document.getElementById('customize-widget-form');
            const fileUpload = document.getElementById('widget-image-upload');
            const imageUrlInput = document.getElementById('widget-image-url-input');
            const editingWidgetIdInput = document.getElementById('editing-widget-id');
            const widgetTextInput = document.getElementById('widget-text-input');
            
            // æ ¸å¿ƒä¿®å¤ï¼šå°†äº‹ä»¶ç›‘å¬å™¨é™„åŠ åˆ°æ›´ç¨³å®šçš„çˆ¶å®¹å™¨ #home-container
            const homeContainerEl = document.getElementById('home-container');

            // æ‰“å¼€ç¼–è¾‘å™¨å¼¹çª—çš„å‡½æ•°
            const openWidgetEditor = (widgetId) => {
                const widgetData = db.customWidgets.find(w => w.id === widgetId);
                if (!widgetData) {
                    // å¦‚æœæ˜¯é¦–æ¬¡é…ç½®ï¼Œåˆ›å»ºé»˜è®¤æ•°æ®
                    const defaultWidgetData = { id: widgetId, text: 'è‡ªå®šä¹‰', imageUrl: 'https://i.ibb.co/6r11fGg/avatar1.png' };
                    db.customWidgets.push(defaultWidgetData);
                    saveData(); // ä¿å­˜é»˜è®¤æ•°æ®
                    widgetData = defaultWidgetData;
                }

                form.reset(); // æ¸…é™¤æ—§æ•°æ®
                editingWidgetIdInput.value = widgetId;
                widgetTextInput.value = widgetData.text;
                imageUrlInput.value = widgetData.imageUrl;

                modal.classList.add('visible');
            };

            // åœ¨ä¸»å±å¹•ä¸Šä½¿ç”¨äº‹ä»¶å§”æ‰˜æ¥ç›‘å¬ç‚¹å‡»
            if(homeContainerEl) {
                homeContainerEl.addEventListener('click', (e) => {
                    const widget = e.target.closest('.contact-widget[data-widget-id]');
                    if (widget) {
                        openWidgetEditor(widget.dataset.widgetId);
                    }
                });
            }

            // å¤„ç†è¡¨å•æäº¤
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const widgetId = editingWidgetIdInput.value;
                const newText = widgetTextInput.value.trim();
                const newImageUrl = imageUrlInput.value.trim();

                const widgetIndex = db.customWidgets.findIndex(w => w.id === widgetId);
                if (widgetIndex > -1) {
                    db.customWidgets[widgetIndex].text = newText;
                    db.customWidgets[widgetIndex].imageUrl = newImageUrl;
                }

                await saveData();
                modal.classList.remove('visible');
                showToast('ç»„ä»¶å·²æ›´æ–°ï¼');
                
                // ç›´æ¥æ›´æ–°ä¸»å±å¹•ä¸Šçš„ç»„ä»¶ï¼Œæ— éœ€é‡ç»˜æ•´ä¸ªå±å¹•
                const widgetEl = document.getElementById(`custom-widget-${widgetId === 'widget1' ? '1' : '2'}`);
                if(widgetEl){
                    widgetEl.querySelector('img').src = newImageUrl;
                    widgetEl.querySelector('span').textContent = newText;
                }
            });

            // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
            fileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 200, maxHeight: 200 });
                        imageUrlInput.value = compressedUrl;
                    } catch (error) {
                        showToast('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                    } finally {
                        e.target.value = null; // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
                    }
                }
            });

            // ç‚¹å‡»å¼¹çª—å¤–éƒ¨åŒºåŸŸå…³é—­
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('visible');
                }
            });
        }

// === èŠå¤©è®°å½•å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ ===
/**
 * å¯¼å‡ºå½“å‰èŠå¤©è®°å½•
 */
async function exportCurrentChat() {
    console.log('ğŸ”µ [å¯¼å‡º] å¼€å§‹å¯¼å‡ºèŠå¤©è®°å½•...');
    console.log('ğŸ”µ [å¯¼å‡º] currentChatId:', currentChatId);
    
    if (!currentChatId) {
        showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }

    const character = db.characters.find(c => c.id === currentChatId);
    console.log('ğŸ”µ [å¯¼å‡º] æ‰¾åˆ°çš„è§’è‰²å¯¹è±¡:', character);
    
    if (!character) {
        showToast('æœªæ‰¾åˆ°å½“å‰èŠå¤©å¯¹è±¡');
        return;
    }

    // âœ… å…³é”®ä¿®å¤ï¼šä½¿ç”¨ history è€Œä¸æ˜¯ messages
    const historyData = character.history || [];
    console.log('ğŸ”µ [å¯¼å‡º] èŠå¤©è®°å½•æ•°é‡:', historyData.length);
    console.log('ğŸ”µ [å¯¼å‡º] èŠå¤©è®°å½•å†…å®¹:', historyData);

    if (historyData.length === 0) {
        console.warn('âš ï¸ [å¯¼å‡º] è­¦å‘Šï¼šå½“å‰èŠå¤©è®°å½•ä¸ºç©ºï¼');
    }

    try {
        // æ„å»ºå¯¼å‡ºæ•°æ®
        const exportData = {
            type: 'ç« é±¼å–·å¢¨æœº-SingleChat',
            version: 1,
            exportDate: new Date().toISOString(),
            chatData: {
                id: character.id,
                remarkName: character.remarkName,
                realName: character.realName,
                avatar: character.avatar,
                myName: character.myName,
                history: historyData, // âœ… ä¿®å¤ï¼šå¯¼å‡º history
                // åŒ…å«è§’è‰²è®¾ç½®
                prompt: character.prompt,
                apiInstructions: character.apiInstructions,
                temperature: character.temperature,
                maxTokens: character.maxTokens,
                enableTts: character.enableTts,
                minimaxVoiceId: character.minimaxVoiceId,
                minimaxVoiceLang: character.minimaxVoiceLang,
                worldBookIds: character.worldBookIds,
                // å…¶ä»–ç›¸å…³è®¾ç½®
                chatBg: character.chatBg,
                relationship: character.relationship,
                stickerGroups: character.stickerGroups // ğŸ†• è¡¨æƒ…åŒ…åˆ†ç»„ç»‘å®š
            }
        };

        console.log('ğŸ”µ [å¯¼å‡º] å¯¼å‡ºæ•°æ®ç»“æ„:', exportData);

        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        const dateStr = new Date().toISOString().split('T')[0];
        link.download = `ç« é±¼å–·å¢¨æœº-${character.remarkName}-${dateStr}.json`;
        link.click();
        URL.revokeObjectURL(url);

        console.log('âœ… [å¯¼å‡º] å¯¼å‡ºæˆåŠŸï¼æ–‡ä»¶å:', link.download);
        showToast(`èŠå¤©è®°å½•å·²æˆåŠŸå¯¼å‡ºï¼(${historyData.length} æ¡æ¶ˆæ¯)`);
    } catch (error) {
        console.error('âŒ [å¯¼å‡º] å¯¼å‡ºå¤±è´¥:', error);
        showToast(`å¯¼å‡ºå¤±è´¥: ${error.message}`);
    }
}

/**
 * å¯¼å…¥èŠå¤©è®°å½•å¹¶è¦†ç›–å½“å‰èŠå¤©
 * @param {File} file - JSONæ–‡ä»¶
 */
async function importCurrentChat(file) {
    console.log('ğŸŸ¢ [å¯¼å…¥] å¼€å§‹å¯¼å…¥èŠå¤©è®°å½•...');
    console.log('ğŸŸ¢ [å¯¼å…¥] æ–‡ä»¶:', file);
    
    if (!currentChatId) {
        showToast('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }

    if (!file) {
        showToast('è¯·é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶');
        return;
    }

    const character = db.characters.find(c => c.id === currentChatId);
    console.log('ğŸŸ¢ [å¯¼å…¥] å½“å‰è§’è‰²:', character);
    
    if (!character) {
        showToast('æœªæ‰¾åˆ°å½“å‰èŠå¤©å¯¹è±¡');
        return;
    }

    console.log('ğŸŸ¢ [å¯¼å…¥] å¯¼å…¥å‰èŠå¤©è®°å½•æ•°é‡:', character.history?.length || 0);

    try {
        const text = await file.text();
        console.log('ğŸŸ¢ [å¯¼å…¥] æ–‡ä»¶è¯»å–æˆåŠŸï¼Œå¤§å°:', text.length);
        
        const data = JSON.parse(text);
        console.log('ğŸŸ¢ [å¯¼å…¥] JSONè§£ææˆåŠŸ:', data);

        // æ ¡éªŒæ–‡ä»¶æ ¼å¼ï¼ˆä»…æ”¯æŒç« é±¼æœºè‡ªå·±å¯¼å‡ºçš„æ ¼å¼ï¼‰
        if (!data.type || data.type !== 'ç« é±¼å–·å¢¨æœº-SingleChat') {
            console.error('âŒ [å¯¼å…¥] æ–‡ä»¶ç±»å‹é”™è¯¯:', data.type);
            showToast('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®ï¼Œè¿™ä¸æ˜¯ç« é±¼å–·å¢¨æœºå¯¼å‡ºçš„å¤‡ä»½æ–‡ä»¶');
            return;
        }

        // âœ… ä¿®å¤ï¼šæ£€æŸ¥ history è€Œä¸æ˜¯ messages
        if (!data.chatData || !data.chatData.history) {
            console.error('âŒ [å¯¼å…¥] æ–‡ä»¶å†…å®¹ä¸å®Œæ•´:', data.chatData);
            showToast('æ–‡ä»¶å†…å®¹ä¸å®Œæ•´ï¼Œç¼ºå°‘èŠå¤©è®°å½•æ•°æ®');
            return;
        }

        console.log('ğŸŸ¢ [å¯¼å…¥] å¾…å¯¼å…¥çš„èŠå¤©è®°å½•æ•°é‡:', data.chatData.history.length);

        // ç¡®è®¤è¦†ç›–
        const confirmed = confirm(
            `âš ï¸ ä¸¥é‡è­¦å‘Šï¼\n\nè¿™å°†ç”¨å¤‡ä»½æ–‡ä»¶ä¸­çš„æ•°æ®ã€å®Œå…¨è¦†ç›–ã€‘å½“å‰ä¸"${character.remarkName}"çš„èŠå¤©è®°å½•ã€‚\n\nå°†å¯¼å…¥ ${data.chatData.history.length} æ¡æ¶ˆæ¯ã€‚\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ`
        );

        if (!confirmed) {
            console.log('ğŸŸ¢ [å¯¼å…¥] ç”¨æˆ·å–æ¶ˆå¯¼å…¥');
            return;
        }

        const importedData = data.chatData;

        // ä¿ç•™å½“å‰è§’è‰²çš„IDï¼ˆé˜²æ­¢ç ´åstateï¼‰
        const preservedId = character.id;

        // âœ… å…³é”®ä¿®å¤ï¼šå¯¼å…¥åˆ° history å±æ€§
        console.log('ğŸŸ¢ [å¯¼å…¥] å¼€å§‹è¦†ç›–èŠå¤©è®°å½•...');
        character.history = importedData.history || [];
        console.log('ğŸŸ¢ [å¯¼å…¥] è¦†ç›–å®Œæˆï¼Œæ–°çš„èŠå¤©è®°å½•æ•°é‡:', character.history.length);

        // å¯¼å…¥è§’è‰²è®¾ç½®
        if (importedData.prompt !== undefined) character.prompt = importedData.prompt;
        if (importedData.apiInstructions !== undefined) character.apiInstructions = importedData.apiInstructions;
        if (importedData.temperature !== undefined) character.temperature = importedData.temperature;
        if (importedData.maxTokens !== undefined) character.maxTokens = importedData.maxTokens;
        if (importedData.enableTts !== undefined) character.enableTts = importedData.enableTts;
        if (importedData.minimaxVoiceId !== undefined) character.minimaxVoiceId = importedData.minimaxVoiceId;
        if (importedData.minimaxVoiceLang !== undefined) character.minimaxVoiceLang = importedData.minimaxVoiceLang;
        if (importedData.worldBookIds !== undefined) character.worldBookIds = importedData.worldBookIds;
        if (importedData.chatBg !== undefined) character.chatBg = importedData.chatBg;
        if (importedData.relationship !== undefined) character.relationship = importedData.relationship;
        if (importedData.stickerGroups !== undefined) character.stickerGroups = importedData.stickerGroups; // ğŸ†• è¡¨æƒ…åŒ…åˆ†ç»„ç»‘å®š
        // å…¼å®¹æ—§æ ¼å¼ï¼šå¦‚æœå¯¼å…¥çš„æ˜¯æ—§ç‰ˆæœ¬çš„ shareStickers
        if (importedData.shareStickers === true && !character.stickerGroups) {
            const allGroups = getAllStickerGroups();
            const hasUngrouped = db.myStickers.some(s => !s.group || s.group.trim() === '');
            if (hasUngrouped) allGroups.unshift('æœªåˆ†ç±»');
            character.stickerGroups = allGroups.join(',');
            console.log('ğŸ”µ [å¯¼å…¥] å…¼å®¹æ—§ç‰ˆ shareStickersï¼Œè‡ªåŠ¨ç»‘å®šæ‰€æœ‰åˆ†ç»„');
        }

        // ç¡®ä¿IDä¸å˜
        character.id = preservedId;
        console.log('ğŸŸ¢ [å¯¼å…¥] ä¿ç•™è§’è‰²ID:', preservedId);

        // ä¿å­˜åˆ°æ•°æ®åº“
        console.log('ğŸŸ¢ [å¯¼å…¥] å¼€å§‹ä¿å­˜æ•°æ®...');
        await saveData();
        console.log('ğŸŸ¢ [å¯¼å…¥] æ•°æ®ä¿å­˜æˆåŠŸ');

        // åˆ·æ–°ç•Œé¢
        console.log('ğŸŸ¢ [å¯¼å…¥] å¼€å§‹åˆ·æ–°ç•Œé¢...');
        renderMessages();
        console.log('âœ… [å¯¼å…¥] å¯¼å…¥å®Œæˆï¼');
        
        showToast(`èŠå¤©è®°å½•å·²æˆåŠŸå¯¼å…¥ï¼(${character.history.length} æ¡æ¶ˆæ¯)`);

        // å…³é—­è®¾ç½®é¢æ¿
        const settingsSidebar = document.getElementById('chat-settings-sidebar');
        if (settingsSidebar) {
            settingsSidebar.classList.remove('active');
        }

    } catch (error) {
        console.error('âŒ [å¯¼å…¥] å¯¼å…¥å¤±è´¥:', error);
        console.error('âŒ [å¯¼å…¥] é”™è¯¯å †æ ˆ:', error.stack);
        if (error instanceof SyntaxError) {
            showToast('æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œæ— æ³•è§£æJSON');
        } else {
            showToast(`å¯¼å…¥å¤±è´¥: ${error.message}`);
        }
    }
}


// === æ–°å¢çš„AIæ€»ç»“å¹¶æ¸…ç©ºå†å²è®°å½•çš„å‡½æ•° ===
async function clearHistoryDirectly() {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    if (!chat) return;

    if (chat.history.length === 0) {
        showToast('æ²¡æœ‰èŠå¤©è®°å½•å¯æ¸…ç©ºã€‚');
        return;
    }

    const sidebar = (currentChatType === 'private') ? settingsSidebar : groupSettingsSidebar;
    sidebar.classList.remove('open');

    // 1. æ¸…ç©ºå†…å­˜ä¸­çš„å†å²è®°å½•
    chat.history = [];

    // 2. æ¸…é™¤ IndexedDB ä¸­å­˜å‚¨çš„æ¶ˆæ¯å—ï¼ˆå…³é”®æ­¥éª¤ï¼ï¼‰
    await dataStorage.clearChatMessages(currentChatId, currentChatType);

    // 3. ä¿å­˜æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
    await saveData();

    // 4. åˆ·æ–°UI
    renderMessages(false, true); // åˆ·æ–°èŠå¤©ç•Œé¢
    renderChatList(); // åˆ·æ–°èŠå¤©åˆ—è¡¨
    showToast('èŠå¤©è®°å½•å·²æ¸…ç©ºï¼');
}
// === æ–°å¢ï¼šä¸»é¡µå¤´å›¾ç¼–è¾‘å™¨åŠŸèƒ½ ===
function setupHomeScreenProfileEditor() {
    const header = document.querySelector('.home-profile-header');
    if (!header) return;

    // å…ƒç´ ç¼“å­˜
    const heroEl = header.querySelector('.home-hero');
    const avatarImg = header.querySelector('#home-profile-avatar');
    const nameEl = header.querySelector('.home-profile-name');
    const signatureEl = header.querySelector('.home-profile-signature');

    // --- ä¿®æ”¹ï¼šè·å–æ–°çš„å¼¹çª—ç»„ä»¶ ---
    const editModal = document.getElementById('home-profile-edit-modal'); 
    const editFromUrlBtn = document.getElementById('edit-profile-from-url-btn');
    const editFromLocalBtn = document.getElementById('edit-profile-from-local-btn');
    const cancelEditBtn = document.getElementById('cancel-edit-profile-btn');
    const fileUploadInput = document.getElementById('home-profile-image-upload');
    let currentProfileEditTarget = null; 

    // 1. æ¸²æŸ“å‡½æ•° (ä¿æŒä¸å˜)
    function renderProfile() {
        const profile = db.homeProfile;
        heroEl.style.backgroundImage = `url('${profile.heroBg}')`;
        avatarImg.src = profile.avatar;
        nameEl.textContent = profile.name;
        signatureEl.textContent = profile.signature;
    
  // â–¼â–¼â–¼ åœ¨è¿™é‡Œæ·»åŠ æ–°çš„ä»£ç  â–¼â–¼â–¼
        // æ–°å¢ï¼šåŒæ—¶æ›´æ–°å•†åŸä¸ªäººä¸­å¿ƒçš„æ˜¾ç¤º
        const mallAvatarImg = document.getElementById('profile-avatar');
        const mallUsernameEl = document.getElementById('profile-username');
        if (mallAvatarImg) {
            mallAvatarImg.src = profile.avatar;
        }
        if (mallUsernameEl) {
            mallUsernameEl.textContent = profile.name;
        }
        // â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²
    }
    // 2. ä¿å­˜å‡½æ•° (ä¿æŒä¸å˜)
    async function saveProfile() {
        await saveData();
        showToast('ä¸»é¡µä¿¡æ¯å·²æ›´æ–°');
    }
    
    // --- ä¿®æ”¹ï¼šå›¾ç‰‡ç¼–è¾‘é€»è¾‘ï¼Œæ”¹ä¸ºæ‰“å¼€å±…ä¸­å¼¹çª— ---
    const openEditMenu = (target) => {
        currentProfileEditTarget = target;
        editModal.classList.add('visible'); 
    };

    heroEl.addEventListener('click', () => {
        openEditMenu('heroBg');
    });

    avatarImg.parentElement.addEventListener('click', () => {
        openEditMenu('avatar');
    });
    
    // --- æ–°å¢ï¼šå¤„ç†æ–°å¼¹çª—çš„æŒ‰é’®ç‚¹å‡» ---
    // a. "å–æ¶ˆ" æŒ‰é’®
    cancelEditBtn.addEventListener('click', () => {
        editModal.classList.remove('visible'); 
    });
    
    // æ–°å¢ï¼šç‚¹å‡»å¼¹çª—ç°è‰²èƒŒæ™¯ä¹Ÿå¯ä»¥å…³é—­
    editModal.addEventListener('click', (e) => {
        if (e.target === editModal) {
            editModal.classList.remove('visible');
        }
    });

    // b. "è¾“å…¥ç½‘ç»œURL" æŒ‰é’®
    editFromUrlBtn.addEventListener('click', async () => {
        const target = currentProfileEditTarget;
        const promptMessage = target === 'heroBg' ? 'è¯·è¾“å…¥æ–°çš„èƒŒæ™¯å›¾URLï¼š' : 'è¯·è¾“å…¥æ–°çš„å¤´åƒURLï¼š';
        const currentValue = db.homeProfile[target];
        
        const newUrl = prompt(promptMessage, currentValue);
        if (newUrl && newUrl.trim()) {
            db.homeProfile[target] = newUrl.trim();
            renderProfile();
            await saveProfile();
        }
        editModal.classList.remove('visible'); 
    });

    // c. "ä»æœ¬åœ°ä¸Šä¼ " æŒ‰é’®
    editFromLocalBtn.addEventListener('click', () => {
        fileUploadInput.click();
        editModal.classList.remove('visible'); 
    });

    // d. å¤„ç†æ–‡ä»¶ä¸Šä¼  (ä¿æŒä¸å˜)
    fileUploadInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file && currentProfileEditTarget) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                db.homeProfile[currentProfileEditTarget] = compressedUrl;
                renderProfile();
                await saveProfile();
            } catch (error) {
                showToast('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
            }
        }
        e.target.value = null; 
    });


    // 4. æ–‡å­—å†…è”ç¼–è¾‘é€»è¾‘ (ä¿æŒä¸å˜)
    nameEl.addEventListener('click', async () => {
        const newName = prompt('è¯·è¾“å…¥æ–°çš„æ˜µç§°ï¼š', db.homeProfile.name);
        if (newName && newName.trim()) {
            db.homeProfile.name = newName.trim();
            renderProfile();
            await saveProfile();
        }
    });

    signatureEl.addEventListener('click', async () => {
        const newSignature = prompt('è¯·è¾“å…¥æ–°çš„ä¸ªæ€§ç­¾åï¼š', db.homeProfile.signature);
        if (newSignature && newSignature.trim()) {
            db.homeProfile.signature = newSignature.trim();
            renderProfile();
            await saveProfile();
        }
    });

    // é¦–æ¬¡åŠ è½½æ—¶æ¸²æŸ“ä¸€æ¬¡ (ä¿æŒä¸å˜)
    renderProfile();
}
// â–¼â–¼â–¼ åœ¨è¿™é‡Œç²˜è´´ä¸‹é¢çš„æ–°ä»£ç  â–¼â–¼â–¼

// --- AIç©ºé—´ (AI POV Chat) åŠŸèƒ½ [ç”±AIç”Ÿæˆå¯¹è¯çš„ä¿®æ”¹ç‰ˆ] ---

// ç”¨äºä¸´æ—¶å­˜å‚¨AIç”Ÿæˆæ•°æ®çš„å…¨å±€å˜é‡
let currentAiPovData = {
    mainAi: null,
    chatList: [],
    conversations: {} // keyæ˜¯povChatId
};
/**
 * [æ–°çš„è¾…åŠ©å‡½æ•°] æ£€æŸ¥ä¸¤ä¸ªè§’è‰²æ˜¯å¦å¯èƒ½æ ¹æ®å…¶äººè®¾å’Œä¸–ç•Œä¹¦ç›¸äº’è®¤è¯†ã€‚
 * @param {object} charA - ç¬¬ä¸€ä¸ªè§’è‰²å¯¹è±¡ã€‚
 * @param {object} charB - ç¬¬äºŒä¸ªè§’è‰²å¯¹è±¡ã€‚
 * @returns {boolean} - å¦‚æœç¡®è®¤ç›¸è¯†åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
 */
function charactersAreAcquainted(charA, charB) {
    // è·å–ä¸¤ä¸ªè§’è‰²çš„æ‰€æœ‰å·²çŸ¥åç§°ï¼Œç”¨äºæ£€æŸ¥æåŠã€‚
    const namesA = [charA.realName, charA.remarkName].filter(Boolean);
    const namesB = [charB.realName, charB.remarkName].filter(Boolean);

    // å°†äººè®¾å’Œæ‰€æœ‰å…³è”çš„ä¸–ç•Œä¹¦å†…å®¹åˆå¹¶ä¸ºæ¯ä¸ªè§’è‰²çš„å•ä¸ªä¸Šä¸‹æ–‡å­—ç¬¦ä¸²ã€‚
    const getWorldBookContent = (char) => {
        return (char.worldBookIds || [])
            .map(id => db.worldBooks.find(wb => wb.id === id))
            .filter(Boolean)
            .map(wb => wb.content)
            .join(' ');
    };

    const contextA = `${charA.persona || ''} ${getWorldBookContent(charA)}`;
    const contextB = `${charB.persona || ''} ${getWorldBookContent(charB)}`;

    // è¿›è¡ŒåŒå‘æ£€æŸ¥ã€‚
    // è§’è‰²Açš„ä¸Šä¸‹æ–‡ï¼ˆäººè®¾æˆ–ä¸–ç•Œä¹¦ï¼‰æ˜¯å¦æåŠäº†è§’è‰²Bçš„åå­—ï¼Ÿ
    const aKnowsB = namesB.some(name => contextA.includes(name));
    // è§’è‰²Bçš„ä¸Šä¸‹æ–‡ï¼ˆäººè®¾æˆ–ä¸–ç•Œä¹¦ï¼‰æ˜¯å¦æåŠäº†è§’è‰²Açš„åå­—ï¼Ÿ
    const bKnowsA = namesA.some(name => contextB.includes(name));

    // åªè¦ä»»æ„ä¸€æ–¹çš„ä¸Šä¸‹æ–‡ä¸­æåˆ°äº†å¯¹æ–¹ï¼Œå°±è®¤ä¸ºä»–ä»¬ç›¸è¯†ã€‚
    return aKnowsB || bKnowsA;
}
/**
 * ä¸ºAIç”Ÿæˆâ€œèŠå¤©åˆ—è¡¨â€çš„æŒ‡ä»¤
 * @param {object} mainAi - ä¸»è§†è§’AIçš„è§’è‰²å¯¹è±¡
 * @param {Array} allOtherCharacters - å…¶ä»–æ‰€æœ‰å¯äº’åŠ¨çš„AIè§’è‰²åˆ—è¡¨
 * @param {object} userProfile - ç”¨æˆ·ä¿¡æ¯å¯¹è±¡
 * @returns {string} - å‘ç»™å¤§è¯­è¨€æ¨¡å‹çš„å®Œæ•´æŒ‡ä»¤
 */
function generateAiChatListPrompt(mainAi, allOtherCharacters, userProfile) {
    if (!Array.isArray(allOtherCharacters)) {
        allOtherCharacters = [];
    }

    // [æ–°å¢é€»è¾‘] æ ¹æ®äººè®¾å’Œä¸–ç•Œä¹¦ç­›é€‰å‡ºçœŸæ­£è®¤è¯†çš„è§’è‰²
    const acquaintedChars = allOtherCharacters.filter(charB => charactersAreAcquainted(mainAi, charB));

    let otherCharsPrompt = acquaintedChars.length > 0
        ? acquaintedChars.map(c => `- ${c.realName} (äººè®¾: ${c.persona})`).join('\n')
        : 'æ— å…¶ä»–å¯äº’åŠ¨è§’è‰²ã€‚';

    let worldBooksPrompt = (mainAi.worldBookIds || [])
        .map(id => db.worldBooks.find(wb => wb.id === id))
        .filter(Boolean)
        .map(wb => `[${wb.name}]\n${wb.content}`)
        .join('\n\n');

    let prompt = `ä½ æ˜¯ä¸€ä¸ªAIè§’è‰²æ‰®æ¼”è¾…åŠ©å·¥å…·ã€‚ä½ çš„ä»»åŠ¡æ˜¯ä¸ºAIè§’è‰²â€œ${mainAi.realName}â€ç”Ÿæˆä¸€ä¸ªè™šæ‹Ÿçš„èŠå¤©åˆ—è¡¨ã€‚

# è§’è‰²ä¿¡æ¯
- ä¸»è§†è§’AI: ${mainAi.realName} (äººè®¾: ${mainAi.persona})
- ç”¨æˆ·: ${userProfile.name} (ç”¨æˆ·åœ¨æˆ‘çœ¼ä¸­çš„äººè®¾: ${mainAi.myPersona || 'æœªè®¾å®š'})
- å…¶ä»–**è®¤è¯†çš„ã€å¯äº’åŠ¨çš„**AIè§’è‰²:\n${otherCharsPrompt}

# ä¸–ç•Œè§‚è®¾å®š
${worldBooksPrompt || 'æ— ç‰¹å®šä¸–ç•Œè§‚ã€‚'}

# ä»»åŠ¡è¦æ±‚
æ ¹æ®â€œ${mainAi.realName}â€çš„äººè®¾ã€ä¸ç”¨æˆ·çš„å…³ç³»ã€ä»¥åŠä¸–ç•Œè§‚ï¼Œè™šæ„ä¸€ä¸ªåŒ…å«3åˆ°5ä¸ªèŠå¤©çš„åˆ—è¡¨ã€‚
1.  **å¿…é¡»åŒ…å«ä¸€ä¸ªä¸ç”¨æˆ·â€œ${userProfile.name}â€çš„èŠå¤©**ã€‚è¿™æ˜¯æœ€é‡è¦çš„ï¼Œè¿™æ¡èŠå¤©çš„â€œæœ€åä¸€æ¡æ¶ˆæ¯â€åº”è¯¥èƒ½åæ˜ å‡ºä»–ä»¬å½“å‰çš„å…³ç³»å’Œæœ€è¿‘çš„äº’åŠ¨ã€‚
2.  **[ä¸¥æ ¼è§„åˆ™]** å‰©ä¸‹çš„èŠå¤©ï¼Œä½ **åªèƒ½**ä»ä¸Šæ–¹â€œå…¶ä»–è®¤è¯†çš„ã€å¯äº’åŠ¨çš„AIè§’è‰²â€åˆ—è¡¨ä¸­é€‰æ‹©è§’è‰²è¿›è¡Œç§èŠæˆ–ç¾¤èŠã€‚å¦‚æœè¯¥åˆ—è¡¨æ˜¯â€œæ— â€ï¼Œåˆ™ä½ **ä¸èƒ½**ç”Ÿæˆä»»ä½•ä¸å…¶ä»–AIçš„èŠå¤©ï¼Œåªèƒ½ç”Ÿæˆä¸ç”¨æˆ·çš„èŠå¤©ã€‚ä¸¥ç¦è™šæ„ä¸ä¸è®¤è¯†çš„è§’è‰²çš„å¯¹è¯ã€‚
3.  ä¸ºæ¯ä¸ªèŠå¤©ç”Ÿæˆä¸€å¥èƒ½ä½“ç°å¯¹è¯å†…å®¹çš„â€œæœ€åä¸€æ¡æ¶ˆæ¯é¢„è§ˆâ€ã€‚
4.  ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ•°ç»„æ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€‚

# è¾“å‡ºJSONæ ¼å¼ç¤ºä¾‹:
[
  {
    "chatId": "pov_chat_user",
    "type": "private",
    "otherParty": { "type": "user", "name": "${userProfile.name}" },
    "lastMessage": "æˆ‘æ­£åœ¨æƒ³ä½ åˆšæ‰è¯´çš„è¯..."
  },
  {
    "chatId": "pov_chat_ai_1",
    "type": "private",
    "otherParty": { "type": "ai", "name": "å¦ä¸€ä¸ªAIçš„çœŸå" },
    "lastMessage": "å…³äºé‚£ä¸ªè®¡åˆ’ï¼Œæˆ‘è§‰å¾—..."
  },
  {
    "chatId": "pov_chat_group_1",
    "type": "group",
    "groupName": "ä¸€ä¸ªæœ‰è¶£çš„ç¾¤å",
    "members": ["AIè§’è‰²AçœŸå", "AIè§’è‰²BçœŸå"],
    "lastMessage": "AIè§’è‰²AçœŸå: å“ˆå“ˆçœŸçš„å—ï¼Ÿ"
  }
]
`;
    return prompt;
}

/**
 * ä¸ºAIç”Ÿæˆå…·ä½“â€œå¯¹è¯å†…å®¹â€çš„æŒ‡ä»¤
 * @param {object} mainAi - ä¸»è§†è§’AIçš„è§’è‰²å¯¹è±¡
 * @param {object} chatInfo - è¢«ç‚¹å‡»çš„èŠå¤©æ¡ç›®çš„ä¿¡æ¯
 * @returns {string} - å‘ç»™å¤§è¯­è¨€æ¨¡å‹çš„å®Œæ•´æŒ‡ä»¤
 */
function generateAiConversationPrompt(mainAi, chatInfo) {
    let participantsPrompt;
    if (chatInfo.type === 'private') {
        const otherPartyName = chatInfo.otherParty.name;
        const otherPartyObj = (chatInfo.otherParty.type === 'user')
            ? { persona: mainAi.myPersona, realName: otherPartyName }
            : db.characters.find(c => c.realName === otherPartyName);
        
        participantsPrompt = `è¿™æ˜¯ä¸€ä¸ªä½  (${mainAi.realName}) å’Œ ${otherPartyName} ä¹‹é—´çš„ç§èŠã€‚
- ä½ çš„è§’è‰²: ${mainAi.realName} (äººè®¾: ${mainAi.persona})
- å¯¹æ–¹çš„è§’è‰²: ${otherPartyName} (äººè®¾: ${otherPartyObj ? otherPartyObj.persona : 'é€šç”¨äººè®¾'})`;
    } else { // group
        const memberNames = [mainAi.realName, ...chatInfo.members];
        const memberInfos = memberNames.map(name => {
            const char = db.characters.find(c => c.realName === name);
            return `- ${name} (äººè®¾: ${char ? char.persona : 'é€šç”¨äººè®¾'})`;
        }).join('\n');
        participantsPrompt = `è¿™æ˜¯ä¸€ä¸ªåä¸ºâ€œ${chatInfo.groupName}â€çš„ç¾¤èŠã€‚
ç¾¤æˆå‘˜ä¿¡æ¯:
${memberInfos}`;
    }

    let prompt = `ä½ æ˜¯ä¸€ä¸ªAIè§’è‰²æ‰®æ¼”è¾…åŠ©å·¥å…·ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ä»¥ä¸‹ä¿¡æ¯ï¼Œç”Ÿæˆä¸€æ®µç®€çŸ­çš„å¯¹è¯è®°å½•ã€‚

# å¯¹è¯èƒŒæ™¯
${participantsPrompt}
å¯¹è¯ä¸»é¢˜çº¿ç´¢ (æœ€åä¸€æ¡æ¶ˆæ¯): "${chatInfo.lastMessage}"

# ä»»åŠ¡è¦æ±‚
1.  ç”Ÿæˆä¸€æ®µè¿è´¯çš„å¯¹è¯ï¼Œæ€»æ¶ˆæ¯æ•°**ä¸å¾—è¶…è¿‡15æ¡**ã€‚
2.  æ‰€æœ‰è§’è‰²çš„å‘è¨€éƒ½å¿…é¡»ä¸¥æ ¼ç¬¦åˆä»–ä»¬å„è‡ªçš„äººè®¾ã€‚
3.  å¯¹è¯å†…å®¹åº”è¯¥ä¸ä¸»é¢˜çº¿ç´¢ç›¸å…³å¹¶è‡ªç„¶å‘å±•ã€‚
4.  å¯¹è¯çš„è§†è§’åº”è¯¥æ˜¯ä»¥ **${mainAi.realName}** ä¸ºä¸»è§†è§’ã€‚
5.  ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ•°ç»„æ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€‚

# è¾“å‡ºJSONæ ¼å¼ç¤ºä¾‹:
[
  {"sender": "å‘é€è€…çœŸå", "content": "è¿™æ˜¯ç¬¬ä¸€æ¡æ¶ˆæ¯ã€‚"},
  {"sender": "å¦ä¸€ä¸ªå‘é€è€…çœŸå", "content": "è¿™æ˜¯ç¬¬äºŒæ¡æ¶ˆæ¯ã€‚"}
]
`;
    return prompt;
}
/**
 * [æ–°å¢çš„è¾…åŠ©å‡½æ•°] æ›´æ™ºèƒ½åœ°ä»AIè¿”å›çš„æ–‡æœ¬ä¸­æå–å¹¶è§£æJSONã€‚
 * @param {string} text - ä»AIè·å–çš„åŸå§‹æ–‡æœ¬å›å¤ã€‚
 * @returns {object} - è§£ææˆåŠŸåçš„JavaScriptå¯¹è±¡æˆ–æ•°ç»„ã€‚
 * @throws {Error} - å¦‚æœåœ¨æ–‡æœ¬ä¸­æ‰¾ä¸åˆ°æˆ–æ— æ³•è§£ææœ‰æ•ˆçš„JSONï¼Œåˆ™æŠ›å‡ºé”™è¯¯ã€‚
 */
function extractAndParseJson(text) {
    // ä¼˜å…ˆå°è¯•ä»Markdownä»£ç å—ä¸­æå–JSON
    const codeBlockMatch = text.match(/```(json)?\s*([\s\S]+?)\s*```/);
    if (codeBlockMatch && codeBlockMatch) {
        try {
            return JSON.parse(codeBlockMatch);
        } catch (e) {
            console.warn("æ— æ³•ä»Markdownä»£ç å—ä¸­è§£æJSONï¼Œå°†å°è¯•åå¤‡æ–¹æ³•ã€‚", e);
        }
    }

    // åå¤‡æ–¹æ³•ï¼šå¯»æ‰¾ç¬¬ä¸€ä¸ª '{' æˆ– '['ï¼Œå¹¶åŒ¹é…åˆ°å…¶å¯¹åº”çš„ '}' æˆ– ']'
    const firstBracket = text.indexOf('[');
    const firstBrace = text.indexOf('{');
    let startIndex = -1;

    if (firstBracket === -1 && firstBrace === -1) {
        throw new Error("AIçš„å›å¤ä¸­æ²¡æœ‰æ‰¾åˆ°JSONå¯¹è±¡æˆ–æ•°ç»„çš„èµ·å§‹ç¬¦å·ã€‚");
    }

    if (firstBracket === -1) {
        startIndex = firstBrace;
    } else if (firstBrace === -1) {
        startIndex = firstBracket;
    } else {
        startIndex = Math.min(firstBracket, firstBrace);
    }
    
    const startChar = text[startIndex];
    const endChar = startChar === '[' ? ']' : '}';
    
    let nestingLevel = 0;
    let endIndex = -1;

    for (let i = startIndex; i < text.length; i++) {
        if (text[i] === startChar) {
            nestingLevel++;
        } else if (text[i] === endChar) {
            nestingLevel--;
        }

        if (nestingLevel === 0) {
            endIndex = i;
            break;
        }
    }

    if (endIndex === -1) {
        throw new Error("æ— æ³•åœ¨AIå›å¤ä¸­æ‰¾åˆ°åŒ¹é…çš„JSONç»“æŸç¬¦å·ã€‚");
    }

    const jsonString = text.substring(startIndex, endIndex + 1);
    
    try {
        return JSON.parse(jsonString);
    } catch (e) {
        console.error("æœ€ç»ˆJSONè§£æå¤±è´¥ã€‚æå–å‡ºçš„å­—ç¬¦ä¸²ä¸º:", jsonString);
        throw e; 
    }
}
/**
 /**
 * [é‡å†™] è®¾ç½®AIç©ºé—´åº”ç”¨çš„æ‰€æœ‰äº‹ä»¶å’Œé€»è¾‘
 */
function setupAiPovApp() {
    // ç›‘å¬â€œAIè§’è‰²é€‰æ‹©åˆ—è¡¨â€çš„ç‚¹å‡»äº‹ä»¶
    document.getElementById('ai-character-select-list').addEventListener('click', async (e) => {
        const charItem = e.target.closest('.list-item');
        if (charItem && charItem.dataset.id) {
            currentAiPovId = charItem.dataset.id;
            const character = db.characters.find(c => c.id === currentAiPovId);
            if (!character) return;
            
            switchScreen('ai-chat-list-screen');

            // [æ–°å¢] æ£€æŸ¥ç¼“å­˜
            if (character.povCache && character.povCache.chatList) {
                console.log("ä»ç¼“å­˜åŠ è½½AIèŠå¤©åˆ—è¡¨ã€‚");
                currentAiPovData.mainAi = character;
                currentAiPovData.chatList = character.povCache.chatList;
                currentAiPovData.conversations = character.povCache.conversations || {};
                renderAiChatList(character, character.povCache.chatList);
                return;
            }

            // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œåˆ™ç”Ÿæˆ
            document.getElementById('ai-chat-list-title').textContent = `æ­£åœ¨ç”Ÿæˆ ${character.remarkName} çš„èŠå¤©...`;
            document.getElementById('ai-chat-list-container').innerHTML = `<p class="placeholder-text">è¯·ç¨å€™...</p>`;

            try {
                const otherCharacters = db.characters.filter(c => c.id !== currentAiPovId);
                const userProfile = { name: character.myName };
                const prompt = generateAiChatListPrompt(character, otherCharacters, userProfile);

                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const chatList = extractAndParseJson(aiResponseText);

                // å­˜å‚¨AIç”Ÿæˆçš„æ•°æ®åˆ°ä¸´æ—¶å˜é‡å’Œé•¿æœŸç¼“å­˜
                currentAiPovData.mainAi = character;
                currentAiPovData.chatList = chatList;
                currentAiPovData.conversations = {};
                
                character.povCache = {
                    chatList: chatList,
                    conversations: {}
                };
                await saveData();

                renderAiChatList(character, chatList);

            } catch (error) {
                console.error("ç”ŸæˆAIèŠå¤©åˆ—è¡¨å¤±è´¥:", error);
                showToast(`ç”Ÿæˆå¤±è´¥: ${error.message}`);
                document.getElementById('ai-chat-list-container').innerHTML = `<p class="placeholder-text" style="color:red;">ç”ŸæˆèŠå¤©åˆ—è¡¨å¤±è´¥ã€‚</p>`;
            }
        }
    });

    // ç›‘å¬ä¸»å±å¹•ä¸Šâ€œAIç©ºé—´â€å›¾æ ‡çš„ç‚¹å‡»
    document.body.addEventListener('click', e => {
        const icon = e.target.closest('[data-target="ai-character-select-screen"]');
        if (icon) {
            renderAiCharacterSelect();
        }
    });
    
    // ç›‘å¬â€œAIçš„èŠå¤©åˆ—è¡¨â€çš„ç‚¹å‡»äº‹ä»¶
    document.getElementById('ai-chat-list-container').addEventListener('click', async (e) => {
        const chatItem = e.target.closest('.list-item');
        if (chatItem && chatItem.dataset.povChatId) {
            currentAiPovChatId = chatItem.dataset.povChatId;
            const chatInfo = currentAiPovData.chatList.find(c => c.chatId === currentAiPovChatId);
            if (!chatInfo) return;

            // [æ–°å¢] ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœç‚¹å‡»çš„æ˜¯ä¸ç”¨æˆ·çš„èŠå¤©
            if (chatInfo.otherParty && chatInfo.otherParty.type === 'user') {
                renderAiPovConversation(currentAiPovData.mainAi, chatInfo, currentAiPovData.mainAi.history);
                switchScreen('ai-chat-view-screen');
                return;
            }

            // [æ–°å¢] æ£€æŸ¥å¯¹è¯ç¼“å­˜
            if (currentAiPovData.conversations[currentAiPovChatId]) {
                console.log("ä»ç¼“å­˜åŠ è½½AIé—´å¯¹è¯ã€‚");
                renderAiPovConversation(currentAiPovData.mainAi, chatInfo, currentAiPovData.conversations[currentAiPovChatId].history);
                switchScreen('ai-chat-view-screen');
                return;
            }
            
            // å¦‚æœæ²¡æœ‰ç¼“å­˜ï¼Œåˆ™ç”Ÿæˆ
            switchScreen('ai-chat-view-screen');
            const otherPartyName = chatInfo.type === 'private' ? (db.characters.find(c=>c.realName === chatInfo.otherParty.name)?.remarkName || chatInfo.otherParty.name) : chatInfo.groupName;
            document.getElementById('ai-chat-view-title').textContent = `æ­£åœ¨ç”Ÿæˆä¸ ${otherPartyName} çš„å¯¹è¯...`;
            document.getElementById('ai-message-area').innerHTML = `<p class="placeholder-text">è¯·ç¨å€™...</p>`;

            try {
                const prompt = generateAiConversationPrompt(currentAiPovData.mainAi, chatInfo);
                const aiResponseText = await callAiApi([{ role: 'user', content: prompt }]);
                const conversation = extractAndParseJson(aiResponseText);

               

                // å­˜å‚¨åˆ°ä¸´æ—¶å˜é‡å’Œé•¿æœŸç¼“å­˜ï¼Œå¹¶æ·»åŠ æ—¶é—´æˆ³
const conversationData = {
    history: conversation,
    timestamp: Date.now() // <-- æ ¸å¿ƒæ–°å¢ï¼šè®°å½•å½“å‰æ—¶é—´
};
currentAiPovData.conversations[currentAiPovChatId] = conversationData;
const character = db.characters.find(c => c.id === currentAiPovId);
if (character && character.povCache) {
    character.povCache.conversations[currentAiPovChatId] = conversationData;
    await saveData();
}


renderAiPovConversation(currentAiPovData.mainAi, chatInfo, conversation);

            } catch(error) {
                console.error("ç”ŸæˆAIå¯¹è¯å¤±è´¥:", error);
                showToast(`ç”Ÿæˆå¤±è´¥: ${error.message}`);
                document.getElementById('ai-message-area').innerHTML = `<p class="placeholder-text" style="color:red;">ç”Ÿæˆå¯¹è¯å¤±è´¥ã€‚</p>`;
            }
        }
    });
}

/**
 * [é‡å†™] æ¸²æŸ“AIè§’è‰²é€‰æ‹©åˆ—è¡¨
 */
function renderAiCharacterSelect() {
    const container = document.getElementById('ai-character-select-list');
    const placeholder = document.getElementById('no-ai-chars-placeholder');
    container.innerHTML = '';
    
    if (!db.characters || db.characters.length === 0) {
        placeholder.style.display = 'block';
    } else {
        placeholder.style.display = 'none';
        db.characters.forEach(char => {
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.id = char.id;
            li.style.cursor = 'pointer';
            li.innerHTML = `
                <img src="${char.avatar}" alt="${char.remarkName}" class="chat-avatar">
                <div class="item-details">
                    <div class="item-name">${char.remarkName}</div>
                    <div class="item-preview">æŸ¥çœ‹ ${char.remarkName} çš„èŠå¤©...</div>
                </div>
            `;
            container.appendChild(li);
        });
    }
    switchScreen('ai-character-select-screen');
}

/**
 * [é‡å†™] æ¸²æŸ“ç”±AIç”Ÿæˆçš„èŠå¤©åˆ—è¡¨
 * @param {object} character - ä¸»è§†è§’AIè§’è‰²å¯¹è±¡
 * @param {Array} chatList - AIç”Ÿæˆçš„èŠå¤©åˆ—è¡¨æ•°æ®
 */
function renderAiChatList(character, chatList) {
    document.getElementById('ai-chat-list-title').textContent = `${character.remarkName}çš„èŠå¤©åˆ—è¡¨`;
    const container = document.getElementById('ai-chat-list-container');
    const placeholder = document.getElementById('no-ai-chats-placeholder');
    container.innerHTML = '';
    
    if (!chatList || chatList.length === 0) {
        placeholder.style.display = 'block';
    } else {
        placeholder.style.display = 'none';
        chatList.forEach(chat => {
            let avatar = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            let name = 'æœªçŸ¥';
            if (chat.type === 'private') {
                if (chat.otherParty.type === 'user') {
                    // å°è¯•ä»ä»»ä½•ä¸€ä¸ªè§’è‰²æ•°æ®ä¸­æ‰¾åˆ°ç”¨æˆ·çš„å¤´åƒä¿¡æ¯
                    const userChar = db.characters.find(c => c.myName === chat.otherParty.name);
                    avatar = userChar ? userChar.myAvatar : (db.characters[0]?.myAvatar || avatar);
                    name = chat.otherParty.name;
                } else {
                    const otherAi = db.characters.find(c => c.realName === chat.otherParty.name);
                    avatar = otherAi ? otherAi.avatar : avatar;
                    name = otherAi ? otherAi.remarkName : chat.otherParty.name;
                }
            } else { // group
                avatar = 'https://i.postimg.cc/fTLCngk1/image.jpg'; // é»˜è®¤ç¾¤å¤´åƒ
                name = chat.groupName;
            }
            
            const li = document.createElement('li');
            li.className = 'list-item';
            li.dataset.povChatId = chat.chatId;
            li.style.cursor = 'pointer';
            li.innerHTML = `
                <img src="${avatar}" alt="${name}" class="chat-avatar ${chat.type === 'group' ? 'group-avatar' : ''}">
                <div class="item-details">
                    <div class="item-name">${name}</div>
                    <div class="item-preview">${chat.lastMessage}</div>
                </div>
            `;
            container.appendChild(li);
        });
    }
}

// â–¼â–¼â–¼ è¯·ç”¨è¿™ä¸ªå®Œæ•´çš„ã€ä¿®æ­£åçš„æ–°å‡½æ•°ï¼Œæ›¿æ¢æ‰æ–‡ä»¶ä¸­æ—§çš„ renderAiPovConversation å‡½æ•° â–¼â–¼â–¼

/**
 * [V2.0 | é‡æ„ç‰ˆ] æ¸²æŸ“ç”±AIç”Ÿæˆçš„å¯¹è¯å†…å®¹æˆ–çœŸå®çš„ç”¨æˆ·å¯¹è¯
 * @param {object} mainAi - ä¸»è§†è§’AIè§’è‰²å¯¹è±¡
 * @param {object} chatInfo - è¢«ç‚¹å‡»çš„èŠå¤©æ¡ç›®çš„ä¿¡æ¯
 * @param {Array} conversationHistory - AIç”Ÿæˆçš„å¯¹è¯å†å²æˆ–çœŸå®çš„èŠå¤©è®°å½•
 */
function renderAiPovConversation(mainAi, chatInfo, conversationHistory) {
    const otherPartyName = chatInfo.type === 'private' ? (db.characters.find(c => c.realName === chatInfo.otherParty.name)?.remarkName || chatInfo.otherParty.name) : chatInfo.groupName;
    document.getElementById('ai-chat-view-title').textContent = `ä¸ ${otherPartyName} çš„å¯¹è¯`;
    const messageArea = document.getElementById('ai-message-area');
    messageArea.innerHTML = '';

    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘å¼€å§‹ ---

    // 1. ä¿å­˜åŸå§‹çš„å…¨å±€èŠå¤©ä¸Šä¸‹æ–‡
    const originalChatId = currentChatId;
    const originalChatType = currentChatType;

    try {
        // 2. åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ã€å‡çš„â€œç¾¤èŠâ€å¯¹è±¡æ¥æ¬ºéª—æ¸²æŸ“å‡½æ•°
        //    è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åˆ©ç”¨ç¾¤èŠä¸­æŒ‰ senderId æŸ¥æ‰¾å¤´åƒçš„ç²¾ç¡®é€»è¾‘
        const tempGroup = {
            id: `temp_group_${mainAi.id}`,
            me: { // ä¸»è§†è§’AIæ‰®æ¼”â€œæˆ‘â€
                nickname: mainAi.remarkName,
                avatar: mainAi.avatar,
                avatarFrameUrl: mainAi.avatarFrameUrl
            },
            members: [], // å¯¹è¯çš„å¦ä¸€æ–¹å°†ä½œä¸ºâ€œç¾¤æˆå‘˜â€
            theme: mainAi.theme, // æ²¿ç”¨ä¸»è§†è§’AIçš„ä¸»é¢˜è®¾ç½®
            useCustomBubbleCss: mainAi.useCustomBubbleCss,
            customBubbleCss: mainAi.customBubbleCss
        };
        
        // 3. æ ¹æ®å¯¹è¯ç±»å‹ï¼Œå¡«å……è¿™ä¸ªå‡ç¾¤èŠçš„â€œæˆå‘˜â€
        if (chatInfo.type === 'private') {
            const otherPartyIsUser = chatInfo.otherParty.type === 'user';
            const otherChar = otherPartyIsUser ? null : db.characters.find(c => c.realName === chatInfo.otherParty.name);
            
            // ã€å®‰å…¨ä¿®å¤ã€‘å¢åŠ å¯¹ otherChar æ˜¯å¦å­˜åœ¨çš„æ£€æŸ¥
            if (!otherPartyIsUser && !otherChar) {
                console.error(`AI POV é”™è¯¯: åœ¨æ•°æ®åº“ä¸­æ‰¾ä¸åˆ° realName ä¸º "${chatInfo.otherParty.name}" çš„è§’è‰²ã€‚`);
            }

            tempGroup.members.push({
                // ã€å®‰å…¨ä¿®å¤ã€‘å³ä½¿ otherChar æœªæ‰¾åˆ°ï¼Œä¹Ÿæä¾›ä¸€ä¸ªå¤‡ç”¨IDï¼Œé˜²æ­¢ .id è®¿é—®é”™è¯¯
                id: otherPartyIsUser ? 'user_temp_id' : (otherChar ? otherChar.id : `unknown_${chatInfo.otherParty.name}`),
                realName: chatInfo.otherParty.name,
                groupNickname: otherPartyIsUser ? mainAi.myName : (otherChar ? otherChar.remarkName : chatInfo.otherParty.name),
                avatar: otherPartyIsUser ? mainAi.myAvatar : (otherChar ? otherChar.avatar : 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg'),
                avatarFrameUrl: otherPartyIsUser ? mainAi.myAvatarFrameUrl : (otherChar ? otherChar.avatarFrameUrl : null)
            });

        } else { // å¦‚æœæ˜¯ç¾¤èŠ
            chatInfo.members.forEach(memberName => {
                 const memberChar = db.characters.find(c => c.realName === memberName);
                 if(memberChar){
                     tempGroup.members.push({
                         id: memberChar.id,
                         realName: memberChar.realName,
                         groupNickname: memberChar.remarkName,
                         avatar: memberChar.avatar,
                         avatarFrameUrl: memberChar.avatarFrameUrl
                     });
                 }
            });
        }

        // 4. ä¸´æ—¶å°†è¿™ä¸ªå‡ç¾¤èŠå¯¹è±¡èµ‹å€¼ç»™ db.groupsï¼Œå¹¶è®¾ç½®å…¨å±€ä¸Šä¸‹æ–‡
        db.groups.push(tempGroup);
        currentChatId = tempGroup.id;
        currentChatType = 'group';

        // 5. éå†å¯¹è¯å†å²å¹¶æ¸²æŸ“
        const historyToRender = Array.isArray(conversationHistory) ? conversationHistory : [];
        
        // [ä¿®æ­£] åˆ¤æ–­æ˜¯çœŸå®å†å²è®°å½•è¿˜æ˜¯AIç”Ÿæˆçš„å†å²è®°å½•
        const isRealHistory = historyToRender.length > 0 && historyToRender[0].hasOwnProperty('role');

        historyToRender.forEach(msg => {
            let senderIdForBubble;

            // [ä¿®æ­£] æ ¹æ®å†å²è®°å½•çš„ç±»å‹ï¼Œä½¿ç”¨ä¸åŒçš„é€»è¾‘æ¥åˆ¤æ–­å‘é€è€…
            if (isRealHistory) {
                // å¤„ç†çœŸå®çš„ç”¨æˆ·-AIå¯¹è¯
                if (msg.role === 'assistant') {
                    senderIdForBubble = 'user_me'; // AIçš„æ¶ˆæ¯ï¼Œåœ¨AIè§†è§’ä¸‹æ˜¯â€œæˆ‘â€å‘çš„
                } else { // role === 'user'
                    senderIdForBubble = tempGroup.members[0].id; // ç”¨æˆ·çš„æ¶ˆæ¯ï¼Œæ˜¯â€œå¯¹æ–¹â€å‘çš„
                }
            } else {
                // å¤„ç†AIç”Ÿæˆçš„AI-AIå¯¹è¯
                if (msg.sender === mainAi.realName) {
                    senderIdForBubble = 'user_me'; // ä¸»è§†è§’AIçš„æ¶ˆæ¯
                } else {
                    const member = tempGroup.members.find(m => m.realName === msg.sender);
                    senderIdForBubble = member ? member.id : 'unknown_sender'; // å…¶ä»–AIæˆ–æœªçŸ¥AIçš„æ¶ˆæ¯
                }
            }
            
            // åˆ›å»ºä¸€ä¸ªç¬¦åˆç¾¤èŠæ¸²æŸ“é€»è¾‘çš„ä¸´æ—¶æ¶ˆæ¯å¯¹è±¡
            const tempMessage = {
                id: msg.id || `pov_${Date.now()}_${Math.random()}`,
                content: msg.content,
                timestamp: msg.timestamp || Date.now(),
                role: 'user', // åœ¨ç¾¤èŠæ¨¡å¼ä¸‹ï¼Œroleä¸é‡è¦ï¼ŒsenderIdæ‰é‡è¦
                senderId: senderIdForBubble,
                ...msg
            };
            
            const bubbleElement = createMessageBubbleElement(tempMessage);
            
            if (bubbleElement) {
                messageArea.appendChild(bubbleElement);
            }
        });

    } finally {
        // 6. æ¸²æŸ“å®Œæˆåï¼Œå¿…é¡»æ¸…ç†æ‰ä¸´æ—¶æ•°æ®å¹¶æ¢å¤åŸå§‹ä¸Šä¸‹æ–‡
        db.groups = db.groups.filter(g => !g.id.startsWith('temp_group_'));
        currentChatId = originalChatId;
        currentChatType = originalChatType;
    }
    // --- æ ¸å¿ƒä¿®å¤é€»è¾‘ç»“æŸ ---

    setTimeout(() => { messageArea.scrollTop = messageArea.scrollHeight; }, 50);
}
/**
 * [é‡å†™] èƒŒæ™¯å¯¹è¯ç”ŸæˆåŠŸèƒ½ï¼Œä»¥ç¡®ä¿ä¸AIç©ºé—´åŠŸèƒ½è§£è€¦
 */
/**
 * [æ–°çš„è¾…åŠ©å‡½æ•°] æ£€æŸ¥ä¸¤ä¸ªè§’è‰²æ˜¯å¦å¯èƒ½æ ¹æ®å…¶äººè®¾å’Œä¸–ç•Œä¹¦ç›¸äº’è®¤è¯†ã€‚
 * @param {object} charA - ç¬¬ä¸€ä¸ªè§’è‰²å¯¹è±¡ã€‚
 * @param {object} charB - ç¬¬äºŒä¸ªè§’è‰²å¯¹è±¡ã€‚
 * @returns {boolean} - å¦‚æœç¡®è®¤ç›¸è¯†åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
 */
function charactersAreAcquainted(charA, charB) {
    // è·å–ä¸¤ä¸ªè§’è‰²çš„æ‰€æœ‰å·²çŸ¥åç§°ï¼Œç”¨äºæ£€æŸ¥æåŠã€‚
    const namesA = [charA.realName, charA.remarkName].filter(Boolean);
    const namesB = [charB.realName, charB.remarkName].filter(Boolean);

    // å°†äººè®¾å’Œæ‰€æœ‰å…³è”çš„ä¸–ç•Œä¹¦å†…å®¹åˆå¹¶ä¸ºæ¯ä¸ªè§’è‰²çš„å•ä¸ªä¸Šä¸‹æ–‡å­—ç¬¦ä¸²ã€‚
    const getWorldBookContent = (char) => {
        return (char.worldBookIds || [])
            .map(id => db.worldBooks.find(wb => wb.id === id))
            .filter(Boolean)
            .map(wb => wb.content)
            .join(' ');
    };

    const contextA = `${charA.persona || ''} ${getWorldBookContent(charA)}`;
    const contextB = `${charB.persona || ''} ${getWorldBookContent(charB)}`;

    // è¿›è¡ŒåŒå‘æ£€æŸ¥ã€‚
    // è§’è‰²Açš„ä¸Šä¸‹æ–‡ï¼ˆäººè®¾æˆ–ä¸–ç•Œä¹¦ï¼‰æ˜¯å¦æåŠäº†è§’è‰²Bçš„åå­—ï¼Ÿ
    const aKnowsB = namesB.some(name => contextA.includes(name));
    // è§’è‰²Bçš„ä¸Šä¸‹æ–‡ï¼ˆäººè®¾æˆ–ä¸–ç•Œä¹¦ï¼‰æ˜¯å¦æåŠäº†è§’è‰²Açš„åå­—ï¼Ÿ
    const bKnowsA = namesA.some(name => contextB.includes(name));

    // åªè¦ä»»æ„ä¸€æ–¹çš„ä¸Šä¸‹æ–‡ä¸­æåˆ°äº†å¯¹æ–¹ï¼Œå°±è®¤ä¸ºä»–ä»¬ç›¸è¯†ã€‚
    return aKnowsB || bKnowsA;
}


/**
 * [ä¿®è®¢ç‰ˆ] è§¦å‘å¹¶ç”Ÿæˆä¸¤ä¸ªAIè§’è‰²ä¹‹é—´çš„åå°å¯¹è¯ã€‚
 * è¯¥å¯¹è¯åªä¼šåœ¨ä¸¤ä¸ªè§’è‰²è¢«ç¡®è®¤ç›¸äº’è®¤è¯†çš„æƒ…å†µä¸‹å‘ç”Ÿã€‚
 * @param {object} characterA - åˆšåˆšä¸ç”¨æˆ·äº’åŠ¨çš„é‚£ä¸ªè§’è‰²ã€‚
 */
async function generateBackgroundChat(characterA) {
    // å¦‚æœæ²¡æœ‰è¶³å¤Ÿçš„è§’è‰²è¿›è¡Œå¯¹è¯ï¼Œåˆ™ä¸­æ­¢ã€‚
    if (currentChatType !== 'private' || db.characters.length < 2) return;

    // æ‰¾åˆ°ç”¨æˆ·çš„æœ€åä¸€æ¡æ¶ˆæ¯ï¼Œä½œä¸ºå¯¹è¯çš„è§¦å‘å™¨ã€‚
    const lastUserMessage = characterA.history.findLast(m => m.role === 'user');
    if (!lastUserMessage) return;

    const otherCharacters = db.characters.filter(c => c.id !== characterA.id);

    // --- æ ¸å¿ƒé€»è¾‘å˜æ›´ ---
    // ç­›é€‰æ½œåœ¨çš„èŠå¤©ä¼™ä¼´åˆ—è¡¨ï¼Œåªä¿ç•™é‚£äº›è®¤è¯† characterA çš„è§’è‰²ã€‚
    const potentialPartners = otherCharacters.filter(charB => charactersAreAcquainted(characterA, charB));

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è®¤è¯†çš„è§’è‰²ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚
    if (potentialPartners.length === 0) {
        console.log(`[åå°èŠå¤©] ${characterA.remarkName} æ²¡æœ‰è®¤è¯†çš„ä¼™ä¼´å¯ä»¥èŠå¤©ã€‚`);
        return;
    }

    // ä»è®¤è¯†çš„è§’è‰²åˆ—è¡¨ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªä¼™ä¼´ã€‚
    const characterB = potentialPartners[Math.floor(Math.random() * potentialPartners.length)];
    // --- æ ¸å¿ƒé€»è¾‘å˜æ›´ç»“æŸ ---

    const prompt = `ä½ æ˜¯ä¸€ä¸ªèŠå¤©æ¨¡æ‹Ÿå™¨ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ ¹æ®ä¸€ä¸ªè§¦å‘äº‹ä»¶ï¼Œåœ¨ä¸¤ä¸ªAIè§’è‰²ä¹‹é—´ç”Ÿæˆä¸€æ®µç®€çŸ­ã€çœŸå®çš„å¯¹è¯ã€‚
    
    è§’è‰²A (å¯¹è¯å‘èµ·è€…):
    - åå­—: ${characterA.realName}
    - äººè®¾: ${characterA.persona}
    
    è§’è‰²B (å¯¹è¯æ¥æ”¶è€…):
    - åå­—: ${characterB.realName}
    - äººè®¾: ${characterB.persona}

    è§¦å‘äº‹ä»¶ (è¿™æ˜¯ç”¨æˆ·åˆšåˆšå¯¹è§’è‰²Aè¯´çš„è¯): "${lastUserMessage.content.replace(/\[.*?çš„æ¶ˆæ¯ï¼š|\]/g, '')}"

    ä»»åŠ¡:
    1. è§’è‰²Aä¸»åŠ¨æ‰¾è§’è‰²Bï¼Œå°±â€œè§¦å‘äº‹ä»¶â€å¼€å§‹ä¸€æ®µå¯¹è¯ã€‚
    2. ç”Ÿæˆ2åˆ°4å¥å¯¹è¯ã€‚
    3. ä¸¥æ ¼ä¿æŒä¸¤ä¸ªè§’è‰²çš„äººè®¾ã€‚
    4. ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ•°ç»„æ ¼å¼ï¼Œåƒè¿™æ ·: [{"sender": "${characterA.realName}", "content": "ç¬¬ä¸€å¥è¯"}, {"sender": "${characterB.realName}", "content": "ç¬¬äºŒå¥è¯"}]
    
    è¯·ç›´æ¥å¼€å§‹ç”ŸæˆJSONï¼Œä¸è¦åŒ…å«ä»»ä½•é¢å¤–çš„è§£é‡Šã€‚`;

    try {
        let messagesForApi;
        if (db.apiSettings.provider === 'gemini') {
            messagesForApi = [{ role: 'user', parts: [{ type: 'text', text: prompt }] }];
        } else {
            messagesForApi = [{ role: 'user', content: prompt }];
        }
        
        const aiResponseText = await callAiApi(messagesForApi);
        const jsonMatch = aiResponseText.match(/\[[\s\S]*?\]/);
        if (!jsonMatch) {
            console.warn("èƒŒæ™¯å¯¹è¯ç”Ÿæˆå¤±è´¥: AIå›å¤ä¸­æœªæ‰¾åˆ°æœ‰æ•ˆçš„JSONæ•°ç»„ã€‚", aiResponseText);
            return;
        }

        const newMessages = JSON.parse(jsonMatch[0]);

        if (!characterA.povChats) characterA.povChats = [];
        
        let povChat = characterA.povChats.find(pc => pc.otherCharId === characterB.id);
        if (!povChat) {
            povChat = {
                id: `pov_${characterA.id}_${characterB.id}`,
                otherCharId: characterB.id,
                history: []
            };
            characterA.povChats.push(povChat);
        }

        povChat.history.push(...newMessages);
        if (povChat.history.length > 20) {
            povChat.history = povChat.history.slice(povChat.history.length - 20);
        }
        
        console.log(`å·²ç”Ÿæˆ ${characterA.remarkName} å’Œ ${characterB.remarkName} ä¹‹é—´çš„èƒŒæ™¯å¯¹è¯ã€‚`);

    } catch (error) {
        console.error("ç”ŸæˆèƒŒæ™¯å¯¹è¯å¤±è´¥:", error);
    }
}
// ===============================================================
// START: æ–°å¢æ‹‰é»‘åŠŸèƒ½æ ¸å¿ƒä»£ç 
// ===============================================================

/**
 * è®¾ç½®æ‹‰é»‘åŠŸèƒ½çš„æ‰€æœ‰äº‹ä»¶ç›‘å¬å’Œé€»è¾‘
 */
function setupBlockFeature() {
    const blockBtn = document.getElementById('block-user-btn');
    if (blockBtn) {
        blockBtn.addEventListener('click', handleUserBlockToggle);
    }
}

async function handleUserBlockToggle() {
    if (currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    if (!character) return;

    character.isBlockedByUser = !character.isBlockedByUser; // åˆ‡æ¢çŠ¶æ€

    let displayMessageContent = '';
    let contextMessageContent = '';
    
    if (character.isBlockedByUser) {
        // ** è¿›å…¥æ‹‰é»‘çŠ¶æ€ **
        character.userBlockTimestamp = Date.now();
        displayMessageContent = `[system-display:ä½ å·²å°† ${character.remarkName} æ‹‰é»‘ã€‚]`;
        contextMessageContent = `[system: ä½ å·²è¢« ${character.myName} æ‹‰é»‘ã€‚]`;
        showToast(`å·²æ‹‰é»‘ ${character.remarkName}`);
        
    } else {
        // ** è§£é™¤æ‹‰é»‘çŠ¶æ€ **
        character.userBlockTimestamp = null;
        displayMessageContent = `[system-display:${character.remarkName} å·²è¢«ä½ è§£é™¤æ‹‰é»‘ã€‚]`;
        contextMessageContent = `[system: ${character.myName} å·²å°†ä½ è§£é™¤æ‹‰é»‘ã€‚]`;

        // å¦‚æœæœ‰æš‚å­˜çš„æ¶ˆæ¯ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†
        if (character.pendingMessages && character.pendingMessages.length > 0) {
            const missedMessagesText = character.pendingMessages
                .map(msg => msg.content.replace(/\[.*?çš„æ¶ˆæ¯ï¼š|\]/g, ''))
                .join('\n- ');
            contextMessageContent += ` åœ¨ä½ è¢«æ‹‰é»‘æœŸé—´ï¼Œ${character.myName} å‘é€äº†ä»¥ä¸‹æ¶ˆæ¯ï¼Œè¯·ä½ ä¸€æ¬¡æ€§åœ°å¯¹è¿™äº›å†…å®¹ä½œå‡ºå›åº”ï¼š\n- ${missessedMessagesText}`;
            
            // å°†æš‚å­˜æ¶ˆæ¯æ­£å¼ç§»å…¥å†å²å¹¶æ¸…ç©º
            character.history.push(...character.pendingMessages);
            character.pendingMessages = [];
        }
        
        showToast(`å·²è§£é™¤å¯¹ ${character.remarkName} çš„æ‹‰é»‘`);
        getAiReply(); // è§£é™¤åç«‹å³è§¦å‘ä¸€æ¬¡AIå›å¤
    }

    // åˆ›å»ºç”¨äºåœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºçš„ç³»ç»Ÿæç¤ºæ¶ˆæ¯
    const displayMessage = {
        id: `msg_block_display_${Date.now()}`,
        role: 'system', // å…³é”®ï¼šè¿™æ˜¯ä¸€ä¸ªç³»ç»Ÿè§’è‰²çš„æ¶ˆæ¯
        content: displayMessageContent,
        parts: [],
        timestamp: Date.now()
    };

    // åˆ›å»ºç”¨äºå‘ŠçŸ¥AIä¸Šä¸‹æ–‡çš„ã€ä¸å¯è§çš„ç”¨æˆ·æ¶ˆæ¯
    const contextMessage = {
        id: `msg_block_context_${Date.now()}`,
        role: 'user',
        content: contextMessageContent,
        parts: [{ type: 'text', text: contextMessageContent }],
        timestamp: Date.now()
    };

    // å°†ä¸¤æ¡æ¶ˆæ¯éƒ½åŠ å…¥å†å²è®°å½•
    character.history.push(displayMessage, contextMessage);

    await saveData();
    updateBlockButtonState(character);
    renderMessages(false, true); // åˆ·æ–°ç•Œé¢ä»¥æ˜¾ç¤ºæ–°çš„ç³»ç»Ÿæç¤º
}
/**
 * æ›´æ–°æ‹‰é»‘æŒ‰é’®çš„æ–‡å­—å’Œæ ·å¼
 * @param {object} character - å½“å‰è§’è‰²å¯¹è±¡
 */
function updateBlockButtonState(character) {
    const blockBtn = document.getElementById('block-user-btn');
    if (blockBtn) {
        if (character.isBlockedByUser) {
            blockBtn.textContent = 'è§£é™¤æ‹‰é»‘';
            blockBtn.classList.remove('btn-danger');
            blockBtn.classList.add('btn-primary');
        } else {
            blockBtn.textContent = 'æ‹‰é»‘';
            blockBtn.classList.add('btn-danger');
            blockBtn.classList.remove('btn-primary');
        }
    }
}

/**
 * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦è¢«AIæ‹‰é»‘ï¼Œå¹¶æ›´æ–°UI
 */
function checkAndUpdateUiForAiBlock() {
    if (currentChatType !== 'private') return;
    const character = db.characters.find(c => c.id === currentChatId);
    const isBlocked = character && character.isBlockedByAi;

    getReplyBtn.disabled = isBlocked || isGenerating;
    // ç¦ç”¨æˆ–å¯ç”¨å›¾æ ‡æ çš„æ‰€æœ‰æŒ‰é’®
    document.querySelectorAll('#sticker-bar .sticker-bar-btn').forEach(btn => {
        btn.disabled = isBlocked;
        btn.style.opacity = isBlocked ? 0.5 : 1;
        btn.style.cursor = isBlocked ? 'not-allowed' : 'pointer';
    });
}

/**
 * å½“AIå‘é€ [block-user] æŒ‡ä»¤æ—¶è°ƒç”¨
 * @param {object} character - è¢«æ“ä½œçš„è§’è‰²å¯¹è±¡
 */
/**
 * å½“AIå‘é€ [block-user] æŒ‡ä»¤æ—¶è°ƒç”¨
 * @param {object} character - è¢«æ“ä½œçš„è§’è‰²å¯¹è±¡
 */
async function activateAiBlock(character) {
    character.isBlockedByAi = true;
    character.aiBlockTimestamp = Date.now();
    const duration = parseInt(db.apiSettings.aiBlockDuration, 10);
    if (duration > 0) {
        character.blockEndTime = Date.now() + duration * 60 * 1000;
    } else {
        character.blockEndTime = null;
    }

    // [æ ¸å¿ƒä¿®æ­£] åˆ›å»ºä¸€ä¸ªç”¨äºåœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºçš„ã€æ­£ç¡®çš„ç³»ç»Ÿæç¤ºæ¶ˆæ¯
    const displayMessage = {
        id: `msg_ai_block_display_${Date.now()}`,
        role: 'system',
        content: `[system-display:ä½ å·²è¢« ${character.remarkName} æ‹‰é»‘ã€‚]`,
        parts: [],
        timestamp: Date.now()
    };
    character.history.push(displayMessage);

    await saveData();

    if (character.id === currentChatId) {
        checkAndUpdateUiForAiBlock();
        // ç›´æ¥è°ƒç”¨ addMessageBubble æ¥æ˜¾ç¤ºæ–°çš„ç³»ç»Ÿæç¤º
        addMessageBubble(displayMessage); 
        showToast(`ä½ å·²è¢« ${character.remarkName} æ‹‰é»‘`);
    }
}
/**
 * å½“AIå‘é€ [unblock-user] æŒ‡ä»¤æˆ–å®šæ—¶å™¨åˆ°æœŸæ—¶è°ƒç”¨
 * @param {object} character - è¢«æ“ä½œçš„è§’è‰²å¯¹è±¡
 * @param {boolean} isAuto - æ˜¯å¦ä¸ºè‡ªåŠ¨è§£å°
 */
/**
 * å½“AIå‘é€ [unblock-user] æŒ‡ä»¤æˆ–å®šæ—¶å™¨åˆ°æœŸæ—¶è°ƒç”¨
 * @param {object} character - è¢«æ“ä½œçš„è§’è‰²å¯¹è±¡
 * @param {boolean} isAuto - æ˜¯å¦ä¸ºè‡ªåŠ¨è§£å°
 */
async function deactivateAiBlock(character, isAuto = false) {
    character.isBlockedByAi = false;
    character.aiBlockTimestamp = null;
    character.blockEndTime = null;

    // [æ ¸å¿ƒä¿®æ­£] åˆ›å»ºæ­£ç¡®çš„ç³»ç»Ÿæç¤ºæ¶ˆæ¯
    const displayMessageContent = `[system-display:${character.remarkName} å·²å°†ä½ è§£é™¤æ‹‰é»‘ã€‚]`;
    const displayMessage = {
        id: `msg_ai_unblock_display_${Date.now()}`,
        role: 'system',
        content: displayMessageContent,
        parts: [],
        timestamp: Date.now()
    };

    const contextMessageContent = `[system: ä½ å·²å°† ${character.myName} è§£é™¤æ‹‰é»‘ã€‚${isAuto ? 'ï¼ˆæ ¹æ®é¢„è®¾æ—¶é—´è‡ªåŠ¨æ“ä½œï¼‰' : ''}]`;
    const contextMessage = {
        id: `msg_unblock_context_${Date.now()}`,
        role: 'user', // ä½œä¸ºç”¨æˆ·æ¶ˆæ¯ï¼Œç¡®ä¿AIèƒ½çœ‹åˆ°å¹¶æ®æ­¤å›åº”
        content: contextMessageContent,
        parts: [{ type: 'text', text: contextMessageContent }],
        timestamp: Date.now()
    };
    
    // å°†æ˜¾ç¤ºæ¶ˆæ¯å’Œä¸Šä¸‹æ–‡æ¶ˆæ¯éƒ½åŠ å…¥å†å²
    character.history.push(displayMessage, contextMessage);

    await saveData();

    if (character.id === currentChatId) {
        checkAndUpdateUiForAiBlock();
        // åˆ·æ–°æ•´ä¸ªèŠå¤©ç•Œé¢ä»¥æ­£ç¡®æ˜¾ç¤ºæ‰€æœ‰æ–°æ¶ˆæ¯
        renderMessages(false, true); 
        showToast(`${character.remarkName} å·²å°†ä½ è§£é™¤æ‹‰é»‘`);
    }
}
/**
 * å®šæ—¶å™¨ï¼Œç”¨äºæ£€æŸ¥å¹¶è‡ªåŠ¨è§£é™¤åˆ°æœŸçš„AIæ‹‰é»‘
 */
function checkTimedUnblocks() {
    const now = Date.now();
    db.characters.forEach(char => {
        if (char.isBlockedByAi && char.blockEndTime && now >= char.blockEndTime) {
            console.log(`è‡ªåŠ¨è§£é™¤å¯¹ ${char.remarkName} çš„æ‹‰é»‘...`);
            deactivateAiBlock(char, true);
        }
    });
}

// ===============================================================
// END: æ‹‰é»‘åŠŸèƒ½æ ¸å¿ƒä»£ç 
// ===============================================================
let isCheckingInactivity = false;

/**
 * Sets up the main timer for checking user inactivity across all chats.
 */
function setupProactiveAiSystem() {
    // Check every minute
    setInterval(checkAllChatsForInactivity, 60 * 1000);
    console.log("AIåå°å›å¤ç³»ç»Ÿå·²å¯åŠ¨ã€‚");
}

/**
 * Iterates through all chats and triggers proactive AI actions if conditions are met.
 */
// â–¼â–¼â–¼ ç¬¬äºŒæ­¥ï¼šå®Œæ•´æ›¿æ¢ checkAllChatsForInactivity å‡½æ•° (å¢åŠ éšæœºè§¦å‘æ¦‚ç‡) â–¼â–¼â–¼
async function checkAllChatsForInactivity() {
    if (isCheckingInactivity) {
        return;
    }
    isCheckingInactivity = true;
    // console.log("æ­£åœ¨æ£€æŸ¥ç”¨æˆ·ä¸æ´»è·ƒèŠå¤©...");
    const now = Date.now();
    const allChats = [
        ...db.characters.map(c => ({ chat: c, type: 'private' })),
        ...db.groups.map(g => ({ chat: g, type: 'group' }))
    ];

    for (const { chat, type } of allChats) {
        // æ£€æŸ¥æ­¤èŠå¤©çš„ç‹¬ç«‹è®¾ç½®
        if (!chat.aiProactiveChatEnabled || !chat.aiProactiveChatDelay ||
            chat.aiProactiveChatDelay <= 0) {
            continue; // å¦‚æœæ­¤èŠå¤©æœªå¼€å¯åå°å›å¤ï¼Œåˆ™è·³è¿‡
        }

        if (!chat.history || chat.history.length === 0) {
            continue; // è·³è¿‡ç©ºèŠå¤©
        }

        // æ‰¾åˆ°æœ€åä¸€æ¡æ¥è‡ªç”¨æˆ·çš„æ¶ˆæ¯
        const lastUserMessage = [...chat.history].reverse().find(m => m.role === 'user');
        
        // å¦‚æœæ²¡æœ‰ç”¨æˆ·æ¶ˆæ¯ï¼Œåˆ™æ— æ³•åˆ¤æ–­ä¸æ´»è·ƒçŠ¶æ€
        if (!lastUserMessage) {
            continue;
        }

        const timeSinceUserLastSpoke = now - lastUserMessage.timestamp;
        const initialDelayMs = chat.aiProactiveChatDelay * 60 * 1000;

        // å¦‚æœç”¨æˆ·ä¸æ´»è·ƒçš„æ—¶é—´å°šæœªè¾¾åˆ°åˆå§‹å»¶è¿Ÿï¼Œåˆ™è·³è¿‡
        if (timeSinceUserLastSpoke < initialDelayMs) {
            continue;
        }

        // æ­¤æ—¶ï¼Œç¡®è®¤ç”¨æˆ·å·²å¤„äºä¸æ´»è·ƒçŠ¶æ€ï¼Œç°åœ¨åˆ¤æ–­æ˜¯å¦åº”è¯¥å‘é€æ¶ˆæ¯
        const lastMessage = chat.history[chat.history.length - 1];
        const timeSinceLastMessage = now - lastMessage.timestamp;
        
        // å¦‚æœæœªè®¾ç½®é—´éš”ï¼Œåˆ™é»˜è®¤ä½¿ç”¨åˆå§‹å»¶è¿Ÿä½œä¸ºé—´éš”
        const intervalMs = (chat.aiProactiveChatInterval > 0 ? chat.aiProactiveChatInterval :
            chat.aiProactiveChatDelay) * 60 * 1000;

        // æ ¸å¿ƒåˆ¤æ–­é€»è¾‘
        if (lastMessage.role === 'user' || (lastMessage.role === 'assistant' &&
            timeSinceLastMessage > intervalMs)) {
            
            // === æ ¸å¿ƒä¿®æ”¹ï¼šåŠ å…¥â€œè‡ªä¸»å†³å®šâ€æ¦‚ç‡ (70% æ¦‚ç‡è§¦å‘) ===
            // æ¯æ¬¡æ£€æŸ¥ï¼ˆæ¯åˆ†é’Ÿï¼‰åªæœ‰ 70% çš„æ¦‚ç‡è§¦å‘ã€‚
            // è¿™æ„å‘³ç€ AI ä¸ä¼šåƒæœºå™¨äººä¸€æ ·å¡ç‚¹å›å¤ï¼Œè€Œæ˜¯ä¼šæœ‰éšæœºçš„â€œå»¶è¿Ÿæ„Ÿâ€å’Œâ€œçŠ¹è±«æ„Ÿâ€ã€‚
            if (Math.random() > 0.7) {
                console.log(`[æ‹ŸäººåŒ–] ${chat.remarkName || chat.name} å†³å®šæ­¤æ—¶æš‚ä¸æ‰“æ‰°ï¼Œç¨åå†çœ‹ã€‚`);
                continue; 
            }
            // === ä¿®æ”¹ç»“æŸ ===

            console.log(`æ£€æµ‹åˆ°ä¸æ´»è·ƒèŠå¤©: ${chat.name || chat.remarkName}ã€‚è§¦å‘ AI åå°å›å¤ã€‚`);
            
            if (type === 'private') {
                await triggerProactivePrivateReply(chat);
            } else {
                await triggerProactiveGroupReply(chat);
            }

            // ç­‰å¾… 5 ç§’ï¼Œé¿å…å¯¹ API é€ æˆè¿‡å¤§å‹åŠ›
            await new Promise(resolve => setTimeout(resolve, 5000));
        }
    }
    isCheckingInactivity = false;
}

/**
 * Triggers a proactive action for a private chat (either send a message or interact with a Moment).
 * @param {object} character - The character object for the private chat.
 */
async function triggerProactivePrivateReply(character) {
    // 30% chance to interact with a Moment, 70% chance to send a message
    if (Math.random() < 0.3 && window.AppDB_Moments) {
        const success = await triggerProactiveMomentInteraction(character);
        if (!success) {
            await triggerProactiveMessage(character, 'private');
        }
    } else {
        await triggerProactiveMessage(character, 'private');
    }
}

/**
 * Triggers a proactive message for a group chat.
 * @param {object} group - The group object.
 */
async function triggerProactiveGroupReply(group) {
    await triggerProactiveMessage(group, 'group');
}

/**
 * Generates and sends a proactive message from the AI.
 * @param {object} chatObject - The character or group object.
 * @param {string} type - 'private' or 'group'.
 */
// --- æ–°ä»£ç å¼€å§‹ ---

// --- æ–°ä»£ç å¼€å§‹ ---

// --- æ–°ä»£ç å¼€å§‹ ---
// â–¼â–¼â–¼ ç¬¬ä¸‰æ­¥ï¼šå®Œæ•´æ›¿æ¢ triggerProactiveMessage å‡½æ•° (æ³¨å…¥ç²¾å‡†æ—¶é—´æ„ŸçŸ¥) â–¼â–¼â–¼
async function triggerProactiveMessage(chatObject, type) {
    let systemPrompt = '';
    const now = Date.now();

    // === æ ¸å¿ƒä¿®æ”¹ï¼šæ„å»ºæ—¶é—´æ„ŸçŸ¥ä¿¡æ¯ ===
    let timeContext = "";
    
    // æ£€æŸ¥æ˜¯å¦å¼€å¯äº†â€œæ—¶é—´æ„ŸçŸ¥åŠ å¼ºâ€
    if (db.apiSettings && db.apiSettings.timePerceptionEnabled) {
        // 1. è·å–å½“å‰ç²¾ç¡®æ—¶é—´
        const nowDate = new Date();
        const weekDays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
        const currentTimeStr = `${nowDate.getFullYear()}å¹´${nowDate.getMonth() + 1}æœˆ${nowDate.getDate()}æ—¥ ${weekDays[nowDate.getDay()]} ${String(nowDate.getHours()).padStart(2, '0')}:${String(nowDate.getMinutes()).padStart(2, '0')}`;
        
        // 2. è®¡ç®—è·ç¦»ä¸Šæ¬¡ç”¨æˆ·å‘è¨€çš„æ—¶é—´å·®
        let timeGapStr = "ä¸€æ®µæ—¶é—´";
        const lastUserMsg = [...chatObject.history].reverse().find(m => m.role === 'user');
        if (lastUserMsg) {
            timeGapStr = formatTimeGap(now - lastUserMsg.timestamp);
        }

        // 3. ç»„åˆæˆæç¤ºè¯
        timeContext = `(é‡è¦å‚è€ƒä¿¡æ¯ï¼šå½“å‰ç°å®æ—¶é—´æ˜¯ ${currentTimeStr}ã€‚è·ç¦»ç”¨æˆ·ä¸Šä¸€æ¬¡å›å¤ä½ ï¼Œå·²ç»è¿‡å»äº† ${timeGapStr}ã€‚)`;
    }
    // === ä¿®æ”¹ç»“æŸ ===

    if (type === 'private') {
        systemPrompt = `[system: ç”¨æˆ· ${chatObject.myName} å·²ç»æœ‰æ®µæ—¶é—´æ²¡æœ‰å›å¤äº†ã€‚${timeContext}
è¯·ä½ æ ¹æ®è‡ªå·±çš„äººè®¾ã€å½“å‰çš„æ—¶é—´ç‚¹ä»¥åŠæˆ‘ä»¬ä¹‹å‰çš„å¯¹è¯ï¼Œä¸»åŠ¨å‘èµ·ä¸€ä¸ªæ–°çš„è¯é¢˜ï¼Œæˆ–è€…ç”¨è‡ªç„¶çš„æ–¹å¼è¯¢é—®å¯¹æ–¹æ­£åœ¨åšä»€ä¹ˆã€‚
**æ³¨æ„**ï¼šè¯·æ ¹æ®â€œè¿‡å»çš„æ—¶é—´é•¿çŸ­â€æ¥å†³å®šä½ çš„è¯­æ°”ã€‚å¦‚æœåªè¿‡äº†å‡ åˆ†é’Ÿï¼Œä¸è¦è¡¨ç°å¾—åƒè¿‡äº†å¥½å‡ å¹´ä¸€æ ·ï¼›å¦‚æœè¿‡äº†å¥½å‡ å¤©ï¼Œå¯ä»¥è¡¨ç°å¾—æ›´æ€å¿µæˆ–æ‹…å¿§ã€‚å›å¤å¿…é¡»è‡ªç„¶ï¼Œå°±åƒæ˜¯çœŸå®çš„äººåœ¨å¾®ä¿¡ä¸Šå‘æ¶ˆæ¯ä¸€æ ·ã€‚]`;
    } else { // group
        systemPrompt = `[system: ç”¨æˆ· ${chatObject.me.nickname} å·²ç»æœ‰æ®µæ—¶é—´æ²¡æœ‰åœ¨ç¾¤é‡Œè¯´è¯äº†ã€‚${timeContext}
è¯·ä½ ä»¬ï¼ˆAI æˆå‘˜ä»¬ï¼‰æ ¹æ®å„è‡ªçš„äººè®¾ï¼Œå¼€å§‹ä¸€æ®µè‡ªç„¶çš„ç¾¤èŠæ¥æ´»è·ƒæ°”æ°›ï¼Œæˆ–è€…å°è¯•æŠŠè¯é¢˜å¼•å‘ç”¨æˆ·æ„Ÿå…´è¶£çš„æ–¹å‘ã€‚]`;
    }

    const proactivePromptMessage = {
        id: `proactive_${now}`,
        role: 'user',
        content: systemPrompt,
        parts: [{ type: 'text', text: systemPrompt }],
        timestamp: now
    };

    if (type === 'group') {
        proactivePromptMessage.senderId = 'user_me';
    }

    chatObject.history.push(proactivePromptMessage);

    try {
        let fullSystemPrompt;
        let historyForApi;

        if (type === 'private') {
            fullSystemPrompt = generatePrivateSystemPrompt(chatObject);
            historyForApi = chatObject.history.slice(-chatObject.maxMemory);
        } else {
            fullSystemPrompt = generateGroupSystemPrompt(chatObject);
            historyForApi = chatObject.history.slice(-chatObject.maxMemory);
        }

        const messages = [
            { role: 'system', content: fullSystemPrompt },
            ...historyForApi.map(msg => ({ role: msg.role, content: msg.content }))
        ];

        const aiResponseText = await callAiApi(messages);

        // é‡è¦ï¼šåœ¨å¤„ç†å›å¤å‰ï¼Œå…ˆä»å†å²è®°å½•ä¸­ç§»é™¤æˆ‘ä»¬æ·»åŠ çš„ç³»ç»ŸæŒ‡ä»¤ï¼Œé¿å…æ±¡æŸ“å†å²
        chatObject.history.pop();

        const cleanedResponse = await processAiCommands(aiResponseText, chatObject);
        const messageRegex = /(\[[\s\S]*?\]|<div class="ai-theater"[\s\S]*?<\/div>)/g;
        let replies = cleanedResponse.match(messageRegex) || [];

        // ğŸ†• çº¿ä¸‹æ¨¡å¼ä¿åº•æœºåˆ¶ï¼šå¦‚æœæ­£åˆ™åŒ¹é…å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬
        if (replies.length === 0 && chatObject.isOfflineMode && cleanedResponse.trim().length > 0) {
             const fixedContent = `[${chatObject.realName}çš„æ¶ˆæ¯ï¼š${cleanedResponse.trim()}]`;
             replies = [fixedContent];
        }

        // ğŸ†• é¢å¤–ä¿åº•ï¼šå¦‚æœ cleanedResponse æœ‰å†…å®¹ä½† replies ä¸ºç©º
        if (replies.length === 0 && cleanedResponse.trim().length > 0) {
            console.warn('âš ï¸ [ä¸»åŠ¨èŠå¤©-æ¶ˆæ¯è§£æ] æ­£åˆ™åŒ¹é…å¤±è´¥ï¼Œå¯ç”¨ä¿åº•æœºåˆ¶ï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬');
            let fallbackContent = cleanedResponse.trim();
            if (fallbackContent.startsWith('[') && fallbackContent.endsWith(']')) {
                fallbackContent = fallbackContent.slice(1, -1);
            }
            const looseMatch = fallbackContent.match(/.*?[:ï¼š]\s*(.*)/s);
            if (looseMatch && looseMatch[1]) {
                const extractedText = looseMatch[1].trim();
                if (extractedText.length > 0) {
                    const roleName = chatObject.realName || chatObject.remarkName || 'AI';
                    replies = [`[${roleName}çš„æ¶ˆæ¯ï¼š${extractedText}]`];
                }
            } else {
                const roleName = chatObject.realName || chatObject.remarkName || 'AI';
                replies = [`[${roleName}çš„æ¶ˆæ¯ï¼š${fallbackContent}]`];
            }
        }

        if (replies.length > 0) {
            for (const replyContent of replies) {
                // ğŸ†• æå–å’ŒéªŒè¯æ¶ˆæ¯å†…å®¹ï¼ˆä¿åº•æœºåˆ¶ï¼‰
                let finalContent = replyContent.trim();
                
                // å°è¯•ç”¨å®½æ¾çš„æ­£åˆ™æå–å†…å®¹ï¼ˆæ”¯æŒä¸­è‹±æ–‡å†’å·ï¼Œå…è®¸ç©ºæ ¼ï¼‰
                const contentMatch = finalContent.match(/\[.*?[:ï¼š]\s*([\s\S]+?)\]/s);
                if (contentMatch && contentMatch[1] && contentMatch[1].trim().length > 0) {
                    const extractedText = contentMatch[1].trim();
                    const roleName = chatObject.realName || chatObject.remarkName || 'AI';
                    finalContent = `[${roleName}çš„æ¶ˆæ¯ï¼š${extractedText}]`;
                } else {
                    // ğŸš¨ å…³é”®ä¿åº•ï¼šæ­£åˆ™åŒ¹é…å¤±è´¥ï¼Œæ£€æŸ¥åŸå§‹å†…å®¹
                    if (finalContent.trim().length === 0) {
                        console.error('âŒ [ä¸»åŠ¨èŠå¤©-æ¶ˆæ¯è§£æ] æå–çš„å†…å®¹ä¸ºç©ºï¼Œè·³è¿‡æ­¤æ¶ˆæ¯');
                        continue;
                    }
                    let cleanedText = finalContent;
                    if (cleanedText.startsWith('[') && cleanedText.endsWith(']')) {
                        cleanedText = cleanedText.slice(1, -1).trim();
                    }
                    if (cleanedText.length > 0) {
                        const roleName = chatObject.realName || chatObject.remarkName || 'AI';
                        finalContent = `[${roleName}çš„æ¶ˆæ¯ï¼š${cleanedText}]`;
                        console.warn('âš ï¸ [ä¸»åŠ¨èŠå¤©-æ¶ˆæ¯è§£æ] æ ¼å¼ä¸åŒ¹é…ï¼Œä½¿ç”¨æ¸…ç†åçš„åŸå§‹æ–‡æœ¬');
                    } else {
                        console.error('âŒ [ä¸»åŠ¨èŠå¤©-æ¶ˆæ¯è§£æ] æ¸…ç†åå†…å®¹ä»ä¸ºç©ºï¼Œè·³è¿‡æ­¤æ¶ˆæ¯');
                        continue;
                    }
                }

                const message = {
                    id: `msg_proactive_${Date.now()}_${Math.random()}`,
                    role: 'assistant',
                    content: finalContent,
                    parts: [{ type: 'text', text: finalContent }],
                    timestamp: Date.now(),
                };

                if (type === 'group') {
                    // ğŸ†• æ”¾å®½æ­£åˆ™åŒ¹é…ï¼šæ”¯æŒä¸­è‹±æ–‡å†’å·
                    const nameMatch = message.content.match(/\[(.*?)(?:çš„æ¶ˆæ¯|çš„è¯­éŸ³|å‘é€çš„è¡¨æƒ…åŒ…|å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘)[:ï¼š]/);
                    if (nameMatch) {
                        const sender = chatObject.members.find(m => m.realName === nameMatch[1] || m.groupNickname === nameMatch[1]);
                        if (sender) {
                            message.senderId = sender.id;
                        }
                    }
                }
                chatObject.history.push(message);
            }

            await saveData();
            renderChatList();

            if (chatObject.id === currentChatId) {
                renderMessages(false, true);
            } else {
                addNotificationToQueue({
                    avatar: chatObject.avatar,
                    text: `<strong>${chatObject.name || chatObject.remarkName}</strong><br>ç»™ä½ å‘æ¥äº†ä¸€æ¡æ–°æ¶ˆæ¯...`,
                    chatId: chatObject.id,
                    type: type
                });
            }
        }

    } catch (error) {
        console.error(`AI åå°å›å¤å¤±è´¥ for ${chatObject.name || chatObject.remarkName}:`, error);
        chatObject.history.pop(); // å‡ºé”™ä¹Ÿè¦ç§»é™¤æŒ‡ä»¤
    }
}

// --- æ–°ä»£ç ç»“æŸ ---
// --- æ–°ä»£ç ç»“æŸ ---
/**
 * Triggers an AI to interact with a user's Moment.
 * @param {object} character - The character object that will perform the interaction.
 * @returns {boolean} - True if an interaction was successfully triggered, false otherwise.
 */
async function triggerProactiveMomentInteraction(character) {
    try {
        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';

        const allMoments = await window.AppDB_Moments.moments.toArray();
        const unInteractedMoments = allMoments.filter(m => 
            m.authorId === myId && 
            !m.likes.includes(character.id) && 
            !m.comments.some(c => c.roleId === character.id)
        );

        if (unInteractedMoments.length === 0) {
            console.log(`[åå°äº’åŠ¨] ${character.remarkName} æ‰¾ä¸åˆ°å¯ä»¥äº’åŠ¨çš„æ–°åŠ¨æ€ã€‚`);
            return false;
        }
        
        const momentToInteract = unInteractedMoments.sort((a,b) => b.timestamp - a.timestamp)[0];

        const prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${character.realName}â€ï¼ˆäººè®¾ï¼š${character.persona}ï¼‰ã€‚ä½ åˆšåˆšåœ¨â€œåŠ¨æ€â€é‡Œçœ‹åˆ°äº†ä½ çš„æœ‹å‹â€œ${character.myName}â€å‘å¸ƒçš„ä¸€æ¡æ–°å†…å®¹ï¼Œä½ è¿˜æ²¡æœ‰å’Œå®ƒäº’åŠ¨è¿‡ã€‚
        
# åŠ¨æ€å†…å®¹
- ä½œè€…: ${character.myName}
- æ–‡å­—: "${momentToInteract.text}"
- å›¾ç‰‡æè¿°(å¦‚æœ‰): "${momentToInteract.imageDesc || 'æ— '}"

# ä½ çš„ä»»åŠ¡
æ ¹æ®ä½ çš„äººè®¾å’ŒåŠ¨æ€å†…å®¹ï¼Œå†³å®šæ˜¯â€œç‚¹èµâ€è¿˜æ˜¯â€œè¯„è®ºâ€ã€‚

# è¾“å‡ºæ ¼å¼ (ä¸¥æ ¼éµå®ˆ)
- å¦‚æœå†³å®šç‚¹èµï¼Œä½ çš„å›å¤å¿…é¡»æ˜¯ä¸”ä»…æ˜¯ï¼š [${character.realName}ç‚¹èµåŠ¨æ€ï¼š{"momentId":"${momentToInteract.id}"}]
- å¦‚æœå†³å®šè¯„è®ºï¼Œä½ çš„å›å¤å¿…é¡»æ˜¯ä¸”ä»…æ˜¯ï¼š [${character.realName}è¯„è®ºåŠ¨æ€ï¼š{"momentId":"${momentToInteract.id}", "comment":"è¿™é‡Œæ˜¯ä½ çš„è¯„è®ºå†…å®¹"}]
- ç»å¯¹ä¸è¦å›å¤ä»»ä½•å…¶ä»–å†…å®¹ã€‚`;

        const messagesForApi = [{ role: 'user', content: prompt }];
        const aiResponseText = await callAiApi(messagesForApi);

        const likeRegex = /\[(.*?)ç‚¹èµåŠ¨æ€ï¼š({.*?})\]/;
        const commentRegex = /\[(.*?)è¯„è®ºåŠ¨æ€ï¼š({.*?})\]/;

        const likeMatch = aiResponseText.match(likeRegex);
        const commentMatch = aiResponseText.match(commentRegex);

        if (likeMatch) {
            const likeData = JSON.parse(likeMatch[2]);
            await saveMomentLike(likeData.momentId, character.id);
            addNotificationToQueue({
                avatar: character.avatar,
                text: `<strong>${character.remarkName}</strong> ç‚¹èµäº†ä½ çš„åŠ¨æ€`
            });
            console.log(`[åå°äº’åŠ¨] ${character.remarkName} ç‚¹èµäº†åŠ¨æ€ ${likeData.momentId}`);
            return true;
        } else if (commentMatch) {
            const commentData = JSON.parse(commentMatch[2]);
            await saveMomentComment(commentData.momentId, character.id, commentData.comment);
            addNotificationToQueue({
                avatar: character.avatar,
                text: `<strong>${character.remarkName}</strong> è¯„è®ºäº†ä½ çš„åŠ¨æ€: ${commentData.comment}`
            });
             console.log(`[åå°äº’åŠ¨] ${character.remarkName} è¯„è®ºäº†åŠ¨æ€ ${commentData.momentId}`);
            return true;
        } else {
            console.warn(`[åå°äº’åŠ¨] AIè¿”å›äº†æ— æ•ˆçš„äº’åŠ¨æŒ‡ä»¤: ${aiResponseText}`);
            return false;
        }
    } catch (error) {
        console.error("AIåå°åŠ¨æ€äº’åŠ¨å¤±è´¥:", error);
        return false;
    }
}
// â–¼â–¼â–¼ ã€å…¨æ–° | V2.0 é«˜çº§å°è£…ç‰ˆã€‘è¯·å°†è¿™ä¸ªå‡½æ•°ç²˜è´´åˆ°æ‚¨çš„JSåŠŸèƒ½åŒº â–¼â–¼â–¼

/**
 * [V2.0 | é«˜çº§å°è£…ç‰ˆ] åº”ç”¨æ‰€æœ‰åŒ¹é…çš„æ¸²æŸ“è§„åˆ™ï¼Œæ”¯æŒä¼˜å…ˆçº§å’Œé“¾å¼æ¸²æŸ“ã€‚
 * @param {string} rawContent - AIè¿”å›çš„åŸå§‹æ–‡æœ¬ã€‚
 * @param {string} chatId - å½“å‰èŠå¤©çš„IDï¼Œç”¨äºåŒ¹é…è§’è‰²ä¸“å±è§„åˆ™ã€‚
 * @param {string} messageRole - æ¶ˆæ¯çš„è§’è‰² ('user' æˆ– 'ai')ã€‚
 * @returns {Promise<object>} - è¿”å›ä¸€ä¸ªåŒ…å«æ¸²æŸ“ç»“æœçš„å¯¹è±¡ã€‚
 *   - { isRendered: true, html: 'å¤„ç†åçš„HTMLå­—ç¬¦ä¸²' }
 *   - { isRendered: false, text: 'åŸå§‹æ–‡æœ¬' }
 */
// â–¼â–¼â–¼ ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå®Œæ•´æ›¿æ¢æ‰æ—§çš„ applyAdvancedRenderingRules å‡½æ•° â–¼â–¼â–¼
function applyAdvancedRenderingRules(rawContent, chatId, messageRole) {
    if (rawContent.trim().startsWith('<') || (!rawContent.includes('[') && !rawContent.includes('{'))) {
        return { isRendered: false, text: rawContent };
    }

    const applicableRules = (db.renderers || [])
        .filter(r =>
            r.enabled &&
            (r.scope || ['ai']).includes(messageRole) &&
            (!r.characterIds || r.characterIds.length === 0 || r.characterIds.includes(chatId)) &&
            r.regex && r.html
        )
        .sort((a, b) => (b.priority || 50) - (a.priority || 50));

    if (applicableRules.length === 0) {
        return { isRendered: false, text: rawContent };
    }
    
    let processedContent = rawContent;
    let hasRendered = false;

    for (const rule of applicableRules) {
        try {
            if (rule.trimStrings && rule.trimStrings.length > 0) {
                rule.trimStrings.forEach(trimStr => {
                    processedContent = processedContent.replaceAll(trimStr, '');
                });
            }
            const flags = (rule.flags || ['g']).join('');
            const regex = new RegExp(rule.regex, flags);
            
            regex.lastIndex = 0;
            if (regex.test(processedContent)) {
                regex.lastIndex = 0;
                processedContent = processedContent.replace(regex, rule.html);
                hasRendered = true;
            }
        } catch (e) {
            console.error(`æ¸²æŸ“å™¨è§„åˆ™ "${rule.name}" æ‰§è¡Œå¤±è´¥:`, e);
            if (typeof showToast === 'function') {
                showToast(`æ¸²æŸ“å™¨è§„åˆ™ "${rule.name}" æ‰§è¡Œå¤±è´¥: æ­£åˆ™è¡¨è¾¾å¼é”™è¯¯ã€‚`);
            }
        }
    }
    
    if (hasRendered) {
        return { isRendered: true, html: processedContent };
    } else {
        return { isRendered: false, text: rawContent };
    }
}
// ===============================================================
// START: æ–°å¢AIç©ºé—´ (AIæ‰‹æœº) åŠŸèƒ½
// ===============================================================

// --- å…¨å±€å˜é‡ ---
let currentAiSpaceApp = null;
let currentAiForApp = null;
/**
 * [å·²æ›´æ–° V3.0] è®¾ç½®AIç©ºé—´æ‰€æœ‰Appçš„äº‹ä»¶ç›‘å¬å’Œæ ¸å¿ƒé€»è¾‘ (å·²é›†æˆéŸ³ä¹App)
 */
function setupAiSpaceApps() {
    document.querySelector('[data-target="ai-space-home-screen"]').addEventListener('click', renderAiSpaceHomeScreen);

    document.getElementById('ai-space-app-grid').addEventListener('click', (e) => {
        const appIcon = e.target.closest('.app-icon');
        if (!appIcon) return;
        const appId = appIcon.dataset.appId;
        currentAiSpaceApp = appId;

        // å¤„ç†PeekåŠŸèƒ½ï¼ˆç»Ÿä¸€åˆ° peek- å‰ç¼€ï¼‰
        if (appId.startsWith('peek-')) {
            openAiSpaceCharacterSelect(appId);
        } else {
            showToast('åŠŸèƒ½å¼€å‘ä¸­');
        }
    });

    document.getElementById('ai-space-select-list').addEventListener('click', (e) => {
        const charItem = e.target.closest('.list-item');
        if (!charItem || !charItem.dataset.id) return;
        currentAiForApp = db.characters.find(c => c.id === charItem.dataset.id);
        if (!currentAiForApp) return;
        currentAiForApp.aiSpaceData = currentAiForApp.aiSpaceData || {};

        // å¤„ç†PeekåŠŸèƒ½ï¼ˆç»Ÿä¸€åˆ° peek- å‰ç¼€ï¼‰
        if (currentAiSpaceApp.startsWith('peek-')) {
            const peekType = currentAiSpaceApp.replace('peek-', '');
            generateAndRenderPeekContent(peekType, currentAiForApp);
        }
    });

    setupPeekFeatureHandlers(); // è®¾ç½®PeekåŠŸèƒ½çš„äº‹ä»¶ç›‘å¬ï¼ˆåŒ…æ‹¬signalå’Œmusicï¼‰
}

function renderAiSpaceHomeScreen() {
    const grid = document.getElementById('ai-space-app-grid');
    grid.innerHTML = '';
    
    // ä¿®æ”¹ï¼šåªä¿ç•™IDåˆ—è¡¨ï¼Œä¸å†ç¡¬ç¼–ç å›¾æ ‡URLå’Œåç§°
    // æ–°å¢ï¼š9ä¸ªPeekåŠŸèƒ½ï¼ˆå…¨éƒ¨ç»Ÿä¸€åˆ° peek- å‰ç¼€ï¼‰
    const appIds = [
        'ai-space-peek-messages', 'ai-space-peek-memos', 'ai-space-peek-cart',
        'ai-space-peek-transfer', 'ai-space-peek-browser', 'ai-space-peek-album',
        'ai-space-peek-unlock', 'ai-space-peek-signal', 'ai-space-peek-music'
    ];

    appIds.forEach(appId => {
        // æ–°å¢ï¼šä»ä¸­å¤®å›¾æ ‡åº“è¯»å–æ•°æ®
        const defaultAppInfo = defaultIcons[appId];
        const customIconUrl = db.customIcons[appId];
        const finalIconUrl = customIconUrl || defaultAppInfo.icon;
        const appName = defaultAppInfo.name;
        // appId é‡Œçš„ 'ai-space-' å‰ç¼€åªæ˜¯ä¸ºäº†åŒºåˆ†ï¼Œå®é™…åŠŸèƒ½IDä¸éœ€è¦è¿™ä¸ªå‰ç¼€
        const functionalAppId = appId.replace('ai-space-', ''); 

        const iconEl = document.createElement('a');
        iconEl.href = '#';
        iconEl.className = 'app-icon';
        iconEl.dataset.appId = functionalAppId; // ä½¿ç”¨ä¸å¸¦å‰ç¼€çš„IDæ¥è§¦å‘åŠŸèƒ½
        iconEl.innerHTML = `
            <img src="${finalIconUrl}" alt="${appName}" class="icon-img">
            <span class="app-name">${appName}</span>
        `;
        grid.appendChild(iconEl);
    });
}
/**
 * [å·²æ›´æ–° V3.0] æ‰“å¼€é€šç”¨çš„AIé€‰æ‹©åˆ—è¡¨é¡µé¢
 */
function openAiSpaceCharacterSelect(appName) {
    const titles = {
        'peek-messages': 'æŸ¥çœ‹è°çš„æ¶ˆæ¯',
        'peek-memos': 'æŸ¥çœ‹è°çš„å¤‡å¿˜å½•',
        'peek-cart': 'æŸ¥çœ‹è°çš„è´­ç‰©è½¦',
        'peek-transfer': 'æŸ¥çœ‹è°çš„ä¸­è½¬ç«™',
        'peek-browser': 'æŸ¥çœ‹è°çš„æµè§ˆå™¨',
        'peek-album': 'æŸ¥çœ‹è°çš„ç›¸å†Œ',
        'peek-unlock': 'æŸ¥çœ‹è°çš„å°å·',
        'peek-signal': 'é€‰æ‹©å¿ƒåŠ¨å¯¹è±¡',
        'peek-music': 'å¬è°çš„æ­Œå•'
    };
    document.getElementById('ai-space-select-title').textContent = titles[appName] || 'é€‰æ‹©AI';
    
    const list = document.getElementById('ai-space-select-list');
    list.innerHTML = '';

    db.characters.forEach(char => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.dataset.id = char.id;
        li.innerHTML = `
            <img src="${char.avatar}" class="chat-avatar">
            <div class="item-details">
                <div class="item-name">${char.remarkName}</div>
            </div>
        `;
        list.appendChild(li);
    });
    
    switchScreen('ai-space-character-select-screen');
}


// --- å¿ƒåŠ¨è®¯å·æ¸²æŸ“å‡½æ•° (ä¿ç•™) ---
function renderAiHeartSignal(signal) {
    const contentEl = document.getElementById('ai-signal-content');
    contentEl.innerHTML = `
        <details>
            <summary style="font-weight: bold; color: var(--secondary-color); cursor: pointer; font-size: 16px;">å¿ƒåŠ¨ç¬é—´</summary>
            <p style="padding-top: 10px;">${signal.moment}</p>
        </details>
        <hr style="border: none; border-top: 1px solid #f0f0f0; margin: 15px 0;">
        <details>
            <summary style="font-weight: bold; color: var(--secondary-color); cursor: pointer; font-size: 16px;">å†…å¿ƒæƒ³æ³•</summary>
            <p style="padding-top: 10px; font-style: italic; color: #555;">â€œ${signal.thoughts}â€</p>
        </details>
    `;
}

// --- éŸ³ä¹æ­Œå•æ¸²æŸ“å‡½æ•° (ä¿ç•™) ---
/**
 * [å·²æ›´æ–° V3.0] æ¸²æŸ“AIçš„æ­Œå•åˆ—è¡¨ (å¢åŠ ç‚¹å‡»æ’­æ”¾åŠŸèƒ½)
 */
function renderAiMusicPlaylist(playlist) {
    const list = document.getElementById('ai-music-playlist-list');
    list.innerHTML = '';
    playlist.forEach((song, index) => {
        const li = document.createElement('li');
        li.className = 'list-item';
        li.style.cursor = 'pointer'; // è®©åˆ—è¡¨é¡¹çœ‹èµ·æ¥å¯ä»¥ç‚¹å‡»

        li.innerHTML = `
            <div class="item-details">
                <div class="item-name">${song.title}</div>
                <div class="item-preview">${song.artist}</div>
            </div>
        `;

        // --- æ ¸å¿ƒæ–°å¢ï¼šä¸ºæ¯ä¸ªåˆ—è¡¨é¡¹æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬ ---
        li.addEventListener('click', async () => {
            // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„æ’­æ”¾é€»è¾‘ï¼Œå®ƒä¼šå°è¯•å°†AIæ­Œå•çš„æ­Œæ›²æ·»åŠ åˆ°ä¸»æ’­æ”¾å™¨å¹¶æ’­æ”¾
            // å‡è®¾AIç”Ÿæˆçš„æ­Œæ›²åå’Œè‰ºæœ¯å®¶æ˜¯å‡†ç¡®çš„
            
            // 1. æ£€æŸ¥ä¸»æ’­æ”¾åˆ—è¡¨ï¼ˆdb.playlistï¼‰ä¸­æ˜¯å¦å·²å­˜åœ¨è¿™é¦–æ­Œ
            let existingSong = db.playlist.find(s => s.name === song.title && s.artist === song.artist);

            if (existingSong) {
                // å¦‚æœå·²å­˜åœ¨ï¼Œç›´æ¥æ‰¾åˆ°å®ƒçš„ç´¢å¼•å¹¶æ’­æ”¾
                const songIndex = db.playlist.indexOf(existingSong);
                if (typeof playSong === 'function') {
                    playSong(songIndex);
                }
                showToast(`æ­£åœ¨æ’­æ”¾ ${song.title}`);
            } else {
                // å¦‚æœä¸å­˜åœ¨ï¼Œæç¤ºç”¨æˆ·éœ€è¦æ‰‹åŠ¨æ·»åŠ 
                showToast(`æ­Œå•ä¸­æ²¡æœ‰æ‰¾åˆ°ã€Š${song.title}ã€‹çš„éŸ³æºï¼Œè¯·åœ¨ä¸»æ’­æ”¾å™¨ä¸­æ‰‹åŠ¨æ·»åŠ ã€‚`);
                // ï¼ˆé«˜çº§åŠŸèƒ½ï¼šæœªæ¥å¯ä»¥æ‰©å±•æ­¤å¤„ï¼Œè°ƒç”¨APIæœç´¢éŸ³ä¹å¹¶è‡ªåŠ¨æ·»åŠ ï¼‰
            }

            // æ‰“å¼€ä¸»éŸ³ä¹æ’­æ”¾å™¨å¼¹çª—
            const musicModal = document.getElementById('music-player-modal');
            if (musicModal) {
                musicModal.classList.add('visible');
            }
        });
        // --- æ–°å¢é€»è¾‘ç»“æŸ ---

        list.appendChild(li);
    });
}

// ===============================================================
// START: Peek æ‰‹æœºåŠŸèƒ½ (ç§»æ¤è‡ª reference_UwU.html)
// ===============================================================

// ç”¨äºå­˜å‚¨æ­£åœ¨ç”Ÿæˆçš„åº”ç”¨ç±»å‹ï¼Œé¿å…é‡å¤ç‚¹å‡»
const generatingPeekApps = new Set();

/**
 * ç”Ÿæˆ Peek å†…å®¹çš„ Prompt
 */
function generatePeekContentPrompt(char, appType, mainChatContext) {
    const appNameMapping = {
        messages: "æ¶ˆæ¯åº”ç”¨ï¼ˆæ¨¡æ‹Ÿä¸ä»–äººçš„å¯¹è¯ï¼‰",
        memos: "å¤‡å¿˜å½•åº”ç”¨",
        cart: "ç”µå•†å¹³å°çš„è´­ç‰©è½¦",
        transfer: "æ–‡ä»¶ä¼ è¾“åŠ©æ‰‹ï¼ˆç”¨äºè®°å½•ä¸´æ—¶æƒ³æ³•ã€é“¾æ¥ç­‰ï¼‰",
        browser: "æµè§ˆå™¨å†å²è®°å½•",
        album: "ç›¸å†Œ"
    };
    const appName = appNameMapping[appType] || appType;

    let prompt = `ä½ æ­£åœ¨æ¨¡æ‹Ÿä¸€ä¸ªåä¸º ${char.realName} çš„è§’è‰²çš„æ‰‹æœºå†…éƒ¨ä¿¡æ¯ã€‚`;
    prompt += `è¯¥è§’è‰²çš„æ ¸å¿ƒäººè®¾æ˜¯ï¼š${char.persona}ã€‚\n`;

    // è·å–å¹¶æ³¨å…¥ä¸–ç•Œä¹¦å’Œç”¨æˆ·äººè®¾
    const associatedWorldBooks = (char.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id)).filter(Boolean);
    if (associatedWorldBooks.length > 0) {
        const worldBookContext = associatedWorldBooks.map(wb => `è®¾å®šå: ${wb.name}\nå†…å®¹: ${wb.content}`).join('\n\n');
        prompt += `\nä¸ºäº†æ›´å¥½åœ°ç†è§£èƒŒæ™¯ï¼Œè¯·å‚è€ƒä»¥ä¸‹ä¸–ç•Œè§‚è®¾å®šï¼š\n---\n${worldBookContext}\n---\n`;
    }
    if (char.myPersona) {
        prompt += `\nä½œä¸ºå‚è€ƒï¼Œæˆ‘ï¼ˆç”¨æˆ·ï¼‰çš„äººè®¾æ˜¯ï¼š${char.myPersona}\n`;
    }

    prompt += `æœ€è¿‘ï¼Œæˆ‘ï¼ˆç§°å‘¼ä¸º ${char.myName}ï¼‰å’Œ ${char.realName} çš„å¯¹è¯å¦‚ä¸‹ï¼ˆè¿™æ˜¯ä½ ä»¬å…³ç³»å’Œå½“å‰çŠ¶æ€çš„æ ¸å¿ƒå‚è€ƒï¼‰ï¼š\n---\n${mainChatContext}\n---\n`;
    prompt += `ç°åœ¨ï¼Œæˆ‘æ­£åœ¨å·çœ‹Taæ‰‹æœºä¸Šçš„"${appName}"ã€‚è¯·ä½ åŸºäºTaçš„äººè®¾å’Œæˆ‘ä»¬æœ€è¿‘çš„èŠå¤©å†…å®¹ï¼Œç”Ÿæˆç¬¦åˆè¯¥åº”ç”¨åœºæ™¯çš„ã€é«˜åº¦ç›¸å…³ä¸”å¯Œæœ‰æ²‰æµ¸æ„Ÿçš„å†…å®¹ã€‚\n`;
    prompt += `ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸€ä¸ªJSONå¯¹è±¡ï¼Œä¸”åªåŒ…å«JSONå†…å®¹ï¼Œä¸è¦æœ‰ä»»ä½•é¢å¤–çš„è§£é‡Šæˆ–æ ‡è®°ã€‚æ ¹æ®åº”ç”¨ç±»å‹ï¼ŒJSONç»“æ„å¦‚ä¸‹ï¼š\n`;

    switch (appType) {
        case 'messages':
            prompt += `
            {
              "conversations": [
                {
                  "partnerName": "ä¸Taå¯¹è¯çš„äººçš„ç§°å‘¼",
                  "history": [
                    { "sender": "char", "content": "${char.realName}å‘é€çš„æ¶ˆæ¯å†…å®¹" },
                    { "sender": "partner", "content": "å¯¹æ–¹å‘é€çš„æ¶ˆæ¯å†…å®¹" }
                  ]
                }
              ]
           }
           è¯·ä¸º ${char.realName} ç¼–é€ 5-7ä¸ªæœ€è¿‘çš„å¯¹è¯ã€‚å¯¹è¯å†…å®¹éœ€è¦å¼ºçƒˆåæ˜ Taçš„äººè®¾ä»¥åŠå’Œæˆ‘çš„èŠå¤©ä¸Šä¸‹æ–‡ã€‚`;
            break;
        case 'album':
            prompt += `
            {
              "photos": [
                { "type": "photo", "imageDescription": "å¯¹ä¸€å¼ ç…§ç‰‡çš„è¯¦ç»†æ–‡å­—æè¿°ï¼Œä¾‹å¦‚ï¼šä¸€å¼ å‚æ™šåœ¨æµ·è¾¹çš„è‡ªæ‹ï¼ŒèƒŒæ™¯æ˜¯æ©™è‰²çš„æ™šéœå’Œå½’æ¥çš„æ¸”èˆ¹ã€‚", "description": "è§’è‰²å¯¹è¿™å¼ ç…§ç‰‡çš„ä¸€å¥è¯æ‰¹æ³¨ï¼Œä¾‹å¦‚ï¼šé‚£å¤©çš„é£å¾ˆèˆ’æœã€‚" },
                { "type": "video", "imageDescription": "å¯¹ä¸€æ®µè§†é¢‘çš„è¯¦ç»†æ–‡å­—æè¿°ï¼Œä¾‹å¦‚ï¼šä¸€æ®µåœ¨çŒ«å’–æ’¸çŒ«çš„è§†é¢‘ï¼Œè§†é¢‘é‡Œæœ‰ä¸€åªæ©˜çŒ«åœ¨æ‰“å“ˆæ¬ ã€‚", "description": "è§’è‰²å¯¹è¿™æ®µè§†é¢‘çš„ä¸€å¥è¯æ‰¹æ³¨ï¼Œä¾‹å¦‚ï¼šä¸‹æ¬¡è¿˜æ¥è¿™é‡Œï¼" }
              ]
            }
            è¯·ä¸º ${char.realName} çš„ç›¸å†Œç”Ÿæˆ8-10ä¸ªæ¡ç›®ï¼ˆç…§ç‰‡æˆ–è§†é¢‘ï¼‰ã€‚å†…å®¹éœ€è¦ä¸Taçš„äººè®¾å’Œæˆ‘ä»¬çš„èŠå¤©ä¸Šä¸‹æ–‡é«˜åº¦ç›¸å…³ã€‚'imageDescription' æ˜¯å¯¹è¿™å¼ ç…§ç‰‡/è§†é¢‘çš„è¯¦ç»†æ–‡å­—æè¿°ï¼Œå®ƒå°†ä»£æ›¿çœŸå®çš„å›¾ç‰‡å±•ç¤ºç»™ç”¨æˆ·ã€‚'description' æ˜¯ ${char.realName} è‡ªå·±å¯¹è¿™å¼ ç…§ç‰‡/è§†é¢‘çš„ä¸€å¥è¯æ‰¹æ³¨ï¼Œä¼šæ˜¾ç¤ºåœ¨æè¿°ä¸‹æ–¹ã€‚`;
            break;
        case 'memos':
            prompt += `
            {
              "memos": [
                { "id": "memo_1", "title": "å¤‡å¿˜å½•æ ‡é¢˜", "content": "å¤‡å¿˜å½•å†…å®¹ï¼Œå¯ä»¥åŒ…å«æ¢è¡Œç¬¦\\n" }
              ]
            }
            è¯·ç”Ÿæˆ6-10æ¡å¤‡å¿˜å½•ï¼Œå†…å®¹è¦ä¸Taçš„äººè®¾å’Œæˆ‘ä»¬çš„èŠå¤©ä¸Šä¸‹æ–‡ç›¸å…³ã€‚`;
            break;
        case 'cart':
            prompt += `
            {
              "items": [
                { "id": "cart_1", "title": "å•†å“æ ‡é¢˜", "spec": "å•†å“è§„æ ¼", "price": "25.00" }
              ]
            }
            è¯·ç”Ÿæˆ5-8ä»¶å•†å“ï¼Œè¿™äº›å•†å“åº”è¯¥åæ˜ Taçš„å…´è¶£ã€éœ€æ±‚æˆ–æˆ‘ä»¬æœ€è¿‘èŠåˆ°çš„è¯é¢˜ã€‚`;
            break;
        case 'browser':
            prompt += `
            {
              "history": [
                { "title": "ç½‘é¡µæ ‡é¢˜", "url": "example.com/path", "annotation": "è§’è‰²å¯¹äºè¿™æ¡æµè§ˆè®°å½•çš„æƒ³æ³•æˆ–æ‰¹æ³¨" }
              ]
            }
            è¯·ç”Ÿæˆ5-8æ¡æµè§ˆè®°å½•ã€‚è®°å½•æœ¬èº«è¦ç¬¦åˆTaçš„äººè®¾å’Œæˆ‘ä»¬çš„èŠå¤©ä¸Šä¸‹æ–‡ï¼Œ'annotation'å­—æ®µåˆ™è¦ç«™åœ¨è§’è‰²è‡ªå·±çš„è§†è§’ï¼Œè®°å½•Taå¯¹è¿™æ¡æµè§ˆè®°å½•çš„æƒ³æ³•æˆ–æ‰¹æ³¨ã€‚`;
            break;
       case 'transfer':
           prompt += `
           {
             "entries": [
               "è¦è®°å¾—ä¹°ç‰›å¥¶ã€‚",
               "https://example.com/interesting-article",
               "åˆšåˆšé‚£ä¸ªæƒ³æ³•ä¸é”™ï¼Œå¯ä»¥æ·±å…¥ä¸€ä¸‹..."
             ]
           }
           è¯·ä¸º ${char.realName} ç”Ÿæˆ5-8æ¡Taå‘é€ç»™è‡ªå·±çš„ã€ç®€çŸ­é›¶ç¢çš„æ¶ˆæ¯ã€‚è¿™äº›å†…å®¹åº”è¯¥åƒæ˜¯Taçš„ä¸´æ—¶å¤‡å¿˜ã€çµæ„Ÿé—ªç°æˆ–éšæ‰‹ä¿å­˜çš„é“¾æ¥ï¼Œè¦ä¸Taçš„äººè®¾å’Œæˆ‘ä»¬çš„èŠå¤©ä¸Šä¸‹æ–‡ç›¸å…³ï¼Œä½†æ¯”"å¤‡å¿˜å½•"åº”ç”¨çš„å†…å®¹æ›´éšæ„ã€æ›´å£è¯­åŒ–ã€‚`;
           break;
        case 'unlock':
            prompt += `
            {
              "nickname": "è§’è‰²çš„å¾®åšæ˜µç§°",
              "handle": "@è§’è‰²çš„å¾®åšID",
              "bio": "è§’è‰²çš„ä¸ªæ€§ç­¾åï¼Œå¯ä»¥åŒ…å«æ¢è¡Œç¬¦\\n",
              "posts": [
                { "timestamp": "2å°æ—¶å‰", "content": "ç¬¬ä¸€æ¡å¾®åšæ­£æ–‡å†…å®¹ï¼Œ140å­—ä»¥å†…ã€‚" },
                { "timestamp": "æ˜¨å¤©", "content": "ç¬¬äºŒæ¡å¾®åšæ­£æ–‡å†…å®¹ã€‚" },
                { "timestamp": "3å¤©å‰", "content": "ç¬¬ä¸‰æ¡å¾®åšæ­£æ–‡å†…å®¹ã€‚" }
              ]
            }
            è¯·ä¸º ${char.realName} ç”Ÿæˆä¸€ä¸ªç¬¦åˆå…¶äººè®¾çš„å¾®åšå°å·ã€‚ä½ éœ€è¦ç”Ÿæˆæ˜µç§°ã€IDã€ä¸ªæ€§ç­¾åï¼Œä»¥åŠ4-6æ¡æœ€è¿‘çš„å¾®åšã€‚å¾®åšå†…å®¹è¦ç”Ÿæ´»åŒ–ã€ç¢ç‰‡åŒ–ï¼Œç¬¦åˆå°å·çš„é£æ ¼ï¼Œå¹¶ä¸Taçš„äººè®¾å’Œæˆ‘ä»¬çš„èŠå¤©ä¸Šä¸‹æ–‡é«˜åº¦ç›¸å…³ã€‚`;
            break;

            case 'signal':
            prompt += `
            ç°åœ¨ï¼Œæˆ‘ï¼ˆ${char.myName}ï¼‰æ­£åœ¨æŸ¥çœ‹ä½ çš„"å¿ƒåŠ¨è®¯å·"åº”ç”¨ã€‚
            è¯·æ ¹æ®ä½ çš„äººè®¾ä»¥åŠæˆ‘ä»¬**æœ€è¿‘çš„èŠå¤©å†…å®¹**ï¼Œå›å¿†ä¸€ä¸ªæœ€è¿‘è®©ä½ å¯¹æˆ‘æ„Ÿåˆ°å¿ƒåŠ¨çš„ç¬é—´ã€‚
            
            è§„åˆ™:
            1. "å¿ƒåŠ¨ç¬é—´"æ˜¯å¯¹ä¸€ä¸ªå…·ä½“äº‹ä»¶çš„æè¿°ï¼Œè¦ç”ŸåŠ¨ã€æœ‰ç”»é¢æ„Ÿã€‚
            2. "å†…å¿ƒæƒ³æ³•"æ˜¯ç¬¬ä¸€äººç§°çš„å¿ƒç†æ´»åŠ¨ï¼Œè¦æ·±åˆ»ä½“ç°ä½ çš„æ€§æ ¼å’Œæƒ…æ„Ÿã€‚
            3. ä¸¤æ®µå†…å®¹åˆè®¡å­—æ•°ä¸å¾—å°‘äº200å­—ã€‚
            4. ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€‚

            JSONæ ¼å¼ç¤ºä¾‹:
            {
              "moment": "æè¿°...",
              "thoughts": "æƒ³æ³•..."
            }`;
            break;

        case 'music':
            prompt += `
            ç°åœ¨ï¼Œæˆ‘ï¼ˆ${char.myName}ï¼‰æ­£åœ¨æŸ¥çœ‹ä½ çš„"éŸ³ä¹æ­Œå•"ã€‚
            è¯·æ ¹æ®ä½ çš„äººè®¾ã€æ€§æ ¼å’Œæœ€è¿‘çš„å¿ƒæƒ…ï¼ˆå‚è€ƒèŠå¤©ä¸Šä¸‹æ–‡ï¼‰ï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å«5-8é¦–æ­Œæ›²çš„ç§äººæ­Œå•ã€‚
            
            è§„åˆ™:
            1. æ­Œå•çš„é€‰æ›²é£æ ¼å¿…é¡»**éå¸¸è´´åˆä½ çš„äººè®¾**ã€‚
            2. æ¯é¦–æ­Œéœ€è¦åŒ…å«"title"(æ­Œå)å’Œ"artist"(è‰ºæœ¯å®¶)ã€‚
            3. ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ•°ç»„æ ¼å¼ã€‚

            JSONæ ¼å¼ç¤ºä¾‹:
            [
              {"title": "å¤œæ›²", "artist": "å‘¨æ°ä¼¦"},
              {"title": "Summertime Sadness", "artist": "Lana Del Rey"}
            ]`;
            break;

        default:
            prompt += `{"error": "Unknown app type"}`;
            break;
    }
    return prompt;
}

/**
 * ç”Ÿæˆå¹¶æ¸²æŸ“ Peek å†…å®¹
 */
async function generateAndRenderPeekContent(appType, char, options = {}) {
    const { forceRefresh = false } = options;

    if (generatingPeekApps.has(appType)) {
        showToast('è¯¥åº”ç”¨å†…å®¹æ­£åœ¨ç”Ÿæˆä¸­ï¼Œè¯·ç¨å€™...');
        return;
    }

    if (!char) {
        showToast('æ— æ³•æ‰¾åˆ°å½“å‰è§’è‰²');
        return;
    }
    
    // ç¡®ä¿ peekData å­˜åœ¨
    if (!char.peekData) char.peekData = {};

    // æ£€æŸ¥æ˜¯å¦æœ‰æŒä¹…åŒ–å­˜å‚¨çš„æ•°æ® (ä¼˜å…ˆä½¿ç”¨å­˜å‚¨çš„æ•°æ®)
    if (!forceRefresh && char.peekData[appType]) {
        const cachedData = char.peekData[appType];
        // ç›´æ¥æ¸²æŸ“å­˜å‚¨çš„æ•°æ®
        switch (appType) {
            case 'messages':
                renderPeekChatList(cachedData.conversations);
                switchScreen('peek-messages-screen');
                break;
            case 'album':
                renderPeekAlbum(cachedData.photos);
                switchScreen('peek-album-screen');
                break;
            case 'memos':
                renderMemosList(cachedData.memos, char);
                switchScreen('peek-memos-screen');
                break;
           case 'transfer':
               renderPeekTransferStation(cachedData.entries);
               switchScreen('peek-transfer-station-screen');
               break;
            case 'cart':
                renderPeekCart(cachedData.items);
                switchScreen('peek-cart-screen');
                break;
            case 'browser':
                renderPeekBrowser(cachedData.history);
                switchScreen('peek-browser-screen');
                break;
           case 'unlock':
               renderPeekUnlock(cachedData, char);
               switchScreen('peek-unlock-screen');
               break;
           case 'signal':
               document.getElementById('ai-signal-title').textContent = `${char.remarkName}çš„å¿ƒåŠ¨è®¯å·`;
               renderAiHeartSignal(cachedData);
               switchScreen('ai-space-signal-screen');
               break;
           case 'music':
               document.getElementById('ai-music-playlist-title').textContent = `${char.remarkName}çš„æ­Œå•`;
               renderAiMusicPlaylist(cachedData);
               switchScreen('ai-space-music-screen');
               break;
       }
       return; // ä½¿ç”¨äº†å­˜å‚¨æ•°æ®ï¼Œç›´æ¥ç»“æŸ
    }

    // å¦‚æœæ²¡æœ‰æ•°æ®æˆ–å¼ºåˆ¶åˆ·æ–°ï¼Œåˆ™è°ƒç”¨ API ç”Ÿæˆ
    const { url, key, model, provider } = db.apiSettings;
    if (!url || !key || !model) {
        showToast('è¯·å…ˆåœ¨"api"åº”ç”¨ä¸­å®Œæˆè®¾ç½®ï¼');
        return switchScreen('api-settings-screen');
    }

    generatingPeekApps.add(appType); // é”å®šé˜²æ­¢é‡å¤ç‚¹å‡»
    let targetContainer;

    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    switch (appType) {
        case 'messages':
            switchScreen('peek-messages-screen');
            targetContainer = document.getElementById('peek-chat-list-container');
            targetContainer.innerHTML = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆå¯¹è¯åˆ—è¡¨...</p>';
            break;
        case 'album':
            switchScreen('peek-album-screen');
            renderPeekAlbum([]); 
            break;
        case 'memos':
            switchScreen('peek-memos-screen');
            renderMemosList([], char); 
            break;
       case 'transfer':
           switchScreen('peek-transfer-station-screen');
           renderPeekTransferStation([]);
           break;
        case 'cart':
            switchScreen('peek-cart-screen');
            renderPeekCart([]);
            break;
        case 'browser':
            switchScreen('peek-browser-screen');
            renderPeekBrowser([]);
            break;
       case 'unlock':
           switchScreen('peek-unlock-screen');
           renderPeekUnlock(null, char); 
           break;
       case 'signal':
           switchScreen('ai-space-signal-screen');
           document.getElementById('ai-signal-title').textContent = `${char.remarkName}çš„å¿ƒåŠ¨è®¯å·`;
           document.getElementById('ai-signal-content').innerHTML = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆå¿ƒåŠ¨ç¬é—´...</p>';
           break;
       case 'music':
           switchScreen('ai-space-music-screen');
           document.getElementById('ai-music-playlist-title').textContent = `${char.remarkName}çš„æ­Œå•`;
           document.getElementById('ai-music-playlist-list').innerHTML = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆæ­Œå•...</p>';
           break;
       default:
           showToast('æ— æ³•æ‰“å¼€');
           generatingPeekApps.delete(appType); 
           return;
   }

    try {
        const mainChatContext = char.history.slice(-10).map(m => m.content).join('\n');
        const systemPrompt = generatePeekContentPrompt(char, appType, mainChatContext);
        
        const requestBody = {
            model: model,
            messages: [{ role: 'user', content: systemPrompt }],
            temperature: 0.8,
            top_p: 0.9,
        };

        const endpoint = `${url}/v1/chat/completions`;
        const headers = { 'Content-Type': 'application/json', Authorization: `Bearer ${key}` };

        const response = await fetch(endpoint, { method: 'POST', headers: headers, body: JSON.stringify(requestBody) });
        if (!response.ok) {
            const error = new Error(`API Error: ${response.status} ${await response.text()}`);
            error.response = response;
            throw error;
        }
        
        const result = await response.json();
        let contentStr = result.choices[0].message.content;
        
        console.log(`[${appType}] AIåŸå§‹è¿”å›:`, contentStr); // æ–¹ä¾¿è°ƒè¯•

        // --- æ ¸å¿ƒä¿®å¤ï¼šç²¾å‡†åŒºåˆ†æ•°ç»„å’Œå¯¹è±¡ ---
        let jsonStr = null;

        // 1. å…ˆå»é™¤ Markdown ä»£ç å—æ ‡è®° (```json ... ```)
        contentStr = contentStr.replace(/```json/g, '').replace(/```/g, '').trim();

        // 2. æ ¹æ®åº”ç”¨ç±»å‹ï¼Œå†³å®šæ˜¯æ‰¾ [] è¿˜æ˜¯ {}
        if (appType === 'music') {
            // ç‰¹ä¾‹ï¼šåªæœ‰éŸ³ä¹æ˜¯çº¯æ•°ç»„ï¼Œæ‰¾è¢« [] åŒ…è£¹çš„å†…å®¹
            const arrayMatch = contentStr.match(/\[[\s\S]*\]/);
            if (arrayMatch) jsonStr = arrayMatch[0];
        } else {
            // é€šç”¨ï¼šå¤‡å¿˜å½•ã€æ¶ˆæ¯ã€å¿ƒåŠ¨è®¯å·ã€Unlockç­‰ï¼Œå…¨éƒ½æ˜¯å¯¹è±¡ï¼Œæ‰¾è¢« {} åŒ…è£¹çš„å†…å®¹
            // æ³¨æ„ï¼šå¤‡å¿˜å½•è™½ç„¶é‡Œé¢æœ‰æ•°ç»„ï¼Œä½†æœ€å¤–å±‚æ˜¯ { "memos": [] }
            const objectMatch = contentStr.match(/\{[\s\S]*\}/);
            if (objectMatch) jsonStr = objectMatch[0];
        }

        // 3. å®¹é”™å…œåº•ï¼šå¦‚æœæ²¡æ‰¾åˆ°æ­£åˆ™åŒ¹é…ï¼Œä½†å­—ç¬¦ä¸²æœ¬èº«çœ‹èµ·æ¥æ˜¯å¯¹çš„ï¼Œå°±ç›´æ¥ç”¨
        if (!jsonStr) {
             if (contentStr.startsWith('[') && contentStr.endsWith(']')) jsonStr = contentStr;
             else if (contentStr.startsWith('{') && contentStr.endsWith('}')) jsonStr = contentStr;
        }

        if (!jsonStr) {
            throw new Error(`æ— æ³•ä»AIè¿”å›ä¸­æå–æœ‰æ•ˆçš„JSONæ ¼å¼ (${appType === 'music' ? 'æ•°ç»„' : 'å¯¹è±¡'})`);
        }
        
        const generatedData = JSON.parse(jsonStr);
        // --- ä¿®å¤ç»“æŸ ---

        // æ•°æ®éªŒè¯
        let isValid = false;
        switch (appType) {
            case 'messages': isValid = generatedData && Array.isArray(generatedData.conversations); break;
            case 'memos': isValid = generatedData && Array.isArray(generatedData.memos); break;
            case 'album': isValid = generatedData && Array.isArray(generatedData.photos); break;
            case 'cart': isValid = generatedData && Array.isArray(generatedData.items); break;
            case 'transfer': isValid = generatedData && Array.isArray(generatedData.entries); break;
            case 'browser': isValid = generatedData && Array.isArray(generatedData.history); break;
            case 'unlock': isValid = generatedData && generatedData.nickname && Array.isArray(generatedData.posts); break;
            case 'signal': isValid = generatedData && generatedData.moment && generatedData.thoughts; break;
            case 'music': isValid = Array.isArray(generatedData); break;
            default: isValid = false;
        }

        if (!isValid) {
            throw new Error("AIè¿”å›çš„æ•°æ®æ ¼å¼ä¸ç¬¦åˆåº”ç”¨è¦æ±‚ã€‚");
        }

        // å°†ç”Ÿæˆçš„æ•°æ®ä¿å­˜åˆ°è§’è‰²å¯¹è±¡ä¸­ï¼Œå¹¶æŒä¹…åŒ–åˆ°æ•°æ®åº“
        char.peekData[appType] = generatedData;
        await saveData(); // ä¿å­˜åˆ° IndexedDB

        // æ¸²æŸ“å†…å®¹
        if (appType === 'messages') {
            renderPeekChatList(generatedData.conversations);
        } else if (appType === 'memos') {
            renderMemosList(generatedData.memos, char);
        } else if (appType === 'album') {
            renderPeekAlbum(generatedData.photos);
        } else if (appType === 'transfer') {
           renderPeekTransferStation(generatedData.entries);
        } else if (appType === 'cart') {
            renderPeekCart(generatedData.items);
        } else if (appType === 'browser') {
            renderPeekBrowser(generatedData.history);
        } else if (appType === 'unlock') {
            renderPeekUnlock(generatedData, char);
        } else if (appType === 'signal') {
            renderAiHeartSignal(generatedData);
        } else if (appType === 'music') {
            renderAiMusicPlaylist(generatedData);
        }
    } catch (error) {
        // ä¿®å¤ï¼šç›´æ¥æ‰“å°é”™è¯¯å¹¶å¼¹çª—ï¼Œä¸å†è°ƒç”¨ä¸å­˜åœ¨çš„ showApiError
        console.error("ç”Ÿæˆå†…å®¹å‡ºé”™:", error);
        showToast(`ç”Ÿæˆå¤±è´¥: ${error.message}`);
        
        const errorMessage = "å†…å®¹ç”Ÿæˆå¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•ã€‚";
        if (appType === 'album') {
            document.querySelector('#peek-album-screen .album-grid').innerHTML = `<p class="placeholder-text">${errorMessage}</p>`;
        } else if (appType === 'unlock') {
            document.getElementById('peek-unlock-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="ai-space-home-screen">â€¹</button><div class="title-container"><h1 class="title">é”™è¯¯</h1></div><button class="action-btn">Â·Â·Â·</button></header><main class="content"><p class="placeholder-text">${errorMessage}</p></main>`;
        } else if (targetContainer) {
            targetContainer.innerHTML = `<p class="placeholder-text">${errorMessage}</p>`;
        }
    } finally {
        generatingPeekApps.delete(appType);
    }
}

// ===============================================================
// Peek æ¸²æŸ“å‡½æ•°
// ===============================================================

/**
 * æ¸²æŸ“ Peek æ¶ˆæ¯åˆ—è¡¨
 */
function renderPeekChatList(conversations = []) {
    const container = document.getElementById('peek-chat-list-container');
    container.innerHTML = '';

    if (!conversations || conversations.length === 0) {
        return;
    }

    conversations.forEach((convo) => {
        const history = convo.history || [];
        const lastMessage = history.length > 0 ? history[history.length - 1] : null;
        const lastMessageText = lastMessage ? (lastMessage.content || '').replace(/\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+)\]/, '$1') : '...';
        
        const li = document.createElement('li');
        li.className = 'list-item chat-item';
        li.dataset.name = convo.partnerName;

        const avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';

        li.innerHTML = `
            <img src="${avatarUrl}" alt="${convo.partnerName}" class="chat-avatar">
            <div class="item-details">
                <div class="item-details-row"><div class="item-name">${convo.partnerName}</div></div>
                <div class="item-preview-wrapper">
                    <div class="item-preview">${lastMessageText}</div>
                </div>
            </div>`;
        
        li.addEventListener('click', () => {
            renderPeekConversation(convo.history, convo.partnerName);
            switchScreen('peek-conversation-screen');
        });
        
        container.appendChild(li);
    });
}

/**
 * æ¸²æŸ“ Peek å¯¹è¯è¯¦æƒ…
 */
function renderPeekConversation(history, partnerName) {
    const titleEl = document.getElementById('peek-conversation-title');
    const messageAreaEl = document.getElementById('peek-message-area');

    titleEl.textContent = partnerName;
    messageAreaEl.innerHTML = '';

    if (!history || history.length === 0) {
        messageAreaEl.innerHTML = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆå¯¹è¯...</p>';
        return;
    }

    history.forEach(msg => {
        const isSentByChar = msg.sender === 'char';
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${isSentByChar ? 'sent' : 'received'}`;

        const bubbleRow = document.createElement('div');
        bubbleRow.className = 'message-bubble-row';

        const bubble = document.createElement('div');
        bubble.className = `message-bubble ${isSentByChar ? 'sent' : 'received'}`;
        bubble.textContent = msg.content;

        if (isSentByChar) {
            bubbleRow.appendChild(bubble);
        } else {
            const avatar = document.createElement('img');
            avatar.className = 'message-avatar';
            avatar.src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            bubbleRow.appendChild(avatar);
            bubbleRow.appendChild(bubble);
        }
        
        wrapper.appendChild(bubbleRow);
        messageAreaEl.appendChild(wrapper);
    });
    messageAreaEl.scrollTop = messageAreaEl.scrollHeight;
}

/**
 * æ¸²æŸ“å¤‡å¿˜å½•åˆ—è¡¨
 */
function renderMemosList(memos, char) {
    const screen = document.getElementById('peek-memos-screen');
    let listHtml = '';
    if (!memos || memos.length === 0) {
        listHtml = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆå¤‡å¿˜å½•...</p>';
    } else {
        memos.forEach(memo => {
            const firstLine = memo.content.split('\n')[0];
            listHtml += `
                <li class="memo-item" data-id="${memo.id}">
                    <h3 class="memo-item-title">${memo.title}</h3>
                    <p class="memo-item-preview">${firstLine}</p>
                </li>
            `;
        });
    }

    screen.innerHTML = `
        <header class="app-header">
            <button class="back-btn" data-target="ai-space-home-screen">â€¹</button>
            <div class="title-container"><h1 class="title">å¤‡å¿˜å½•</h1></div>
            <button class="action-btn" id="refresh-peek-memos-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="22" height="22"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg></button>
        </header>
        <main class="content"><ul id="peek-memos-list">${listHtml}</ul></main>
    `;

    if (char) {
        screen.querySelector('#refresh-peek-memos-btn').addEventListener('click', () => {
            generateAndRenderPeekContent('memos', char, { forceRefresh: true });
        });
    }

    screen.querySelectorAll('.memo-item').forEach(item => {
        item.addEventListener('click', () => {
            const memo = memos.find(m => m.id === item.dataset.id); 
            if (memo) {
                renderMemoDetail(memo);
                switchScreen('peek-memo-detail-screen');
            }
        });
    });
}

/**
 * æ¸²æŸ“å¤‡å¿˜å½•è¯¦æƒ…
 */
function renderMemoDetail(memo) {
    const screen = document.getElementById('peek-memo-detail-screen');
    if (!memo) return;
    const contentHtml = memo.content.replace(/\n/g, '<br>');
    screen.innerHTML = `
        <header class="app-header">
            <button class="back-btn" data-target="peek-memos-screen">â€¹</button>
            <div class="title-container"><h1 class="title">${memo.title}</h1></div>
            <div class="placeholder"></div>
        </header>
        <main class="content" style="padding: 20px; line-height: 1.6;">${contentHtml}</main>
    `;
}

/**
 * æ¸²æŸ“è´­ç‰©è½¦
 */
function renderPeekCart(items) {
   const screen = document.getElementById('peek-cart-screen');
    let itemsHtml = '';
    let totalPrice = 0;

    if (!items || items.length === 0) {
        itemsHtml = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆè´­ç‰©è½¦å†…å®¹...</p>';
    } else {
        items.forEach(item => {
            itemsHtml += `
                <li class="cart-item" data-id="${item.id}">
                    <img src="https://i.postimg.cc/wMbSMvR9/export202509181930036600.png" class="cart-item-image" alt="${item.title}">
                    <div class="cart-item-details">
                        <h3 class="cart-item-title">${item.title}</h3>
                        <p class="cart-item-spec">è§„æ ¼ï¼š${item.spec}</p>
                        <p class="cart-item-price">Â¥${item.price}</p>
                    </div>
                </li>
            `;
            totalPrice += parseFloat(item.price);
        });
    }

   screen.innerHTML = `
       <header class="app-header">
           <button class="back-btn" data-target="ai-space-home-screen">â€¹</button>
           <div class="title-container"><h1 class="title">è´­ç‰©è½¦</h1></div>
           <button class="action-btn" id="refresh-peek-cart-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="22" height="22"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg></button>
       </header>
       <main class="content"><ul class="cart-item-list">${itemsHtml}</ul></main>
       <footer class="cart-footer">
           <div class="cart-total-price">
               <span class="label">åˆè®¡ï¼š</span>Â¥${totalPrice.toFixed(2)}
           </div>
           <button class="checkout-btn">ç»“ç®—</button>
       </footer>
   `;
   
   const refreshBtn = screen.querySelector('#refresh-peek-cart-btn');
   if (refreshBtn && currentAiForApp) {
       refreshBtn.addEventListener('click', () => {
           generateAndRenderPeekContent('cart', currentAiForApp, { forceRefresh: true });
       });
   }
   
   screen.querySelector('.checkout-btn').addEventListener('click', () => {
       showToast('åŠŸèƒ½å¼€å‘ä¸­');
   });
}

/**
 * æ¸²æŸ“ä¸­è½¬ç«™
 */
function renderPeekTransferStation(entries) {
   const screen = document.getElementById('peek-transfer-station-screen');
    let messagesHtml = '';

    if (!entries || entries.length === 0) {
        messagesHtml = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆä¸­è½¬ç«™å†…å®¹...</p>';
    } else {
        entries.forEach(entry => {
            messagesHtml += `
                <div class="message-wrapper sent">
                    <div class="message-bubble-row">
                        <div class="message-bubble sent" style="background-color: #98E165; color: #000;">
                            ${entry}
                        </div>
                    </div>
                </div>
            `;
        });
    }

   screen.innerHTML = `
       <header class="app-header">
           <button class="back-btn" data-target="ai-space-home-screen">â€¹</button>
           <div class="title-container">
               <h1 class="title">æ–‡ä»¶ä¼ è¾“åŠ©æ‰‹</h1>
           </div>
           <button class="action-btn" id="refresh-peek-transfer-btn">
               <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="22" height="22"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
           </button>
       </header>
       <main class="content">
           <div class="message-area" style="padding: 10px;">
                ${messagesHtml}
           </div>
           <div class="transfer-station-input-area">
               <div class="fake-input"></div>
               <button class="plus-btn"></button>
           </div>
       </main>
   `;

    const refreshBtn = screen.querySelector('#refresh-peek-transfer-btn');
    if (refreshBtn && currentAiForApp) {
        refreshBtn.addEventListener('click', () => {
            generateAndRenderPeekContent('transfer', currentAiForApp, { forceRefresh: true });
        });
    }

    const messageArea = screen.querySelector('.message-area');
    if (messageArea) {
        messageArea.scrollTop = messageArea.scrollHeight;
    }
}

/**
 * æ¸²æŸ“æµè§ˆå™¨å†å²
 */
function renderPeekBrowser(historyItems) {
  const screen = document.getElementById('peek-browser-screen');
  let itemsHtml = '';
    if (!historyItems || historyItems.length === 0) {
        itemsHtml = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆæµè§ˆè®°å½•...</p>';
    } else {
        historyItems.forEach(item => {
            itemsHtml += `
                <li class="browser-history-item">
                    <h3 class="history-item-title">${item.title}</h3>
                    <p class="history-item-url">${item.url}</p>
                    <div class="history-item-annotation">${item.annotation}</div>
                </li>
            `;
        });
    }

  screen.innerHTML = `
      <header class="app-header">
          <button class="back-btn" data-target="ai-space-home-screen">â€¹</button>
          <div class="title-container"><h1 class="title">æµè§ˆå™¨</h1></div>
          <button class="action-btn" id="refresh-peek-browser-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="22" height="22"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg></button>
      </header>
      <main class="content"><ul class="browser-history-list">${itemsHtml}</ul></main>
  `;
  
  const refreshBtn = screen.querySelector('#refresh-peek-browser-btn');
  if (refreshBtn && currentAiForApp) {
      refreshBtn.addEventListener('click', () => {
          generateAndRenderPeekContent('browser', currentAiForApp, { forceRefresh: true });
      });
  }
}

/**
 * æ¸²æŸ“ç›¸å†Œ
 */
function renderPeekAlbum(photos) {
    const screen = document.getElementById('peek-album-screen');
    const grid = screen.querySelector('.album-grid');
    grid.innerHTML = '';

    if (!photos || photos.length === 0) {
        grid.innerHTML = '<p class="placeholder-text">æ­£åœ¨ç”Ÿæˆç›¸å†Œå†…å®¹...</p>';
        return;
    }

    photos.forEach(photo => {
        const photoEl = document.createElement('div');
        photoEl.className = 'album-photo';
        photoEl.dataset.imageDescription = photo.imageDescription;
        photoEl.dataset.description = photo.description;

        const img = document.createElement('img');
        img.src = 'https://i.postimg.cc/1tH6ds9g/1752301200490.jpg';
        img.alt = "ç›¸å†Œç…§ç‰‡";
        photoEl.appendChild(img);

        if (photo.type === 'video') {
            const videoIndicator = document.createElement('div');
            videoIndicator.className = 'video-indicator';
            videoIndicator.innerHTML = `<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>`;
            photoEl.appendChild(videoIndicator);
        }
        
        photoEl.addEventListener('click', () => {
            const modal = document.getElementById('peek-photo-modal');
            const imgContainer = document.getElementById('peek-photo-image-container');
            const descriptionEl = document.getElementById('peek-photo-description');
            
            imgContainer.innerHTML = `<div style="padding: 20px; text-align: left; color: #555; font-size: 16px; line-height: 1.6; height: 100%; overflow-y: auto;">${photo.imageDescription}</div>`;
            descriptionEl.textContent = `æ‰¹æ³¨ï¼š${photo.description}`;
            
            modal.classList.add('visible');
        });

        grid.appendChild(photoEl);
    });
}

/**
 * æ¸²æŸ“ Unlock (å¾®åšå°å·)
 */
function renderPeekUnlock(data, char) {
    const screen = document.getElementById('peek-unlock-screen');
    if (!screen) return;

    if (!data) {
        screen.innerHTML = `
            <header class="app-header">
                <button class="back-btn" data-target="ai-space-home-screen">â€¹</button>
                <div class="title-container"><h1 class="title">...</h1></div>
                <button class="action-btn">Â·Â·Â·</button>
            </header>
            <main class="content"><p class="placeholder-text">æ­£åœ¨ç”Ÿæˆå°å·å†…å®¹...</p></main>
        `;
        return;
    }

    const { nickname, handle, bio, posts } = data;
    const fixedAvatar = char.avatar || 'https://i.postimg.cc/SNwL1XwR/chan-11.png';

    const randomFollowers = (Math.random() * 5 + 1).toFixed(1) + 'k';
    const randomFollowing = Math.floor(Math.random() * 500) + 50;

    let postsHtml = '';
    if (posts && posts.length > 0) {
        posts.forEach(post => {
            const randomComments = Math.floor(Math.random() * 100);
            const randomLikes = Math.floor(Math.random() * 500);
            postsHtml += `
                <div class="unlock-post-card">
                    <div class="unlock-post-card-header">
                        <img src="${fixedAvatar}" alt="Profile Avatar">
                        <div class="unlock-post-card-author-info">
                            <span class="username">${nickname}</span>
                            <span class="timestamp">${post.timestamp}</span>
                        </div>
                    </div>
                    <div class="unlock-post-card-content">
                        ${post.content.replace(/\n/g, '<br>')}
                    </div>
                    <div class="unlock-post-card-actions">
                        <div class="action"><svg viewBox="0 0 24 24"><path d="M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L16.04,7.15C16.56,7.62 17.24,7.92 18,7.92C19.66,7.92 21,6.58 21,5C21,3.42 19.66,2 18,2C16.34,2 15,3.42 15,5C15,5.24 15.04,5.47 15.09,5.7L7.96,9.85C7.44,9.38 6.76,9.08 6,9.08C4.34,9.08 3,10.42 3,12C3,13.58 4.34,14.92 6,14.92C6.76,14.92 7.44,14.62 7.96,14.15L15.09,18.3C15.04,18.53 15,18.76 15,19C15,20.58 16.34,22 18,22C19.66,22 21,20.58 21,19C21,17.42 19.66,16.08 18,16.08Z"></path></svg> <span>åˆ†äº«</span></div>
                        <div class="action"><svg viewBox="0 0 24 24"><path d="M20,2H4C2.9,0,2,0.9,2,2v18l4-4h14c1.1,0,2-0.9,2-2V4C22,2.9,21.1,2,20,2z M18,14H6v-2h12V14z M18,11H6V9h12V11z M18,8H6V6h12V8z"></path></svg> <span>${randomComments}</span></div>
                        <div class="action"><svg viewBox="0 0 24 24"><path d="M12,21.35L10.55,20.03C5.4,15.36,2,12.27,2,8.5C2,5.42,4.42,3,7.5,3c1.74,0,3.41,0.81,4.5,2.09C13.09,3.81,14.76,3,16.5,3C19.58,3,22,5.42,22,8.5c0,3.78-3.4,6.86-8.55,11.54L12,21.35z"></path></svg> <span>${randomLikes}</span></div>
                    </div>
                </div>
            `;
        });
    }

    screen.innerHTML = `
        <header class="app-header">
            <button class="back-btn" data-target="ai-space-home-screen">â€¹</button>
            <div class="title-container">
                <h1 class="title">${nickname}</h1>
            </div>
            <button class="action-btn" id="refresh-unlock-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="22" height="22"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg></button>
        </header>
        <main class="content">
            <div class="unlock-profile-header">
                <img src="${fixedAvatar}" alt="Profile Avatar" class="unlock-profile-avatar">
                <div class="unlock-profile-info">
                    <h2 class="unlock-profile-username">${nickname}</h2>
                    <p class="unlock-profile-handle">${handle}</p>
                </div>
            </div>
            <div class="unlock-profile-bio">
                <p>${bio.replace(/\n/g, '<br>')}</p>
            </div>
            <div class="unlock-profile-stats">
                <div class="unlock-profile-stat">
                    <span class="count">${posts.length}</span>
                    <span class="label">å¸–å­</span>
                </div>
                <div class="unlock-profile-stat">
                    <span class="count">${randomFollowers}</span>
                    <span class="label">ç²‰ä¸</span>
                </div>
                <div class="unlock-profile-stat">
                    <span class="count">${randomFollowing}</span>
                    <span class="label">å…³æ³¨</span>
                </div>
            </div>
            <div class="unlock-post-feed">
                ${postsHtml}
            </div>
        </main>
    `;

    if (char) {
        screen.querySelector('#refresh-unlock-btn').addEventListener('click', () => {
            generateAndRenderPeekContent('unlock', char, { forceRefresh: true });
        });
    }
}

/**
 * è®¾ç½® Peek åŠŸèƒ½çš„äº‹ä»¶ç›‘å¬å™¨
 */
function setupPeekFeatureHandlers() {
    // ç›¸å†Œåˆ·æ–°æŒ‰é’®
    const refreshAlbumBtn = document.getElementById('refresh-album-btn');
    if (refreshAlbumBtn) {
        refreshAlbumBtn.addEventListener('click', () => {
            if (currentAiForApp) {
                generateAndRenderPeekContent('album', currentAiForApp, { forceRefresh: true });
            }
        });
    }

    // æ¶ˆæ¯åˆ·æ–°æŒ‰é’®
    const refreshMessagesBtn = document.getElementById('refresh-peek-messages-btn');
    if (refreshMessagesBtn) {
        refreshMessagesBtn.addEventListener('click', () => {
            if (currentAiForApp) {
                generateAndRenderPeekContent('messages', currentAiForApp, { forceRefresh: true });
            }
        });
    }

    // å¿ƒåŠ¨è®¯å·åˆ·æ–°æŒ‰é’®
    const refreshSignalBtn = document.getElementById('refresh-signal-btn');
    if (refreshSignalBtn) {
        refreshSignalBtn.addEventListener('click', () => {
            if (currentAiForApp) {
                generateAndRenderPeekContent('signal', currentAiForApp, { forceRefresh: true });
            }
        });
    }

    // éŸ³ä¹æ­Œå•åˆ·æ–°æŒ‰é’®
    const refreshMusicBtn = document.getElementById('refresh-music-playlist-btn');
    if (refreshMusicBtn) {
        refreshMusicBtn.addEventListener('click', () => {
            if (currentAiForApp) {
                generateAndRenderPeekContent('music', currentAiForApp, { forceRefresh: true });
            }
        });
    }

    // è´­ç‰©è½¦åˆ·æ–°æŒ‰é’® (åŠ¨æ€æ·»åŠ ï¼Œåœ¨æ¸²æŸ“æ—¶ç»‘å®š)
    // æµè§ˆå™¨åˆ·æ–°æŒ‰é’® (åŠ¨æ€æ·»åŠ ï¼Œåœ¨æ¸²æŸ“æ—¶ç»‘å®š)
    // ä¸­è½¬ç«™åˆ·æ–°æŒ‰é’® (åŠ¨æ€æ·»åŠ ï¼Œåœ¨æ¸²æŸ“æ—¶ç»‘å®š)

    // ç…§ç‰‡è¯¦æƒ…æ¨¡æ€æ¡†å…³é—­æŒ‰é’®
    const closePhotoBtn = document.getElementById('close-peek-photo-btn');
    if (closePhotoBtn) {
        closePhotoBtn.addEventListener('click', () => {
            document.getElementById('peek-photo-modal').classList.remove('visible');
        });
    }

    // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
    const photoModal = document.getElementById('peek-photo-modal');
    if (photoModal) {
        photoModal.addEventListener('click', (e) => {
            if (e.target === photoModal) {
                photoModal.classList.remove('visible');
            }
        });
    }
}


// ===============================================================
// END: Peek æ‰‹æœºåŠŸèƒ½æ ¸å¿ƒé€»è¾‘
// ===============================================================



// ===============================================================
// END: AIç©ºé—´åŠŸèƒ½
// ===============================================================
        init();
    });

// ===============================================================
// START: äº¤æ¢æ—¥è®°AppåŠŸèƒ½ (V3.0 - æ—¥è®°æœ¬æ»‘åŠ¨ç‰ˆ)
// ===============================================================
function setupDiaryExchangeApp() {
    // --- DOMå…ƒç´ ç¼“å­˜ ---
    const writeModal = document.getElementById('write-diary-exchange-modal');
    const writeForm = document.getElementById('diary-exchange-form');
    const imageUpload = document.getElementById('exchange-diary-image-upload');
    const imagePreview = document.getElementById('exchange-diary-image-preview');
    const submitBtn = writeForm.querySelector('button[type="submit"]');
    const listContainer = document.getElementById('diary-exchange-list-container');
    const viewerModal = document.getElementById('diary-exchange-viewer-modal');

    let tempImageDataUrl = null; 

    // --- äº‹ä»¶ç»‘å®š ---

    // æ‰“å¼€æ’°å†™æ—¥è®°å¼¹çª—
    document.getElementById('write-new-exchange-btn').addEventListener('click', () => {
        writeForm.reset();
        imagePreview.style.display = 'none';
        imagePreview.style.backgroundImage = 'none';
        tempImageDataUrl = null;
        submitBtn.disabled = false;
        writeModal.classList.add('visible');
    });

    // å¤„ç†å›¾ç‰‡é€‰æ‹©
    imageUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.8, maxWidth: 800, maxHeight: 800 });
                tempImageDataUrl = compressedUrl;
                imagePreview.style.backgroundImage = `url(${compressedUrl})`;
                imagePreview.style.display = 'block';
            } catch (error) {
                showToast('å›¾ç‰‡å¤„ç†å¤±è´¥');
                tempImageDataUrl = null;
            }
        }
    });

    // å¤„ç†æ—¥è®°å‘é€
    writeForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
        const character = db.characters.find(c => c.id === characterId);
        if (!character) return;

        const userContent = document.getElementById('exchange-diary-content').value.trim();
        if (!userContent) {
            showToast('æ—¥è®°å†…å®¹ä¸èƒ½ä¸ºç©º');
            return;
        }

        submitBtn.disabled = true;
        writeModal.classList.remove('visible');
        showToast('æ­£åœ¨å‘é€æ—¥è®°ï¼Œè¯·ç¨å€™...');

        try {
            const prompt = generateDiaryExchangePrompt(character, userContent, tempImageDataUrl);
            
            let messagesForApi;
            if (db.apiSettings.provider === 'claude' && tempImageDataUrl) {
                const base64Match = tempImageDataUrl.match(/^data:(image\/.+);base64,(.*)$/);
                messagesForApi = [{ role: 'user', content: [{ type: 'text', text: prompt }, { type: 'image', source: { type: 'base64', media_type: base64Match[1], data: base64Match[2] } }] }];
            } else {
                 messagesForApi = [{ role: 'user', content: prompt }];
            }

            const aiResponseText = await callAiApi(messagesForApi);
            
            // AIè¿”å›çš„æ•°æ®å¯èƒ½åŒ…å«å°é¢ä¿¡æ¯
            const responseData = JSON.parse(aiResponseText);

            const newExchange = {
                id: `exchange_${Date.now()}`,
                timestamp: Date.now(),
                userEntry: userContent,
                userImage: tempImageDataUrl,
                aiReply: responseData.diaryContent, // æå–æ—¥è®°æ­£æ–‡
                coverImage: `https://image.pollinations.ai/prompt/${encodeURIComponent(responseData.coverImagePrompt)}`, // ç”Ÿæˆå°é¢å›¾ç‰‡
                coverTitle: responseData.coverTitle // æå–å°é¢æ ‡é¢˜
            };

            character.soulBondData.diaryExchanges = character.soulBondData.diaryExchanges || [];
            character.soulBondData.diaryExchanges.unshift(newExchange);

            await saveData();
            renderDiaryExchanges();
            showToast('äº¤æ¢æ—¥è®°å·²æ”¶åˆ°å›å¤ï¼');

        } catch (error) {
            console.error("äº¤æ¢æ—¥è®°å¤±è´¥:", error);
            showToast(`å‘é€å¤±è´¥: ${error.message}`);
        } finally {
            submitBtn.disabled = false;
        }
    });

    // ä½¿ç”¨äº‹ä»¶å§”æ‰˜å¤„ç†æ—¥è®°æœ¬çš„ç‚¹å‡»å’Œé•¿æŒ‰
    let longPressTimer;
    const handleLongPress = async (targetElement) => {
        const diaryBook = targetElement.closest('.diary-book');
        if (!diaryBook) return;
        const exchangeId = diaryBook.dataset.id;
        
        if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æœ¬æ—¥è®°å—ï¼Ÿ')) {
            const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
            const character = db.characters.find(c => c.id === characterId);
            if (character && character.soulBondData) {
                character.soulBondData.diaryExchanges = character.soulBondData.diaryExchanges.filter(ex => ex.id !== exchangeId);
                await saveData();
                renderDiaryExchanges();
                showToast('äº¤æ¢æ—¥è®°å·²åˆ é™¤');
            }
        }
    };
    
    listContainer.addEventListener('click', (e) => {
        const diaryBook = e.target.closest('.diary-book');
        if (diaryBook) {
            openDiaryViewer(diaryBook.dataset.id);
        }
    });
    listContainer.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        handleLongPress(e.target);
    });
    listContainer.addEventListener('touchstart', (e) => {
        longPressTimer = setTimeout(() => handleLongPress(e.target), 500);
    });
    listContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
    listContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));

    // å…³é—­æŸ¥çœ‹å™¨
    document.getElementById('close-diary-viewer-btn').addEventListener('click', () => {
        viewerModal.classList.remove('visible');
    });
}
// ===============================================================
// END: äº¤æ¢æ—¥è®°AppåŠŸèƒ½ (V2.0)
// æ¸²æŸ“äº¤æ¢æ—¥è®°åˆ—è¡¨ (V3.0 - æ—¥è®°æœ¬æ ·å¼)
function renderDiaryExchanges() {
    const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
    const character = db.characters.find(c => c.id === characterId);
    const container = document.getElementById('diary-exchange-list-container');
    const placeholder = document.getElementById('no-diary-exchanges-placeholder');

    if (!character || !character.soulBondData || !character.soulBondData.diaryExchanges || character.soulBondData.diaryExchanges.length === 0) {
        container.innerHTML = '';
        placeholder.style.display = 'block';
        return;
    }

    placeholder.style.display = 'none';
    container.innerHTML = '';
    
    character.soulBondData.diaryExchanges.forEach(exchange => {
        const bookDiv = document.createElement('div');
        bookDiv.className = 'diary-book';
        bookDiv.dataset.id = exchange.id;
        
        const date = new Date(exchange.timestamp);
        const dateString = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;

        bookDiv.innerHTML = `
            <div class="diary-book-inner">
                <div class="diary-book-cover" style="background-image: url('${exchange.coverImage}')">
                    <span class="cover-date">${dateString}</span>
                    <h4 class="cover-title">${exchange.coverTitle || 'æˆ‘ä»¬çš„æ—¥è®°'}</h4>
                    <span class="cover-authors">${character.myName} & ${character.remarkName}</span>
                </div>
                <div class="diary-book-back">
                    <p>ç‚¹å‡»æŸ¥çœ‹<br>${exchange.coverTitle || 'æˆ‘ä»¬çš„æ—¥è®°'}</p>
                </div>
            </div>
        `;
        container.appendChild(bookDiv);
    });
}

// æ‰“å¼€æ—¥è®°å†…å®¹æŸ¥çœ‹å™¨
function openDiaryViewer(exchangeId) {
    const characterId = document.getElementById('soul-bond-screen').dataset.characterId;
    const character = db.characters.find(c => c.id === characterId);
    if (!character || !character.soulBondData) return;

    const exchange = character.soulBondData.diaryExchanges.find(ex => ex.id === exchangeId);
    if (!exchange) return;

    document.getElementById('diary-viewer-title').textContent = exchange.coverTitle || 'äº¤æ¢æ—¥è®°';
    const contentContainer = document.getElementById('diary-viewer-content');
    
    const userImageHTML = exchange.userImage ? `<img src="${exchange.userImage}" alt="æ—¥è®°å›¾ç‰‡" class="entry-image">` : '';

    contentContainer.innerHTML = `
        <div class="diary-exchange-entry user-entry">
            <div class="entry-header">
                <img src="${character.myAvatar}" alt="My Avatar">
                <span class="author-name">${character.myName}</span>
            </div>
            <p class="entry-content">${exchange.userEntry.replace(/\n/g, '<br>')}</p>
            ${userImageHTML}
        </div>
        <div class="diary-exchange-entry ai-reply">
            <div class="entry-header">
                <img src="${character.avatar}" alt="AI Avatar">
                <span class="author-name">${character.remarkName}</span>
            </div>
            <p class="entry-content">${exchange.aiReply.replace(/\n/g, '<br>')}</p>
        </div>
    `;
    document.getElementById('diary-exchange-viewer-modal').classList.add('visible');
}

// ä¸ºAIç”Ÿæˆäº¤æ¢æ—¥è®°çš„æŒ‡ä»¤ (V3.0 - æ–°å¢å°é¢ç”Ÿæˆ)
function generateDiaryExchangePrompt(character, userContent, userImage) {
    let imagePromptPart = userImage 
        ? "Taè¿˜é™„ä¸Šäº†ä¸€å¼ å›¾ç‰‡ã€‚ä½ çš„å›ä¿¡å¿…é¡»æ·±åˆ»ç»“åˆå›¾ç‰‡å†…å®¹å’Œæ–‡å­—æ¥å†™ã€‚" 
        : "";

    let prompt = `ä½ æ­£åœ¨æ‰®æ¼”è§’è‰²â€œ${character.realName}â€ï¼Œäººè®¾æ˜¯ï¼š${character.persona}ã€‚
ä½ åˆšåˆšæ”¶åˆ°äº†â€œæˆ‘â€ï¼ˆ${character.myName}ï¼‰å†™ç»™ä½ çš„ä¸€ç¯‡äº¤æ¢æ—¥è®°ã€‚${imagePromptPart}

# æˆ‘å†™çš„æ—¥è®°å†…å®¹ï¼š
"${userContent}"

# ä½ çš„ä»»åŠ¡ï¼š
1.  **åˆ›ä½œå›ä¿¡**: ä¸¥æ ¼ä»¥ ${character.realName} çš„ç¬¬ä¸€äººç§°è§†è§’ï¼Œå†™ä¸€ç¯‡**ä¸å°‘äº200å­—**çš„å›å¤æ—¥è®°ã€‚ä½ çš„å›ä¿¡éœ€è¦æ·±åˆ»ä½“ç°ä½ è¯»å®Œæ—¥è®°ï¼ˆä»¥åŠçœ‹å®Œå›¾ç‰‡ï¼Œå¦‚æœé™„å¸¦äº†ï¼‰ä¹‹åçš„å¤æ‚æƒ…æ„Ÿã€è”æƒ³ã€å›å¿†æˆ–å¯¹æœªæ¥çš„æœŸè®¸ã€‚
2.  **æ„æ€å°é¢**: æ ¹æ®ä½ ä»¬çš„æ—¥è®°å†…å®¹ï¼Œä¸ºè¿™æœ¬æ—¥è®°æ„æ€ä¸€ä¸ªå°é¢ã€‚ä½ éœ€è¦æä¾›ï¼š
    - ä¸€ä¸ªç®€çŸ­ã€æ–‡è‰ºçš„å°é¢æ ‡é¢˜ (coverTitle)ã€‚
    - ä¸€ä¸ªç”¨äºAIç»˜ç”»çš„ã€æè¿°å°é¢ç”»é¢çš„è‹±æ–‡å…³é”®è¯çŸ­è¯­ (coverImagePrompt)ã€‚
3.  **ä¸¥æ ¼æ ¼å¼**: ä½ çš„è¾“å‡ºå¿…é¡»æ˜¯ä¸¥æ ¼çš„JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€‚

# JSONæ ¼å¼ç¤ºä¾‹:
{
  "diaryContent": "è¿™é‡Œæ˜¯ä½ å†™çš„ã€ä¸å°‘äº200å­—çš„å›ä¿¡æ—¥è®°æ­£æ–‡...",
  "coverTitle": "æµ·è¾¹çš„çº¦å®š",
  "coverImagePrompt": "anime style, a couple sitting on the beach, watching sunset, warm colors, romantic"
}`;
    
    return prompt;
}

// ===============================================================
// END: äº¤æ¢æ—¥è®°åŠŸèƒ½ (V3.0)
// ===============================================================

(function(){
  if (window._bubblePresetsScriptLoaded) return;
  window._bubblePresetsScriptLoaded = true;

  // localStorage key
  const PRES_KEY = 'bubblePresets';

  function _getBubblePresets() {
    try { return JSON.parse(localStorage.getItem(PRES_KEY) || '[]'); }
    catch(e){ return []; }
  }
  function _saveBubblePresets(arr) {
    localStorage.setItem(PRES_KEY, JSON.stringify(arr || []));
  }

  function populateBubblePresetSelect() {
    const sel = document.getElementById('bubble-preset-select');
    if (!sel) return;
    const presets = _getBubblePresets();
    sel.innerHTML = '<option value="">â€” é€‰æ‹©é¢„è®¾ â€”</option>';
    presets.forEach((p) => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }
function startQuoteReply(messageId) {
    const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
    const message = chat.history.find(m => m.id === messageId);
    if (!message) return;

    // æå–å¹²å‡€çš„æ–‡æœ¬å†…å®¹ç”¨äºé¢„è§ˆ
    let previewText = message.content;
    const regexes = [
        /\[.*?çš„æ¶ˆæ¯ï¼š([\s\S]+?)\]/,
        /\[.*?çš„è¯­éŸ³ï¼š([\s\S]+?)\]/,
        /\[.*?å¼•ç”¨äº†â€œ.*?â€çš„æ¶ˆæ¯?å¹¶å›å¤ï¼š([\s\S]+?)\]/,
        /\[.*?å‘æ¥çš„ç…§ç‰‡\/è§†é¢‘ï¼š([\s\S]+?)\]/
    ];

    for (const regex of regexes) {
        const match = message.content.match(regex);
        if (match) {
            previewText = match[1];
            break;
        }
    }
    
    if (message.parts && message.parts.some(p => p.type === 'image')) {
        previewText = '[å›¾ç‰‡]';
    } else if (message.quote) {
        previewText = message.replyText;
    }

    currentQuotedMessageId = messageId;
    document.getElementById('quoted-message-preview').textContent = `å›å¤ï¼š${previewText}`;
    document.getElementById('quote-reply-bar').style.display = 'flex';
    messageInput.focus();
}

function cancelQuoteReply() {
    currentQuotedMessageId = null;
    document.getElementById('quote-reply-bar').style.display = 'none';
}
  async function applyPresetToCurrentChat(presetName) {
    const presets = _getBubblePresets();
    const preset = presets.find(p => p.name === presetName);
    if (!preset) { (window.showToast && showToast('æœªæ‰¾åˆ°è¯¥é¢„è®¾')) || alert('æœªæ‰¾åˆ°è¯¥é¢„è®¾'); return; }
    // æ›´æ–°ç•Œé¢ textarea
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (textarea) textarea.value = preset.css;

    // å°è¯•æ‰¾åˆ°å½“å‰ chat å¯¹è±¡å¹¶å†™å…¥ã€‚å¦‚æœæ²¡æœ‰ç°æˆçš„ db å¯¹è±¡ï¼Œä»…æ›´æ–° preview å’Œ textareaã€‚
    try {
      if (typeof currentChatId !== 'undefined' && typeof currentChatType !== 'undefined' && window.db) {
        const chat = (currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null);
        if (chat) {
          chat.customBubbleCss = preset.css;
          chat.useCustomBubbleCss = true;
        }
      }
    } catch(e){
      console.warn('applyPresetToCurrentChat: cannot write to db object', e);
    }

    // æ›´æ–°é¡µé¢æ ·å¼é¢„è§ˆï¼šä¼˜å…ˆä½¿ç”¨å·²æœ‰çš„ updateBubbleCssPreview æˆ– updateCustomBubbleStyle
    try {
      if (typeof updateCustomBubbleStyle === 'function') {
        try { updateCustomBubbleStyle(window.currentChatId || null, preset.css, true); } catch(e){ /* ignore */ }
      }
      const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
      if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, preset.css, false);
      (window.showToast && showToast('é¢„è®¾å·²åº”ç”¨åˆ°å½“å‰èŠå¤©å¹¶ä¿å­˜')) || alert('é¢„è®¾å·²åº”ç”¨ï¼ˆè‹¥é¡µé¢æ”¯æŒï¼‰');
      if (typeof saveData === 'function') {
        try { await saveData(); } catch(e){ /* ignore */ }
      }
    } catch(e){
      console.error('applyPresetToCurrentChat error', e);
    }
  }

  function saveCurrentTextareaAsPreset() {
    const textarea = document.getElementById('setting-custom-bubble-css');
    if (!textarea) return (window.showToast && showToast('æ‰¾ä¸åˆ°è‡ªå®šä¹‰ CSS æ–‡æœ¬æ¡†')) || alert('æ‰¾ä¸åˆ°è‡ªå®šä¹‰ CSS æ–‡æœ¬æ¡†');
    const css = textarea.value.trim();
    if (!css) return (window.showToast && showToast('å½“å‰ CSS ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜')) || alert('å½“å‰ CSS ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜');
    let name = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼ˆå°†è¦†ç›–åŒåé¢„è®¾ï¼‰:');
    if (!name) return;
    const presets = _getBubblePresets();
    const idx = presets.findIndex(p => p.name === name);
    if (idx >= 0) presets[idx].css = css;
    else presets.push({name, css});
    _saveBubblePresets(presets);
    populateBubblePresetSelect();
    (window.showToast && showToast('é¢„è®¾å·²ä¿å­˜')) || alert('é¢„è®¾å·²ä¿å­˜');
  }

  function openManagePresetsModal() {
    const modal = document.getElementById('bubble-presets-modal');
    const list = document.getElementById('bubble-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getBubblePresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">æš‚æ— é¢„è®¾</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';
      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = 'åº”ç”¨';
      applyBtn.onclick = function(){ applyPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = 'é‡å‘½å';
      renameBtn.onclick = function(){
        const newName = prompt('è¾“å…¥æ–°åç§°ï¼š', p.name);
        if (!newName) return;
        const presetsAll = _getBubblePresets();
        presetsAll[idx].name = newName;
        _saveBubblePresets(presetsAll);
        openManagePresetsModal(); // refresh
        populateBubblePresetSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn btn-danger';
      delBtn.style.padding = '6px 8px;border-radius:8px';
      delBtn.textContent = 'åˆ é™¤';
      delBtn.onclick = function(){
        if (!confirm('ç¡®å®šåˆ é™¤é¢„è®¾ \"' + p.name + '\" ?')) return;
        const presetsAll = _getBubblePresets();
        presetsAll.splice(idx, 1);
        _saveBubblePresets(presetsAll);
        openManagePresetsModal();
        populateBubblePresetSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(delBtn);
      row.appendChild(btnWrap);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  function bindBubblePresetUI() {
    populateBubblePresetSelect();
    const sel = document.getElementById('bubble-preset-select');
    const applyBtn = document.getElementById('apply-preset-btn');
    const saveBtn = document.getElementById('save-preset-btn');
    const manageBtn = document.getElementById('manage-presets-btn');
    const modalClose = document.getElementById('close-presets-modal');

    if (sel) {
      sel.addEventListener('change', (e) => {
        const val = e.target.value;
        const previewBox = document.getElementById('private-bubble-css-preview') || document.getElementById('group-bubble-css-preview');
        if (!val) {
          // restore preview from current chat theme or textarea
          try {
            const chat = (typeof currentChatType !== 'undefined' && typeof currentChatId !== 'undefined' && window.db) ? ((currentChatType === 'private') ? (db.characters && db.characters.find ? db.characters.find(c => c.id === currentChatId) : null) : (db.groups && db.groups.find ? db.groups.find(g => g.id === currentChatId) : null)) : null;
            const baseCss = (chat && chat.customBubbleCss) ? chat.customBubbleCss : (document.getElementById('setting-custom-bubble-css') ? document.getElementById('setting-custom-bubble-css').value : '');
            if (previewBox && typeof updateBubbleCssPreview === 'function') {
              updateBubbleCssPreview(previewBox, baseCss, !chat || !chat.useCustomBubbleCss);
            }
          } catch(e){ /* ignore */ }
          return;
        }
        const presets = _getBubblePresets();
        const p = presets.find(x => x.name === val);
        if (previewBox && typeof updateBubbleCssPreview === 'function') updateBubbleCssPreview(previewBox, p ? p.css : '', false);
      });
    }
    if (applyBtn) applyBtn.addEventListener('click', () => {
      const selVal = document.getElementById('bubble-preset-select').value;
      if (!selVal) return (window.showToast && showToast('è¯·é€‰æ‹©è¦åº”ç”¨çš„é¢„è®¾')) || alert('è¯·é€‰æ‹©è¦åº”ç”¨çš„é¢„è®¾');
      applyPresetToCurrentChat(selVal);
    });
    if (saveBtn) saveBtn.addEventListener('click', saveCurrentTextareaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManagePresetsModal);
    if (modalClose) modalClose.addEventListener('click', () => {
      document.getElementById('bubble-presets-modal').style.display = 'none';
    });
  }
// START: æ–°å¢ - HTMLå°å‰§åœºå®‰å…¨äº¤äº’å¤„ç†å‡½æ•°
// [ä¿®æ­£] å°†å‡½æ•°é™„åŠ åˆ° window å¯¹è±¡ï¼Œä½¿å…¶æˆä¸ºå…¨å±€å‡½æ•°ï¼Œä»¥ä¾¿ HTML onclick å¯ä»¥è°ƒç”¨
// START: ä¿®å¤ç‰ˆ handleTheaterClick (ç²¾å‡†å®šä½ï¼Œåªæ“ä½œå½“å‰å‰§åœºå†…éƒ¨å…ƒç´ )
window.handleTheaterClick = function(element, action, targetSelector, value) {
    try {
        // 1. å¯»æ‰¾å½“å‰å°å‰§åœºçš„æ ¹å®¹å™¨ (è¿™æ˜¯æœ€å…³é”®çš„ä¸€æ­¥ï¼Œåˆ’å®šæ“ä½œèŒƒå›´)
        const theaterRoot = element.closest('.ai-generated-theater') || element.closest('.ai-theater');
        
        if (!theaterRoot) {
            console.warn("æœªæ‰¾åˆ°å°å‰§åœºæ ¹å®¹å™¨ï¼Œæ— æ³•æ‰§è¡Œæ“ä½œã€‚");
            return;
        }

        // 2. åœ¨ *å½“å‰å°å‰§åœºå†…éƒ¨* æŸ¥æ‰¾ç›®æ ‡å…ƒç´ 
        // è¿™æ ·å³ä½¿é¡µé¢ä¸Šæœ‰100ä¸ª id="page1" çš„å…ƒç´ ï¼Œæˆ‘ä»¬ä¹Ÿåªä¼šæ‰¾åˆ°å½“å‰è¿™ä¸€ä¸ª
        const targetElement = theaterRoot.querySelector(targetSelector);
        
        if (!targetElement) {
             // å¦‚æœç›´æ¥æŸ¥æ‰¾å¤±è´¥ï¼Œå°è¯•æŸ¥æ‰¾å¸¦åç¼€çš„ID (å› ä¸ºæˆ‘ä»¬ä¹‹å‰åŠ äº†åç¼€)
             // è¿™ä¸€æ­¥æ˜¯ä¸ºäº†å…¼å®¹æ—§çš„IDé€»è¾‘
             const suffixMatch = theaterRoot.innerHTML.match(/id=["']([a-zA-Z0-9_-]+?)_([a-zA-Z0-9]{6})["']/);
             if (suffixMatch) {
                 const suffix = suffixMatch[2];
                 const selectorWithoutHash = targetSelector.replace('#', '');
                 const newSelector = `#${selectorWithoutHash}_${suffix}`;
                 const retryTarget = theaterRoot.querySelector(newSelector);
                 if (retryTarget) {
                     performAction(retryTarget, action, value);
                     return;
                 }
             }
             return;
        }

        performAction(targetElement, action, value);

    } catch (e) {
        console.error("å¤„ç†å°å‰§åœºäº¤äº’æ—¶å‡ºé”™:", e);
    }

    function performAction(el, act, val) {
        switch (act) {
            case 'toggle-class':
                el.classList.toggle(val);
                break;
            case 'add-class':
                el.classList.add(val);
                break;
            case 'remove-class':
                el.classList.remove(val);
                break;
            case 'set-text':
                el.textContent = val;
                break;
            case 'show': // ä¸“é—¨ç”¨äºé¡µé¢åˆ‡æ¢
                el.style.display = 'block';
                break;
            case 'hide': // ä¸“é—¨ç”¨äºé¡µé¢åˆ‡æ¢
                el.style.display = 'none';
                break;
             case 'switch-tab': 
                // è¿™æ˜¯ä¸€ä¸ªé«˜çº§æ“ä½œï¼šéšè—å½“å‰ç»„çš„æ‰€æœ‰å…¶ä»–é¡µï¼Œåªæ˜¾ç¤ºç›®æ ‡é¡µ
                // éœ€è¦æŒ‰é’®æä¾› grouping classï¼Œä¾‹å¦‚ "tab-page"
                const groupClass = val; // å‡è®¾ val ä¼ çš„æ˜¯ "tab-page"
                const container = el.parentElement; 
                if (container) {
                    const allTabs = container.querySelectorAll('.' + groupClass);
                    allTabs.forEach(tab => tab.style.display = 'none'); // éšè—åŒä¸€ç»„çš„æ‰€æœ‰é¡µ
                    el.style.display = 'block'; // æ˜¾ç¤ºç›®æ ‡é¡µ
                }
                break;
        }
    }
}

// END: æ–°å¢ - HTMLå°å‰§åœºå®‰å…¨äº¤äº’å¤„ç†å‡½æ•°
  // åˆå§‹åŒ–ç»‘å®š
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => { try { bindBubblePresetUI(); } catch(e){ console.warn('ç»‘å®šæ°”æ³¡é¢„è®¾å¤±è´¥', e); } });
  } else {
    setTimeout(() => { try { bindBubblePresetUI(); } catch(e){ console.warn('ç»‘å®šæ°”æ³¡é¢„è®¾å¤±è´¥', e); } }, 50);
  }
})();


// === /ChatGPT æ’å…¥ï¼šAPI é¢„è®¾è„šæœ¬ === 

(function(){
  if (window._apiPresetsScriptLoaded) return;
  window._apiPresetsScriptLoaded = true;

  function _getApiPresets() {
    try { return JSON.parse(localStorage.getItem('apiPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveApiPresets(arr) {
    localStorage.setItem('apiPresets', JSON.stringify(arr || []));
  }

  function populateApiSelect() {
    const sel = document.getElementById('api-preset-select');
    if (!sel) return;
    const presets = _getApiPresets();
    sel.innerHTML = '<option value="">â€” é€‰æ‹© API é¢„è®¾ â€”</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  function saveCurrentApiAsPreset() {
    // Try to gather API settings fields: try to detect common fields like #setting-api-key, #setting-api-url, etc.
    const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
    const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
    const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

    const data = {
      apiKey: apiKeyEl ? apiKeyEl.value : '',
      apiUrl: apiUrlEl ? apiUrlEl.value : '',
      provider: providerEl ? providerEl.value : '',
      // capture whole form as fallback
      raw: {}
    };
    // gather inputs inside same settings container if possible
    const container = apiKeyEl ? apiKeyEl.closest('form,div') : null;
    if (container) {
      const inputs = container.querySelectorAll('input,select,textarea');
      inputs.forEach(i => { try { data.raw[i.name || i.id || i.getAttribute('data-key') || ('f_'+Math.random().toString(36).slice(2))] = i.value; } catch(e){} });
    }
    let name = prompt('ä¸ºè¯¥ API é¢„è®¾å¡«å†™åç§°ï¼ˆä¼šè¦†ç›–åŒåé¢„è®¾ï¼‰ï¼š');
    if (!name) return;
    const presets = _getApiPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = {name: name, data: data};
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveApiPresets(presets);
    populateApiSelect();
    (window.showToast && showToast('API é¢„è®¾å·²ä¿å­˜')) || console.log('API é¢„è®¾å·²ä¿å­˜');
  }

  async function applyApiPreset(name) {
    const presets = _getApiPresets();
    const p = presets.find(x => x.name === name);
    if (!p) return (window.showToast && showToast('æœªæ‰¾åˆ°è¯¥é¢„è®¾')) || alert('æœªæ‰¾åˆ°è¯¥é¢„è®¾');
    // Try to populate detected fields
    try {
      const apiKeyEl = document.querySelector('#setting-api-key, input[name="apiKey"], input[id*="api-key"], input[id*="apikey"]');
      const apiUrlEl = document.querySelector('#setting-api-url, input[name="apiUrl"], input[id*="api-url"], input[id*="apiurl"]');
      const providerEl = document.querySelector('#setting-api-provider, select[name="provider"], select[id*="provider"]');

      if (apiKeyEl && p.data && typeof p.data.apiKey !== 'undefined') apiKeyEl.value = p.data.apiKey;
      if (apiUrlEl && p.data && typeof p.data.apiUrl !== 'undefined') apiUrlEl.value = p.data.apiUrl;
      if (providerEl && p.data && typeof p.data.provider !== 'undefined') providerEl.value = p.data.provider;

      // populate raw fields if present
      if (p.data && p.data.raw) {
        for (const k in p.data.raw) {
          try {
            const el = document.querySelector('#'+k+', [name="'+k+'"]');
            if (el) el.value = p.data.raw[k];
          } catch(e){}
        }
      }

      (window.showToast && showToast('å·²åº”ç”¨ API é¢„è®¾')) || console.log('å·²åº”ç”¨ API é¢„è®¾');
    } catch(e) {
      console.error('applyApiPreset error', e);
    }
  }

  function openApiManageModal() {
    const modal = document.getElementById('api-presets-modal');
    const list = document.getElementById('api-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getApiPresets();
    if (!presets.length) {
      list.innerHTML = '<p style="color:#888;margin:6px 0;">æš‚æ— é¢„è®¾</p>';
    }
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 6px';
      row.style.borderBottom = '1px solid #f6f6f6';

      const left = document.createElement('div');
      left.style.flex = '1';
      left.style.minWidth = '0';
      left.innerHTML = '<div style="font-weight:600;">'+p.name+'</div><div style="font-size:12px;color:#666;margin-top:4px;">' + (p.data && p.data.provider ? ('æä¾›è€…ï¼š'+p.data.provider) : '') + '</div>';

      const btns = document.createElement('div');
      btns.style.display = 'flex';
      btns.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn';
      applyBtn.textContent = 'åº”ç”¨';
      applyBtn.onclick = function(){ applyApiPreset(p.name); modal.style.display='none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.textContent = 'é‡å‘½å';
      renameBtn.onclick = function(){
        const newName = prompt('è¾“å…¥æ–°åç§°ï¼š', p.name);
        if (!newName) return;
        const all = _getApiPresets();
        all[idx].name = newName;
        _saveApiPresets(all);
        openApiManageModal();
        populateApiSelect();
      };

      const delBtn = document.createElement('button');
      delBtn.className = 'btn';
      delBtn.textContent = 'åˆ é™¤';
      delBtn.onclick = function(){ if(!confirm('ç¡®å®šåˆ é™¤ "'+p.name+'" ?')) return; const all=_getApiPresets(); all.splice(idx,1); _saveApiPresets(all); openApiManageModal(); populateApiSelect(); };

      btns.appendChild(applyBtn); btns.appendChild(renameBtn); btns.appendChild(delBtn);

      row.appendChild(left); row.appendChild(btns);
      list.appendChild(row);
    });
    modal.style.display = 'flex';
  }

  // export / import handlers
  function exportApiPresets() {
    const presets = _getApiPresets();
    const blob = new Blob([JSON.stringify(presets, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'api_presets.json'; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }
  function importApiPresets() {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.accept = 'application/json';
    inp.onchange = function(e){
      const f = e.target.files[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = function(){ try { const data = JSON.parse(r.result); if (Array.isArray(data)) { _saveApiPresets(data); populateApiSelect(); openApiManageModal(); } else alert('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®'); } catch(e){ alert('å¯¼å…¥å¤±è´¥ï¼š'+e.message); } };
      r.readAsText(f);
    };
    inp.click();
  }

  // bind UI
  function bind() {
    populateApiSelect();
    const saveBtn = document.getElementById('api-save-preset');
    const manageBtn = document.getElementById('api-manage-presets');
    const applyBtn = document.getElementById('api-apply-preset');
    const select = document.getElementById('api-preset-select');
    const modalClose = document.getElementById('api-close-modal');
    const importBtn = document.getElementById('api-import-presets');
    const exportBtn = document.getElementById('api-export-presets');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentApiAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openApiManageModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v=select.value; if(!v) return (window.showToast&&showToast('è¯·é€‰æ‹©é¢„è®¾'))||alert('è¯·é€‰æ‹©é¢„è®¾'); applyApiPreset(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('api-presets-modal').style.display='none'; });
    if (importBtn) importBtn.addEventListener('click', importApiPresets);
    if (exportBtn) exportBtn.addEventListener('click', exportApiPresets);

    if (select) select.addEventListener('change', function(){ /* optional: preview selection */ });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);

})();


// === ChatGPT æ’å…¥è„šæœ¬ï¼šæˆ‘çš„äººè®¾é¢„è®¾é€»è¾‘ï¼ˆæ”¾åˆ°é¡µé¢è„šæœ¬å—ï¼‰ === 

(function(){
  if (window._myPersonaPresetScriptLoaded) return;
  window._myPersonaPresetScriptLoaded = true;

  // å­˜å– localStorage
  function _getMyPersonaPresets() {
    try { return JSON.parse(localStorage.getItem('myPersonaPresets') || '[]'); }
    catch(e){ return []; }
  }
  function _saveMyPersonaPresets(arr) {
    localStorage.setItem('myPersonaPresets', JSON.stringify(arr || []));
  }

  // å¡«å……ä¸‹æ‹‰
  function populateMyPersonaSelect() {
    const sel = document.getElementById('mypersona-preset-select');
    if (!sel) return;
    const presets = _getMyPersonaPresets();
    sel.innerHTML = '<option value="">â€” é€‰æ‹©é¢„è®¾ â€”</option>';
    presets.forEach(p => {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
  }

  // ä¿å­˜å½“å‰ä¾§æ ï¼ˆæˆ‘çš„äººè®¾ + æˆ‘çš„å¤´åƒï¼‰ä¸ºé¢„è®¾
  function saveCurrentMyPersonaAsPreset() {
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (!personaEl || !avatarEl) return (window.showToast && showToast('æ‰¾ä¸åˆ°æˆ‘çš„äººè®¾æˆ–å¤´åƒæ§ä»¶')) || alert('æ‰¾ä¸åˆ°æˆ‘çš„äººè®¾æˆ–å¤´åƒæ§ä»¶');
    const persona = personaEl.value.trim();
    const avatar = avatarEl.src || '';
    if (!persona && !avatar) return (window.showToast && showToast('äººè®¾å’Œå¤´åƒéƒ½ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜')) || alert('äººè®¾å’Œå¤´åƒéƒ½ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜');
    const name = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼ˆå°†è¦†ç›–åŒåé¢„è®¾ï¼‰ï¼š');
    if (!name) return;
    const presets = _getMyPersonaPresets();
    const idx = presets.findIndex(p => p.name === name);
    const preset = { name, persona, avatar };
    if (idx >= 0) presets[idx] = preset; else presets.push(preset);
    _saveMyPersonaPresets(presets);
    populateMyPersonaSelect();
    (window.showToast && showToast('æˆ‘çš„äººè®¾é¢„è®¾å·²ä¿å­˜')) || console.log('æˆ‘çš„äººè®¾é¢„è®¾å·²ä¿å­˜');
  }

  // å°†é¢„è®¾åº”ç”¨åˆ°å½“å‰èŠå¤©ï¼ˆåŒæ—¶å†™ UI + db.charactersï¼Œå¹¶ä¿å­˜ï¼‰
  async function applyMyPersonaPresetToCurrentChat(presetName) {
    const presets = _getMyPersonaPresets();
    const p = presets.find(x => x.name === presetName);
    if (!p) { (window.showToast && showToast('æœªæ‰¾åˆ°è¯¥é¢„è®¾')) || alert('æœªæ‰¾åˆ°è¯¥é¢„è®¾'); return; }

    // æ›´æ–°ç•Œé¢
    const personaEl = document.getElementById('setting-my-persona');
    const avatarEl = document.getElementById('setting-my-avatar-preview');
    if (personaEl) personaEl.value = p.persona || '';
    if (avatarEl) avatarEl.src = p.avatar || '';

    // å°è¯•å†™å…¥å½“å‰ chat å¯¹è±¡ï¼ˆä¸æ°”æ³¡é¢„è®¾åšæ³•ä¸€è‡´ï¼‰
    try {
      if (typeof currentChatId !== 'undefined' && window.db && Array.isArray(db.characters)) {
        const e = db.characters.find(c => c.id === currentChatId);
        if (e) {
          e.myPersona = p.persona || '';
          e.myAvatar = p.avatar || '';
          if (typeof saveData === 'function') await saveData();
          (window.showToast && showToast('é¢„è®¾å·²åº”ç”¨å¹¶ä¿å­˜åˆ°å½“å‰èŠå¤©')) || console.log('é¢„è®¾å·²åº”ç”¨');
          // åˆ·æ–°ä¾§æ ä¸åˆ—è¡¨ä»¥æ˜¾ç¤ºæ›´æ–°
          if (typeof loadSettingsToSidebar === 'function') try{ loadSettingsToSidebar(); }catch(e){}
          if (typeof renderChatList === 'function') try{ renderChatList(); }catch(e){}
        }
      } else {
        (window.showToast && showToast('é¢„è®¾å·²åº”ç”¨åˆ°ç•Œé¢ï¼ˆæœªæ£€æµ‹åˆ°å½“å‰èŠå¤©ä¿å­˜å…¥å£ï¼‰')) || console.log('é¢„è®¾å·²åº”ç”¨åˆ°ç•Œé¢');
      }
    } catch(err) {
      console.error('applyMyPersonaPresetToCurrentChat error', err);
    }
  }

  // ç®¡ç† Modal
  function openManageMyPersonaModal() {
    const modal = document.getElementById('mypersona-presets-modal');
    const list = document.getElementById('mypersona-presets-list');
    if (!modal || !list) return;
    list.innerHTML = '';
    const presets = _getMyPersonaPresets();
    if (!presets.length) list.innerHTML = '<p style="color:#888;margin:6px 0;">æš‚æ— é¢„è®¾</p>';
    presets.forEach((p, idx) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px 0';
      row.style.borderBottom = '1px solid #f0f0f0';

      const nameDiv = document.createElement('div');
      nameDiv.style.flex = '1';
      nameDiv.style.whiteSpace = 'nowrap';
      nameDiv.style.overflow = 'hidden';
      nameDiv.style.textOverflow = 'ellipsis';
      nameDiv.textContent = p.name;
      row.appendChild(nameDiv);

      const btnWrap = document.createElement('div');
      btnWrap.style.display = 'flex';
      btnWrap.style.gap = '6px';

      const applyBtn = document.createElement('button');
      applyBtn.className = 'btn btn-primary';
      applyBtn.style.padding = '6px 8px;border-radius:8px';
      applyBtn.textContent = 'åº”ç”¨';
      applyBtn.onclick = function(){ applyMyPersonaPresetToCurrentChat(p.name); modal.style.display = 'none'; };

      const renameBtn = document.createElement('button');
      renameBtn.className = 'btn';
      renameBtn.style.padding = '6px 8px;border-radius:8px';
      renameBtn.textContent = 'é‡å‘½å';
      renameBtn.onclick = function(){
        const newName = prompt('è¾“å…¥æ–°åç§°ï¼š', p.name);
        if (!newName) return;
        const all = _getMyPersonaPresets();
        all[idx].name = newName;
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn';
      deleteBtn.style.padding = '6px 8px;border-radius:8px;color:#e53935';
      deleteBtn.textContent = 'åˆ é™¤';
      deleteBtn.onclick = function(){
        if (!confirm('ç¡®è®¤åˆ é™¤è¯¥é¢„è®¾ï¼Ÿ')) return;
        const all = _getMyPersonaPresets();
        all.splice(idx,1);
        _saveMyPersonaPresets(all);
        openManageMyPersonaModal();
        populateMyPersonaSelect();
      };

      btnWrap.appendChild(applyBtn);
      btnWrap.appendChild(renameBtn);
      btnWrap.appendChild(deleteBtn);
      row.appendChild(btnWrap);

      list.appendChild(row);
    });

    modal.style.display = 'flex';
  }

  // ç»‘å®š UI
  function bind() {
    populateMyPersonaSelect();
    const saveBtn = document.getElementById('mypersona-save-btn');
    const manageBtn = document.getElementById('mypersona-manage-btn');
    const applyBtn = document.getElementById('mypersona-apply-btn');
    const select = document.getElementById('mypersona-preset-select');
    const modalClose = document.getElementById('mypersona-close-modal');

    if (saveBtn) saveBtn.addEventListener('click', saveCurrentMyPersonaAsPreset);
    if (manageBtn) manageBtn.addEventListener('click', openManageMyPersonaModal);
    if (applyBtn) applyBtn.addEventListener('click', function(){ const v = select.value; if(!v) return (window.showToast && showToast('è¯·é€‰æ‹©è¦åº”ç”¨çš„é¢„è®¾')) || alert('è¯·é€‰æ‹©è¦åº”ç”¨çš„é¢„è®¾'); applyMyPersonaPresetToCurrentChat(v); });
    if (modalClose) modalClose.addEventListener('click', function(){ document.getElementById('mypersona-presets-modal').style.display='none'; });

    // é¡µé¢å¯èƒ½åœ¨åŠ è½½åæ”¹å˜ä¾§æ æ•°æ®ï¼Œå°è¯•åœ¨ DOMContentLoaded æˆ–å·²æœ‰ç»‘å®šååˆå§‹åŒ–
    // å½“æœ‰å…¶ä»–ä»£ç é‡ç½® sidebar æ—¶ï¼Œå¯æ‰‹åŠ¨è°ƒç”¨ populateMyPersonaSelect()
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else setTimeout(bind,50);
  

})();



  // åˆå§‹åŒ–é»˜è®¤å€¼ï¼ˆå¯æŒ‰éœ€æ›¿æ¢ä¸ºåŠ¨æ€æ•°æ®ï¼‰
  (function(){
    document.addEventListener('DOMContentLoaded', function(){
      try {
        // é»˜è®¤æ–‡æœ¬ï¼Œéµå¾ªä½ çš„è¦æ±‚
        const defaults = {
          name: 'Skeleton',
          signature: 'æŠŠå¿ƒæƒ…å†™åœ¨è¿™é‡Œå§â™¥',
          id: 'user',
          location: 'è‡ªå®šä¹‰å®šä½',
          avatarSrc: null, // null ä½¿ç”¨ç™½è‰²é»˜è®¤å›¾
          heroBg: '#000' // çº¯é»‘èƒŒæ™¯
        };

        const nameEl = document.getElementById('icity-name');
        const sigEl = document.getElementById('icity-signature');
        const idEl = document.getElementById('icity-id');
        const locEl = document.getElementById('icity-loc-text');
        const avatarEl = document.getElementById('icity-avatar');
        const heroEl = document.getElementById('icity-hero');

        if (nameEl) nameEl.textContent = defaults.name;
        if (sigEl) sigEl.textContent = defaults.signature;
        if (idEl) idEl.textContent = defaults.id;
        if (locEl) locEl.textContent = defaults.location;
        if (heroEl) heroEl.style.background = defaults.heroBg;

        // ---- Profile helpers: load/save/render ----
        window.loadProfileFromStorage = function(){
            return {
                name: localStorage.getItem('myTopName') || defaults.name,
                id: localStorage.getItem('myTopId') || defaults.id,
                location: localStorage.getItem('myTopLoc') || defaults.location,
                signature: localStorage.getItem('myTopSignature') || defaults.signature,
                avatar: localStorage.getItem('myTopAvatar') || (defaults.avatarSrc || ''),
                heroBg: localStorage.getItem('myTopBg') || (defaults.heroBg || '')
            };
        }
        function saveProfileToStorage(profile){
            if(profile.name!=null) localStorage.setItem('myTopName', profile.name);
            if(profile.id!=null) localStorage.setItem('myTopId', profile.id);
            if(profile.location!=null) localStorage.setItem('myTopLoc', profile.location);
            if(profile.signature!=null) localStorage.setItem('myTopSignature', profile.signature);
            if(profile.avatar!=null) localStorage.setItem('myTopAvatar', profile.avatar);
            if(profile.heroBg!=null) localStorage.setItem('myTopBg', profile.heroBg);
        }
        function renderProfileAndSync(){
            const p = loadProfileFromStorage();
            if(nameEl) nameEl.textContent = p.name;
            if(sigEl) sigEl.textContent = p.signature;
            if(idEl) idEl.textContent = p.id;
            if(locEl) locEl.textContent = p.location;
            if(avatarEl){
                if(p.avatar) avatarEl.src = p.avatar;
                // also update global avatar displays
                document.querySelectorAll('.my-avatar, #moments-screen .top-avatar, .top-avatar').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || '';
                    else img.style.backgroundImage = p.avatar? `url('${p.avatar}')` : '';
                });
                // update moment avatars (sync instead of snapshot)
                document.querySelectorAll('.moment-avatar, .post .avatar-img').forEach(img=>{
                    if(img.tagName==='IMG') img.src = p.avatar || img.src;
                });
            }
            if(heroEl){
                if(p.heroBg){
                    if(p.heroBg.startsWith('http') || p.heroBg.startsWith('data:') || p.heroBg.startsWith('url(')){
                        heroEl.style.backgroundImage = `url('${p.heroBg}')`;
                        heroEl.style.backgroundSize = 'cover';
                        heroEl.style.backgroundPosition = 'center';
                    } else {
                        heroEl.style.background = p.heroBg;
                    }
                } else {
                    heroEl.style.background = defaults.heroBg;
                }
            }
            // If there is a moments renderer, call it to re-render posts with updated profile data
            if(typeof renderMoments === 'function') {
                try{ renderMoments(); }catch(e){}
            } else if(typeof window.renderMomentsSafe === 'function'){
                try{ window.renderMomentsSafe(); }catch(e){}
            }
        }

        // ---- Click handlers per your requirement (separate triggers) ----
        // Clicking hero edits background; clicking avatar edits avatar
        try {
            const bgBtn = document.getElementById('edit-bg-btn');
            const avatarBtn = document.getElementById('edit-avatar-btn');
            if(heroEl) heroEl.addEventListener('click', ()=> { if(bgBtn) bgBtn.click(); });
            if(avatarEl) avatarEl.addEventListener('click', ()=> { if(avatarBtn) avatarBtn.click(); });
        } catch(e){ console.warn('bind bg/avatar click failed', e); }

        // Inline edit helper for text fields (name, id, location, signature)
        function inlineEditText(el, key, placeholder){
            if(!el) return;
            el.style.cursor = 'text';
            el.addEventListener('click', function handler(e){
                e.stopPropagation();
                const old = el.textContent || '';
                const input = document.createElement('input');
                input.type = 'text';
                input.value = old;
                input.placeholder = placeholder || '';
                input.style.fontSize = window.getComputedStyle(el).fontSize;
                input.style.width = '100%';
                input.style.boxSizing = 'border-box';
                el.replaceWith(input);
                input.focus();
                function commit(){
                    const v = input.value.trim();
                    const profile = loadProfileFromStorage();
                    profile[key] = v;
                    saveProfileToStorage(profile);
                    renderProfileAndSync();
                    input.removeEventListener('blur', onBlur);
                    input.removeEventListener('keydown', onKey);
                }
                function onBlur(){ commit(); input.replaceWith(el); }
                function onKey(ev){ if(ev.key === 'Enter'){ commit(); input.replaceWith(el); } else if(ev.key==='Escape'){ input.replaceWith(el); } }
                input.addEventListener('blur', onBlur);
                input.addEventListener('keydown', onKey);
            }, { once: false });
        }

        inlineEditText(nameEl, 'name', 'è¯·è¾“å…¥åç§°');
        inlineEditText(idEl, 'id', 'è¯·è¾“å…¥IDï¼ˆå°†ä½œä¸º authorIdï¼‰');
        inlineEditText(locEl, 'location', 'è¯·è¾“å…¥å®šä½æ–‡æœ¬');
        inlineEditText(sigEl, 'signature', 'è¯·è¾“å…¥ä¸ªæ€§ç­¾å');

        // Initial render from storage
        renderProfileAndSync();

        if (defaults.avatarSrc) {
          avatarEl.src = defaults.avatarSrc;
        }

        // å¤´åƒç‚¹å‡»äº‹ä»¶å ä½
        const wrap = document.getElementById('icity-avatar-wrap');
        if (wrap) {
          wrap.addEventListener('click', function(){
            console.log('icity avatar clicked');
          });
        }

      } catch (e) {
        console.warn('icity header init error', e);
      }
    });
  })();



(function() {
  // ç­‰ DOM å®Œå…¨åŠ è½½
  document.addEventListener('DOMContentLoaded', () => {
    // --- å…¨å±€è¾…åŠ©å‡½æ•° ---
    window.getAuthorNameById = function(authorId) {
        if (!authorId) return 'æœªçŸ¥';
        // ä¼˜å…ˆä»é¡¶æ ä¿¡æ¯è·å–è‡ªå·±çš„åå­—
        if (typeof loadProfileFromStorage === 'function') {
            const myProfile = loadProfileFromStorage();
            if (myProfile && myProfile.id === authorId) {
                return myProfile.name || 'æˆ‘';
            }
        }
        // ä»å…¨å±€ db å¯¹è±¡æŸ¥æ‰¾
        if (window.db) { // This now refers to the main data object, not Dexie.
            if (window.db.characters) {
                const character = window.db.characters.find(c => c.id === authorId);
                if (character) return character.remarkName;
            }
            if (window.db.groups) {
                for (const group of window.db.groups) {
                    if (group.members) {
                        const member = group.members.find(m => m.id === authorId);
                        if (member) return member.groupNickname;
                    }
                }
            }
        }
        // Fallback
        return authorId.startsWith('char_') ? 'æŸè§’è‰²' : authorId;
    };

    // --- ç®€å•å·¥å…·å‡½æ•° ---
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    function escapeText(t) { return String(t == null ? '' : t); }

    // 1) åˆå§‹åŒ– Dexieï¼ˆä½¿ç”¨é¡µé¢å·²å¼•å…¥çš„ Dexieï¼‰
    let db;
    try {
      db = new Dexie('AppDB_Moments');
      db.version(1).stores({
        moments: 'id,timestamp,commentedBy' // comments å’Œ likes å­˜åœ¨äºå¯¹è±¡å†…
      });
      // expose to window so external scripts can access the Dexie instance
      try{ window.AppDB_Moments = db; }catch(e){}

    } catch (e) {
      console.error('Dexie init failed', e);
      showToast('æœ¬åœ°æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼ŒåŠ¨æ€åŠŸèƒ½å—é™');
      return;
    }
    // 2) DOM å…ƒç´ 
    const openPostBtn = $('#open-post-modal');
    const postModal = $('#post-modal');
    const postForm = $('#post-form');
    const addImageCheckbox = $('#add-image');
    const imageInputGroup = $('#image-input-group');
    const postImageInput = $('#post-image');
    const imageDescInput = $('#image-description');
    const postImagePreview = $('#post-image-preview');
    const cancelPostBtn = $('#cancel-post-btn');
    const momentsContainer = $('#moments-container');
    const momentsEmpty = $('#moments-empty');
    const momentsScreen = $('#moments-screen');
    const bottomNavHost = document.getElementById('bottom-nav-host');
if (typeof setupMentions === 'function') {
        try {
            setupMentions();
        } catch (e) {
            console.error("åœ¨åŠ¨æ€æ¨¡å—ä¸­åˆå§‹åŒ–æåŠåŠŸèƒ½å¤±è´¥:", e);
        }
    }
    // 3) ç»‘å®šæ‰“å¼€/å…³é—­å‘å¸ƒæ¨¡æ€
    if (openPostBtn) openPostBtn.addEventListener('click', () => {
      postModal.style.display = 'flex';
      postModal.classList.add('visible');
    });
    if (cancelPostBtn) cancelPostBtn.addEventListener('click', closePostModal);
    function closePostModal() {
      postModal.style.display = 'none';
      postModal.classList.remove('visible');
      postForm.reset();
      // æ¸…ç†å›¾ç‰‡é¢„è§ˆä¸æ–‡ä»¶è¾“å…¥ï¼Œé¿å…æ®‹ç•™ dataURL æˆ–é¡µé¢ URL å¯¼è‡´åç»­å‘å¸ƒå¼‚å¸¸
      try { postImagePreview.src = ''; } catch(e){}
      try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){}
      postImagePreview.style.display = 'none';
      imageInputGroup.style.display = 'none';
    }

    addImageCheckbox.addEventListener('change', e => {
      // å¦‚æœå–æ¶ˆæ·»åŠ å›¾ç‰‡ï¼Œæ¸…ç†ä¹‹å‰çš„é¢„è§ˆå’Œæ–‡ä»¶è¾“å…¥
      if (!addImageCheckbox.checked) { try { postImagePreview.src = ''; } catch(e){} try { const pi = document.getElementById('post-image'); if(pi) pi.value = ''; } catch(e){} }

      imageInputGroup.style.display = e.target.checked ? 'block' : 'none';
    });

    

    async function fileToDataURLAndCompress(file, maxWidth = 1200, quality = 0.85) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(ev) {
          const img = new Image();
          img.onload = function() {
            const w = img.width, h = img.height;
            let nw = w, nh = h;
            if (w > maxWidth) {
              nw = maxWidth;
              nh = Math.round(h * (maxWidth / w));
            }
            const canvas = document.createElement('canvas');
            canvas.width = nw;
            canvas.height = nh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, nw, nh);
            const out = canvas.toDataURL('image/jpeg', quality);
            resolve(out);
          };
          img.onerror = reject;
          img.src = ev.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    // 4) å‘å¸ƒåŠ¨æ€ï¼ˆå†™å…¥ Dexieï¼‰
    

// --- Safe addMoment helper (injected by assistant) ---
async function addMomentToDB(momentObj) {
  // 1) Prefer global Dexie instance AppDB_Moments if available
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.add === 'function') {
      return window.AppDB_Moments.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 2) If window.db.moments looks like Dexie, use it
  try {
    if (window.db && window.db.moments && typeof window.db.moments.add === 'function') {
      return window.db.moments.add(momentObj);
    }
  } catch(e){ /* ignore */ }

  // 3) Fallback to in-memory array and try to persist via saveData()
  if (!window.db) window.db = {};
  if (!Array.isArray(window.db.moments)) window.db.moments = [];
  window.db.moments.push(momentObj);

  if (typeof window.saveData === 'function') {
    try { await window.saveData(); } catch(e){ console.warn('saveData fallback failed', e); }
  }

  // 4) Try to mirror into AppDB_Moments (put to avoid duplicate key issues)
  try {
    if (window.AppDB_Moments && window.AppDB_Moments.moments && typeof window.AppDB_Moments.moments.put === 'function') {
      await window.AppDB_Moments.moments.put(momentObj);
    }
  } catch(e){ console.warn('mirror to AppDB_Moments failed', e); }

  return Promise.resolve();
}

// --- Replaced postForm submit handler (injected by assistant) ---
postForm.addEventListener('submit', async (ev) => {
  ev.preventDefault();

  const submitBtn = postForm.querySelector('button[type=\"submit\"]');
  if (submitBtn) submitBtn.disabled = true;

  // adapt these IDs to match your form inputs if they differ
  const textEl = document.getElementById('post-text');
  const addImageEl = document.getElementById('add-image');
  const imageDescEl = document.getElementById('image-description');

  const text = textEl ? textEl.value.trim() : '';
  const addImage = addImageEl ? addImageEl.checked : false;
  const imageDesc = imageDescEl ? imageDescEl.value.trim() : '';

  if (!text && !addImage) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('è¯·è¾“å…¥åŠ¨æ€å†…å®¹');
    return;
  }

  if (addImage && !imageDesc) {
    if (submitBtn) submitBtn.disabled = false;
    if (typeof showToast === 'function') showToast('è¯·è¾“å…¥å›¾ç‰‡æè¿°');
    return;
  }

  const id = 'm_' + Date.now() + '_' + Math.random().toString(36).slice(2,8);
  const momentObj = {
    id,
    authorId: (localStorage.getItem('myTopId') || 'user'),
    authorAvatar: (localStorage.getItem('myTopAvatar') || null),
    text,
    imageDesc: addImage ? imageDesc : '',
    timestamp: Date.now(),
    commentedBy: [],
    comments: [],
    likes: []
  };

  try {
    await addMomentToDB(momentObj);

    if (typeof showToast === 'function') showToast('å‘å¸ƒæˆåŠŸ');
    try { if (typeof closePostModal === 'function') closePostModal(); } catch(e){}

    // Force immediate re-render of moments
    if (typeof renderMoments === 'function') {
      try { await renderMoments(); } catch(e){ console.warn('renderMoments failed', e); }
    } else if (typeof window.renderMomentsSafe === 'function') {
      try { await window.renderMomentsSafe(); } catch(e){ console.warn('renderMomentsSafe failed', e); }
    } else {
      // last resort: toggle screen class to force repaint
      const ms = document.getElementById('moments-screen');
      if (ms) {
        ms.classList.remove('active');
        setTimeout(()=>ms.classList.add('active'), 10);
      }
    }
  } catch (e) {
    console.error('add moment err', e);
    if (typeof showToast === 'function') showToast('ä¿å­˜å¤±è´¥: ' + (e && e.message ? e.message : String(e)));
  } finally {
    if (submitBtn) submitBtn.disabled = false;
  }
});



    // 5) æ¸²æŸ“åŠ¨æ€åˆ—è¡¨
// 5) æ¸²æŸ“åŠ¨æ€åˆ—è¡¨ (å·²ä¿®å¤ï¼šæ­£ç¡®æ˜¾ç¤ºå›å¤å…³ç³»)
// 5) æ¸²æŸ“åŠ¨æ€åˆ—è¡¨ (ç»ˆæä¿®å¤ç‰ˆï¼šå¼ºåˆ¶æ¥ç®¡æ˜¾ç¤ºï¼Œæ”¯æŒç›–æ¥¼)
// â–¼â–¼â–¼â–¼â–¼â–¼ è¡¥å…¨ä¸¢å¤±çš„å·¥å…·å‡½æ•° â–¼â–¼â–¼â–¼â–¼â–¼
    function getAuthorProfile(authorId) {
        // é»˜è®¤å¤‡ç”¨ä¿¡æ¯
        let profile = { name: 'æœªçŸ¥ç”¨æˆ·', avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg' };

        // 1. æ£€æŸ¥æ˜¯ä¸æ˜¯ç”¨æˆ·è‡ªå·±
        let myProfile = {};
        try {
            if (typeof loadProfileFromStorage === 'function') {
                myProfile = loadProfileFromStorage();
            } else {
                 myProfile = {
                    id: localStorage.getItem('myTopId') || 'user',
                    name: localStorage.getItem('myTopName') || 'æˆ‘',
                    avatar: localStorage.getItem('myTopAvatar')
                };
            }
        } catch (e) {}

        if (authorId === (myProfile.id || 'user')) {
            return { name: myProfile.name || 'æˆ‘', avatar: myProfile.avatar };
        }

        // 2. åœ¨æ‰€æœ‰AIè§’è‰²ä¸­æŸ¥æ‰¾
        if (window.db && Array.isArray(window.db.characters)) {
            const character = window.db.characters.find(c => c.id === authorId);
            if (character) {
                return { name: character.remarkName, avatar: character.avatar };
            }
        }

        // 3. åœ¨æ‰€æœ‰ç¾¤èŠçš„æˆå‘˜ä¸­æŸ¥æ‰¾
        if (window.db && Array.isArray(window.db.groups)) {
            for (const group of window.db.groups) {
                if (Array.isArray(group.members)) {
                    const member = group.members.find(m => m.id === authorId);
                    if (member) {
                        return { name: member.groupNickname, avatar: member.avatar };
                    }
                }
            }
        }
        return profile;
    }
    // â–²â–²â–²â–²â–²â–² å·¥å…·å‡½æ•°è¡¥å…¨ç»“æŸ â–²â–²â–²â–²â–²â–²

    // 5) æ¸²æŸ“åŠ¨æ€åˆ—è¡¨ (åŒ…å«å·¥å…·å‡½æ•°çš„å®Œæ•´ç‰ˆ)
    async function renderMoments() {
        let list = [];
        try {
            // ä¼˜å…ˆè¯»å–æœ€æ–°çš„æ•°æ®åº“
            if (window.AppDB_Moments && window.AppDB_Moments.moments) {
                list = await window.AppDB_Moments.moments.orderBy('timestamp').reverse().toArray();
            } else if (window.db && window.db.moments) {
                list = window.db.moments.sort((a,b) => b.timestamp - a.timestamp);
            }
        } catch(e) { console.warn('Load moments failed', e); }

        const momentsContainer = document.getElementById('moments-container');
        const momentsEmpty = document.getElementById('moments-empty');

        if (!momentsContainer) return;

        momentsContainer.innerHTML = '';

        if (!list.length) {
            if (momentsEmpty) momentsEmpty.style.display = 'block';
            return;
        } else {
            if (momentsEmpty) momentsEmpty.style.display = 'none';
        }

        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';

        list.forEach(m => {
            const div = document.createElement('div');
            div.className = 'moment-item';
            div.dataset.id = m.id || (m.id = ('m_' + Date.now() + Math.random()));

            // --- 1. å¤´éƒ¨ä¿¡æ¯ ---
            const head = document.createElement('div');
            head.className = 'moment-head';
            const avatar = document.createElement('img');
            avatar.className = 'moment-avatar';
            
            const authorInfo = getAuthorProfile(m.authorId);
            avatar.src = authorInfo.avatar || m.authorAvatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
            
            const meta = document.createElement('div');
            meta.className = 'moment-meta';
            const name = document.createElement('div');
            name.style.fontWeight = '700';
            name.textContent = authorInfo.name || m.author || 'æœªçŸ¥ç”¨æˆ·';
            
            const time = document.createElement('div');
            time.style.fontSize = '12px';
            time.style.color = '#999';
            try { time.textContent = new Date(m.timestamp).toLocaleString(); } catch (e) { time.textContent = ''; }
            
            meta.appendChild(name);
            meta.appendChild(time);
            head.appendChild(avatar);
            head.appendChild(meta);
            div.appendChild(head);

            // --- 2. æ­£æ–‡å†…å®¹ ---
            const txt = document.createElement('div');
            txt.className = 'moment-text';
            txt.textContent = m.text || '';
            div.appendChild(txt);

            // --- 3. å›¾ç‰‡å†…å®¹ ---
            if (m.imageData && m.imageData.length > 10) {
                const im = document.createElement('img');
                im.className = 'moment-image';
                im.src = m.imageData;
                im.alt = m.imageDesc || 'åŠ¨æ€å›¾ç‰‡';
                div.appendChild(im);
            } else if (m.imageDesc) {
                const descCard = document.createElement('div');
                descCard.className = 'moment-image-desc-card';
                descCard.innerHTML = `<p class="desc-content">${m.imageDesc}</p>`;
                div.appendChild(descCard);
            }

            // --- 4. æ“ä½œæ  ---
            const actions = document.createElement('div');
            actions.className = 'moment-actions';
            
            const likeBtn = document.createElement('button');
            likeBtn.className = 'moment-action-btn';
            const likes = m.likes || [];
            if (likes.includes(myId)) likeBtn.classList.add('liked');
            
            likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : 'ç‚¹èµ'}</span>`;
            
            likeBtn.addEventListener('click', async (event) => {
                event.stopPropagation();
                const btn = event.currentTarget;
                const likesWrap = div.querySelector('.moment-likes');
                const currentLikes = m.likes || [];
                const myIdx = currentLikes.indexOf(myId);

                if (myIdx > -1) {
                    currentLikes.splice(myIdx, 1);
                    btn.classList.remove('liked');
                } else {
                    currentLikes.push(myId);
                    btn.classList.add('liked');
                }
                m.likes = currentLikes;

                if (window.AppDB_Moments) await window.AppDB_Moments.moments.put(m);

                btn.querySelector('span').textContent = currentLikes.length > 0 ? currentLikes.length : 'ç‚¹èµ';
                if (likesWrap) {
                    if (currentLikes.length > 0) {
                        const likeNames = currentLikes.map(id => getAuthorProfile(id).name).join(', ');
                        likesWrap.innerHTML = `<span class="like-icon">â™¥</span> ${likeNames}`;
                        likesWrap.classList.add('visible');
                    } else {
                        likesWrap.classList.remove('visible');
                    }
                }
            });

            const commentBtn = document.createElement('button');
            commentBtn.className = 'moment-action-btn';
            commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>è¯„è®º</span>`;
            
            commentBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                const inputArea = div.querySelector('.moment-comment-input-area');
                if (inputArea) {
                    inputArea.classList.toggle('visible');
                    const input = inputArea.querySelector('input');
                    const postBtn = inputArea.querySelector('button');
                    input.value = '';
                    input.placeholder = 'æ·»åŠ è¯„è®º...';
                    delete postBtn.dataset.replyToCommentId;
                    delete postBtn.dataset.replyToAuthorId;
                    if (inputArea.classList.contains('visible')) input.focus();
                }
            });

            actions.appendChild(likeBtn);
            actions.appendChild(commentBtn);
            div.appendChild(actions);

            // --- 5. ç‚¹èµåˆ—è¡¨åŒº ---
            const likesWrap = document.createElement('div');
            likesWrap.className = 'moment-likes';
            if (likes.length > 0) {
                const likeNames = likes.map(id => getAuthorProfile(id).name).join(', ');
                likesWrap.innerHTML = `<span class="like-icon">â™¥</span> ${likeNames}`;
                likesWrap.classList.add('visible');
            }
            div.appendChild(likesWrap);

            // --- 6. è¯„è®ºåˆ—è¡¨åŒº (é€’å½’æ¸²æŸ“) ---
            const commentsWrap = document.createElement('div');
            commentsWrap.className = 'moment-comments';

            const renderCommentsFlat = (comments) => {
                if (!comments || comments.length === 0) return;
                
                const traverse = (list) => {
                    list.forEach(c => {
                        const cm = document.createElement('div');
                        cm.className = 'moment-comment';
                        cm.dataset.commentId = c.id;
                        cm.dataset.authorId = c.roleId; 
                        
                        const authorName = getAuthorProfile(c.roleId).name;
                        
                        let replyHtml = '';
                        if (c.replyTo) {
                            const replyToName = getAuthorProfile(c.replyTo).name;
                            replyHtml = `<span style="color:#888; margin: 0 4px;">å›å¤</span><strong>${replyToName}</strong>`;
                        }

                        cm.innerHTML = `<strong>${authorName}</strong>${replyHtml}: <span>${c.text}</span>`;
                        commentsWrap.appendChild(cm);

                        if (c.replies && c.replies.length > 0) {
                            traverse(c.replies);
                        }
                    });
                };
                traverse(comments);
            };

            renderCommentsFlat(m.comments);
            
            if (commentsWrap.innerHTML === '') {
                const none = document.createElement('div');
                none.style.color='#bbb'; none.textContent = 'æš‚æ—¶æ²¡æœ‰è¯„è®º';
                commentsWrap.appendChild(none);
            }
            div.appendChild(commentsWrap);

            // --- 7. è¯„è®ºè¾“å…¥æ¡† ---
            const commentInputArea = document.createElement('div');
            commentInputArea.className = 'moment-comment-input-area';
            commentInputArea.innerHTML = `
              <input type="text" class="moment-comment-input" placeholder="æ·»åŠ è¯„è®º...">
              <button class="post-comment-btn" data-moment-id="${m.id}">å‘å¸ƒ</button>
            `;
            div.appendChild(commentInputArea);

            momentsContainer.appendChild(div);
        });
        
        // å¼ºåˆ¶æ¥ç®¡æ—§çš„å®‰å…¨æ¨¡å¼
        window.renderMomentsSafe = renderMoments;
    }

// --- æ–°å¢: ä¿å­˜è¯„è®ºå’Œç‚¹èµçš„è¾…åŠ©å‡½æ•° ---
// --- æ–°å¢: ä¿å­˜è¯„è®ºå’Œç‚¹èµçš„è¾…åŠ©å‡½æ•° (å·²ä¿®å¤ï¼šAIèƒ½è¯†åˆ«æ˜¯â€œæˆ‘â€è¯„è®ºçš„) ---
// --- ä¿®å¤ç‰ˆï¼šä¿å­˜è¯„è®º (è®°å½• replyTo å­—æ®µ) ---
// --- ä¿®å¤ç‰ˆ V2ï¼šä¿å­˜è¯„è®º (å¹¶åœ¨é€šçŸ¥ä¸­æºå¸¦IDç»™AI) ---
async function saveUserComment(momentId, commentText, replyToCommentId = null, replyToAuthorName = null) {
    try {
        if (!db || !momentId || !commentText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        const myProfile = loadProfileFromStorage();
        const myId = myProfile.id || 'user';
        const myGlobalName = myProfile.name || 'æˆ‘';
        const targetAuthorId = replyToAuthorName; 

        const newComment = {
            id: `comment_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
            roleId: myId,
            text: commentText,
            ts: Date.now(),
            replies: [],
            replyTo: targetAuthorId || null 
        };

        let notificationTargetCharacter = null;
        let notificationContent = '';
        
        const getUserNameForAi = (targetAi) => {
            return (targetAi && targetAi.myName) ? targetAi.myName : myGlobalName;
        };

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨é€šçŸ¥å†…å®¹ä¸­ï¼Œæ˜¾å¼åŒ…å« momentId å’Œ commentId ---
        // è¿™æ · AI åœ¨å›å¤æ—¶å°±èƒ½ç›´æ¥æŠ„ä½œä¸šäº†
        const idInfo = `(è¯·åœ¨å›å¤æŒ‡ä»¤ä¸­ä½¿ç”¨æ­¤IDæ•°æ® -> momentId: "${momentId}", commentId: "${newComment.id}")`;

        if (replyToCommentId) {
            // æ˜¯å›å¤è¯„è®º
            const findComment = (comments) => {
                for (const c of comments) {
                    if (c.id === replyToCommentId) return c;
                    if (c.replies && c.replies.length > 0) {
                        const found = findComment(c.replies);
                        if (found) return found;
                    }
                }
                return null;
            };
            const parentComment = findComment(moment.comments || []);
            
            if (parentComment) {
                parentComment.replies = parentComment.replies || [];
                parentComment.replies.push(newComment);
                
                if (targetAuthorId && targetAuthorId.startsWith('char_')) {
                    notificationTargetCharacter = window.db.characters.find(c => c.id === targetAuthorId);
                    if (notificationTargetCharacter) {
                        const nameToUse = getUserNameForAi(notificationTargetCharacter);
                        const momentSnippet = moment.text.substring(0, 10) + '...';
                        notificationContent = `[system: ${nameToUse} å›å¤äº†ä½ å¯¹åŠ¨æ€ "${momentSnippet}" çš„è¯„è®º: "${commentText}"ã€‚${idInfo}]`;
                    }
                }
            } else {
                 moment.comments = moment.comments || [];
                 moment.comments.push(newComment);
            }
        } else {
            // æ˜¯ç›´æ¥è¯„è®ºåŠ¨æ€
            moment.comments = moment.comments || [];
            moment.comments.push(newComment);
            
            if (moment.authorId && moment.authorId.startsWith('char_')) {
                notificationTargetCharacter = window.db.characters.find(c => c.id === moment.authorId);
                if (notificationTargetCharacter) {
                    const nameToUse = getUserNameForAi(notificationTargetCharacter);
                    const momentSnippet = moment.text.substring(0, 10) + '...';
                    notificationContent = `[system: ${nameToUse} è¯„è®ºäº†ä½ çš„åŠ¨æ€ "${momentSnippet}": "${commentText}"ã€‚${idInfo}]`;
                }
            }
        }

        moment.commentedBy = moment.commentedBy || [];
        if (!moment.commentedBy.includes(myId)) {
            moment.commentedBy.push(myId);
        }

        await db.moments.put(moment);

        if (notificationTargetCharacter && notificationContent) {
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: notificationContent,
                parts: [{ type: 'text', text: notificationContent }],
                timestamp: Date.now()
            };
            notificationTargetCharacter.history.push(contextMessage);
            if (typeof window.saveData === 'function') {
                await window.saveData();
            }
        }
        
        renderMoments();
    } catch (e) {
        console.error(`Failed to save user comment`, e);
        if (typeof showToast === 'function') showToast('è¯„è®ºå¤±è´¥');
    }
}



async function saveMomentComment(momentId, authorId, commentText) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.comments = moment.comments || [];
            moment.commentedBy = moment.commentedBy || [];
            moment.comments.push({
                roleId: authorId,
                text: commentText,
                ts: Date.now()
            });
            if (!moment.commentedBy.includes(authorId)) {
                moment.commentedBy.push(authorId);
            }
            await window.AppDB_Moments.moments.put(moment);
            if (typeof renderMoments === 'function') renderMoments();
        }
    } catch (e) {
        console.error(`Failed to save comment for moment ${momentId}:`, e);
    }
}

async function saveMomentLike(momentId, authorId) {
    try {
        if (!window.AppDB_Moments || !window.AppDB_Moments.moments || !momentId) return;
        const moment = await window.AppDB_Moments.moments.get(momentId);
        if (moment) {
            moment.likes = moment.likes || [];
            if (!moment.likes.includes(authorId)) {
                moment.likes.push(authorId);
                await window.AppDB_Moments.moments.put(moment);
                if (typeof renderMoments === 'function') renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save like for moment ${momentId}:`, e);
    }
}
// --- end æ–°å¢ ---


    // 6) è·å–å°šæœªè¢«æŸè§’è‰²è¯„è®ºçš„åŠ¨æ€ï¼ˆlimitï¼‰ -> ä¿®å¤ç‰ˆï¼šåªè·å–ç”¨æˆ·è‡ªå·±çš„åŠ¨æ€
    async function getPendingMomentsForRole(roleId, limit = 5) {
      // 1. è·å–â€œæˆ‘â€çš„ID
      let myId = 'user'; // é»˜è®¤ID
      
      // å°è¯•ä»å…¨å±€å‡½æ•°è·å–æœ€æ–°ID
      if (typeof window.loadProfileFromStorage === 'function') {
          const profile = window.loadProfileFromStorage();
          if (profile && profile.id) myId = profile.id;
      } else {
          // ä¿åº•æ–¹æ¡ˆï¼šç›´æ¥æŸ¥localStorage
          myId = localStorage.getItem('myTopId') || 'user';
      }

      // 2. ä»æ•°æ®åº“è·å–æ‰€æœ‰åŠ¨æ€
      let all = [];
      if (db && db.moments) {
          all = await db.moments.orderBy('timestamp').reverse().toArray();
      }

      // 3. æ ¸å¿ƒç­›é€‰é€»è¾‘
      const pending = all.filter(m => 
          m.authorId === myId && // ã€å…³é”®ä¿®æ”¹ã€‘åªç­›é€‰ä½œè€…IDç­‰äºâ€œæˆ‘â€çš„åŠ¨æ€
          !(m.commentedBy || []).includes(roleId) // ä¸”è¯¥è§’è‰²è¿˜æ²¡è¯„è®ºè¿‡
      );

      return pending.slice(0, limit);
    }

    // 7) å°† AI çš„è¯„è®ºå†™å›æ•°æ®åº“å¹¶æ ‡è®° commentedBy
    async function markMomentsCommentedBy(commentsArray, roleId) {
      // commentsArray: [{momentId, commentText}, ...]
      try {
        await db.transaction('rw', db.moments, async () => {
          for (const c of commentsArray) {
            const m = await db.moments.get(c.momentId);
            if (!m) continue;
            const cbSet = new Set(m.commentedBy || []);
            cbSet.add(roleId);
            m.commentedBy = Array.from(cbSet);
            m.comments = m.comments || [];
            m.comments.push({ roleId, text: c.commentText, ts: Date.now() });
            await db.moments.put(m);
          }
        });
        renderMoments();
      } catch (e) {
        console.error('mark comments err', e);
      }
    }

    // 8) hook åº•éƒ¨å¯¼èˆªæ˜¾ç¤ºé€»è¾‘ï¼ˆåªåœ¨èŠå¤©åˆ—è¡¨ screen å¯è§æ—¶æ˜¾ç¤ºï¼‰
    // æŠŠ bottom-nav-host æ’å…¥åˆ° .phone-screen å†…åº•éƒ¨ï¼Œä½¿å®ƒåœ¨èŠå¤©é¡µåº•éƒ¨æ˜¾ç¤º
    const phoneScreen = document.querySelector('.phone-screen');

    // === Step3 fix: ensure modal overlays are placed inside .phone-screen so absolute positioning works ===
    (function ensureModalsInPhoneScreen() {
      try {
        const phone = document.querySelector('.phone-screen');
        if (!phone) return;
        // move all modal overlays (only once)
        const modalSelectors = ['#post-modal', '.modal-overlay', '#sticker-modal', '#add-sticker-modal', '#time-skip-modal', '#group-recipient-selection-modal'];
        // Use querySelectorAll to move elements that exist and are not already inside phone
        document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar, #post-modal, #sticker-modal, #add-sticker-modal, #time-skip-modal, #group-recipient-selection-modal').forEach(el => {
          if (!el) return;
          if (phone.contains(el)) return;
          phone.appendChild(el);
        });
      } catch (e) {
        console.error('ensureModalsInPhoneScreen error', e);
      }
    })();

    
if (phoneScreen && bottomNavHost) {
      // æŠŠå¯¼èˆªæ”¾å…¥ chat-list-screen åº•éƒ¨ï¼Œä½¿å…¶ä»…åœ¨è¯¥ screen å†…æ¸²æŸ“ä¸å®šä½
      const chatListScreen = document.getElementById('chat-list-screen');
      if (phoneScreen && bottomNavHost.parentElement !== phoneScreen) {
        phoneScreen.appendChild(bottomNavHost);
      }
      bottomNavHost.style.display = 'none'; // åˆå§‹éšè—

      // --- æ–°å¢ï¼šä¸ºç”¨æˆ·è¯„è®ºæŒ‰é’®æ·»åŠ äº‹ä»¶å§”æ‰˜ ---
// --- æœ€ç»ˆä¿®æ­£ï¼šç”¨æˆ·è¯„è®ºæŒ‰é’®ç‚¹å‡»äº‹ä»¶ ---
      momentsContainer.addEventListener('click', async (e) => {
          const postBtn = e.target.closest('.post-comment-btn');
          if (postBtn) {
              e.preventDefault();
              const momentId = postBtn.dataset.momentId;
              const input = postBtn.previousElementSibling;
              const commentText = input.value.trim();

              const replyToCommentId = postBtn.dataset.replyToCommentId || null;
              // è¿™é‡Œçš„ replyToAuthorId å°±æ˜¯æˆ‘ä»¬åœ¨ç‚¹å‡»è¯„è®ºæ—¶å­˜è¿›å»çš„ ID
              const replyToAuthorId = postBtn.dataset.replyToAuthorId || null;

              if (commentText) {
                  // å°† ID ä¼ ç»™å‡½æ•°çš„æœ€åä¸€ä¸ªå‚æ•°
                  await saveUserComment(momentId, commentText, replyToCommentId, replyToAuthorId);
                  
                  input.value = '';
                  input.placeholder = 'æ·»åŠ è¯„è®º...';
                  delete postBtn.dataset.replyToCommentId;
                  delete postBtn.dataset.replyToAuthorId; // æ¸…ç†
                  postBtn.closest('.moment-comment-input-area').classList.remove('visible');
              } else {
                  showToast('è¯„è®ºå†…å®¹ä¸èƒ½ä¸ºç©º');
              }
          }
      });

      // ç»‘å®šæŒ‰é’®ï¼ˆè‹¥å·²æœ‰ç»‘å®šåˆ™ä¿æŒï¼‰
      const navButtons = bottomNavHost.querySelectorAll('.nav-btn');
      navButtons.forEach(btn => {
        if (btn._bound) return;
        btn.addEventListener('click', () => {
          navButtons.forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
          const target = btn.getAttribute('data-target');
          if (typeof window.switchScreen === 'function') {
            window.switchScreen(target);
          } else {
            // ç®€å•å›é€€ï¼šåˆ‡æ¢ active ç±»å¹¶è§¦å‘è‡ªå®šä¹‰äº‹ä»¶
            document.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === target));
            document.dispatchEvent(new CustomEvent('app:screenChanged', { detail: { targetId: target } }));
          }
        });
        btn._bound = true;
      });

      // åˆå§‹ï¼šå¦‚æœå½“å‰ active æ˜¯ chat-list-screenï¼Œåˆ™æ˜¾ç¤ºå¹¶ä¿æŒ chat æŒ‰é’® active
      const initActive = document.querySelector('.screen.active');
      if (initActive && initActive.id === 'chat-list-screen') {
        bottomNavHost.style.display = '';
        navButtons.forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
      
async function saveAiReplyToComment(momentId, commentId, replyText, aiAuthorId) {
    try {
        if (!db || !momentId || !commentId || !replyText) return;
        const moment = await db.moments.get(momentId);
        if (!moment) return;

        // é€’å½’æŸ¥æ‰¾è¦å›å¤çš„è¯„è®º
        const findCommentAndAddReply = (comments) => {
            for (const c of comments) {
                if (c.id === commentId) {
                    c.replies = c.replies || [];
                    c.replies.push({
                        id: `comment_${Date.now()}`,
                        roleId: aiAuthorId,
                        text: replyText,
                        ts: Date.now(),
                        replyTo: c.roleId // è®°å½•è¿™æ¡å›å¤æ˜¯å›å¤ç»™è°çš„
                    });
                    return true;
                }
                if (c.replies && findCommentAndAddReply(c.replies)) {
                    return true;
                }
            }
            return false;
        };

        if (findCommentAndAddReply(moment.comments || [])) {
            await db.moments.put(moment);
            if (typeof renderMoments === 'function') {
                renderMoments();
            }
        }
    } catch (e) {
        console.error(`Failed to save AI reply for comment ${commentId}:`, e);
    }
}
      // ä½ç½®æ›´æ–°å‡½æ•°ï¼šæ ¹æ® chat-list-screen çš„ active ç±»æ˜¾ç¤º/éšè—
function updateBottomNavVisibilityByActive() {
    const chatCls = document.getElementById('chat-list-screen');
    const momentsCls = document.getElementById('moments-screen');
    const forumScreen = document.getElementById('forum-screen');
    const forumThreadScreen = document.getElementById('forum-thread-screen');
    const walletScreen = document.getElementById('wallet-screen'); // <-- æ–°å¢è¿™ä¸€è¡Œ

    // --- ä¿®æ”¹ï¼šåœ¨åˆ¤æ–­æ¡ä»¶é‡ŒåŠ å…¥å¯¹è®ºå›å’Œé’±åŒ…é¡µé¢çš„æ£€æŸ¥ ---
    if ((chatCls && chatCls.classList.contains('active')) ||
        (momentsCls && momentsCls.classList.contains('active')) ||
        (forumScreen && forumScreen.classList.contains('active')) ||
        (forumThreadScreen && forumThreadScreen.classList.contains('active')) ||
        (walletScreen && walletScreen.classList.contains('active')) // <-- æ–°å¢è¿™ä¸€è¡Œ
       ) {
      bottomNavHost.style.display = '';
    } else {
      bottomNavHost.style.display = 'none';
    }
}
// â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²
      // ç«‹å³æ‰§è¡Œä¸€æ¬¡
      updateBottomNavVisibilityByActive();

      // ç›‘å¬ .phone-screen ä¸‹ class å˜åŒ–ï¼ˆå±å¹•åˆ‡æ¢é€šå¸¸ä¼šè§¦å‘ class å˜åŒ–ï¼‰
      const moTarget = phoneScreen;
      try {
        const mo = new MutationObserver(() => updateBottomNavVisibilityByActive());
        mo.observe(moTarget, { attributes: true, subtree: true, attributeFilter: ['class'] });
      } catch (e) {
        // ignore observer errors
      }
    }
    // å…¨å±€åˆ‡æ¢ screen çš„å°å‡½æ•°ï¼ˆä¸é¡µé¢å·²æœ‰åˆ‡æ¢ä¿æŒä¸€è‡´ï¼‰
    function switchScreen(targetId) {
      // ä»…åˆ‡æ¢ active ç±»ï¼Œé¿å…ç›´æ¥æ”¹å†™ style.display å¯¼è‡´å¸ƒå±€ï¼ˆflexï¼‰å¼‚å¸¸
      document.querySelectorAll('.screen').forEach(s => {
        s.classList.toggle('active', s.id === targetId);
      });
      // è§¦å‘å…¨å±€äº‹ä»¶ï¼Œé€šçŸ¥å…¶ä»–æ¨¡å—å±å¹•å·²åˆ‡æ¢
      try {
        const ev = new CustomEvent('app:screenChanged', { detail: { targetId } });
        document.dispatchEvent(ev);
      } catch (e) {
        console.warn('dispatch app:screenChanged failed', e);
      }
      // å¦‚æœè¿›å…¥ moments-screenï¼Œæ¸²æŸ“
      if (targetId === 'moments-screen' && typeof renderMoments === 'function') renderMoments();
    }

    // 9) å°†åŠ¨æ€å†…å®¹ä¸èŠå¤©ä¸€èµ·å‘ç»™ AIï¼ˆæŒ‚åˆ° #get-reply-btnï¼‰
    const getReplyBtn = $('#get-reply-btn');
    if (getReplyBtn) {
      getReplyBtn.addEventListener('click', async (ev) => {
        // Determine current roleId: try chat-room-title text
        const roleTitleEl = $('#chat-room-title');
        let roleId = roleTitleEl ? roleTitleEl.textContent.trim() : 'role_unknown';
        if (!roleId) roleId = 'role_unknown';

        // collect chat history from #message-area DOM
        const chatArea = $('#message-area');
        let chatText = '';
        if (chatArea) {
          const messages = chatArea.querySelectorAll('.message-bubble');
          const arr = [];
          messages.forEach(mb => {
            // get role name if exists, else fallback to bubble's class
            const wrapper = mb.closest('.message-wrapper');
            let who = wrapper && wrapper.classList.contains('sent') ? 'æˆ‘' : (wrapper && wrapper.classList.contains('received') ? roleId : '');
            arr.push(`${who}: ${mb.textContent.trim()}`);
          });
          chatText = arr.join('\n');
        }

        // pending moments
        const pending = await getPendingMomentsForRole(roleId, 5);

        // build a structured prompt (we'll ask AI to return JSON)
        let prompt = `ç³»ç»Ÿï¼šè¯·æŒ‰ JSON æ ¼å¼è¾“å‡ºï¼š{"chat_reply":"...","moment_comments":[{"momentId":"...","comment":"..."}]}\n\n`;
        prompt += `èŠå¤©è®°å½•ï¼š\n${chatText}\n\n`;
        if (pending && pending.length) {
          prompt += `éœ€è¦è¯„è®ºçš„åŠ¨æ€ï¼ˆæœ€å¤š ${pending.length} æ¡ï¼ŒæŒ‰åºå¯¹åº” idï¼‰ï¼š\n`;
          pending.forEach((m, i) => {
            prompt += `${i+1}) id:${m.id}\ntext:${m.text}\nimageDesc:${m.imageDesc || ''}\n\n`;
          });
        } else {
          prompt += 'ï¼ˆæ— å¾…è¯„è®ºçš„åŠ¨æ€ï¼‰\n';
        }

        // Try to call existing global sendToAI-like function if exists
        let aiRaw = null;
        try {
          if (typeof window.sendToAI === 'function') {
            aiRaw = await window.sendToAI(prompt);
          } else if (typeof window.callAI === 'function') {
            aiRaw = await window.callAI(prompt);
          } else if (typeof window.sendMessageToModel === 'function') {
            aiRaw = await window.sendMessageToModel(prompt);
          }
        } catch (e) {
          console.error('AI call failed', e);
          showToast('AI è¯·æ±‚å¤±è´¥ï¼š' + (e.message || e));
          return;
        }

        // è§£æ AI è¿”å›ï¼ˆä¼˜å…ˆ JSONï¼‰
        let parsed = null;
        try {
          parsed = typeof aiRaw === 'string' ? JSON.parse(aiRaw) : aiRaw;
        } catch (e) {
          // fallback: ä½¿ç”¨åŸå§‹æ–‡æœ¬ä½œä¸º chat å›å¤
          parsed = { chat_reply: String(aiRaw || ''), moment_comments: [] };
        }

        // å¤„ç†èŠå¤©å›å¤ï¼šæŠŠ parsed.chat_reply æ’å…¥èŠå¤©åŒºåŸŸï¼ˆè‹¥é¡µé¢å·²æœ‰ appendAIMessageToChat å‡½æ•°ä¼˜å…ˆä½¿ç”¨ï¼‰
        if (parsed && parsed.chat_reply) {
          if (typeof window.appendAIMessageToChat === 'function') {
            window.appendAIMessageToChat(parsed.chat_reply, roleId);
          } else {
            // å°è¯•åœ¨é¡µé¢ç›´æ¥æ’å…¥ï¼ˆå¦‚æœ message-area å­˜åœ¨ï¼‰
            const mArea = $('#message-area');
            if (mArea) {
              const wrapper = document.createElement('div');
              wrapper.className = 'message-wrapper received';
              const row = document.createElement('div');
              row.className = 'message-bubble received';
              row.textContent = parsed.chat_reply;
              wrapper.appendChild(row);
              mArea.appendChild(wrapper);
              mArea.scrollTop = mArea.scrollHeight;
            }
          }
        }

        // å¤„ç† moment è¯„è®º
        if (parsed && Array.isArray(parsed.moment_comments) && parsed.moment_comments.length) {
          // Normalize to array of {momentId, commentText}
          const normalized = parsed.moment_comments.map(mc => {
            return { momentId: mc.momentId || mc.momentId || mc.id || mc.id, commentText: mc.comment || mc.commentText || mc.text || '' };
          }).filter(x => x.momentId);
          if (normalized.length) {
            await markMomentsCommentedBy(normalized, roleId);
          }
        }

      }); // end getReplyBtn click
    } // end if getReplyBtn

    // small toast helper (reuse existing #toast-notification if exists)
    function showToast(msg, timeout = 2400) {
      const t = $('#toast-notification');
      if (t) {
        t.textContent = msg;
        t.classList.add('show');
        setTimeout(()=>t.classList.remove('show'), timeout);
      } else {
        // fallback
        alert(msg);
      }
    }

    /* simulateAIResponse removed: local simulated AI replies disabled by user request */

// åˆå§‹ï¼šå¦‚æœé¡µé¢å½“å‰åœ¨ chat-list-screenï¼Œæ˜¾ç¤º bottom nav
    const currentActive = document.querySelector('.screen.active');
    if (currentActive && currentActive.id === 'chat-list-screen') {
      // keep bottom nav visible and make chat button active
      const botNav = document.getElementById('bottom-nav');
      if (botNav) {
        botNav.querySelectorAll('.nav-btn').forEach(b => b.classList.toggle('active', b.getAttribute('data-target') === 'chat-list-screen'));
      }
    }

    // å¦‚æœåˆå§‹å­˜åœ¨ moments screen activeï¼Œåˆ™ render
    if (currentActive && currentActive.id === 'moments-screen') renderMoments();

    // --- å°†å…³é”®å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä»¥ä¾¿å…¶ä»–æ¨¡å—è°ƒç”¨ ---
    window.getPendingMomentsForRole = getPendingMomentsForRole;
    window.saveMomentComment = saveMomentComment;
    window.saveMomentLike = saveMomentLike;
    window.markMomentsCommentedBy = markMomentsCommentedBy;
    window.renderMoments = renderMoments; // æš´éœ²æ¸²æŸ“å‡½æ•°ï¼Œä»¥ä¾¿å¤–éƒ¨æ¨¡å—å¯ä»¥åˆ·æ–°åŠ¨æ€åˆ—è¡¨

  }); // DOMContentLoaded end
})();



// Begin: Render moments safe patch (injected for step4) 

(function(){
  console.log('[injected patch] renderMomentsSafe initializing...');
  try {
    const momentsScreen = document.getElementById('moments-screen');
    if (!momentsScreen) {
      console.warn('[injected patch] #moments-screen not found.');
    }
    // Ensure a container exists
    let momentsContainer = document.getElementById('moments-container');
    if (!momentsContainer && momentsScreen) {
      const content = momentsScreen.querySelector('.content') || momentsScreen;
      momentsContainer = document.createElement('div');
      momentsContainer.id = 'moments-container';
      content.appendChild(momentsContainer);
      console.log('[injected patch] created #moments-container');
    }
    // Safe Dexie wrapper
    let _db = null;
    if (typeof Dexie !== 'undefined') {
        // Use the existing global instance if available
        if (window.AppDB_Moments) {
            _db = window.AppDB_Moments;
        } else {
            try {
                _db = new Dexie('AppDB_Moments');
                _db.version(1).stores({ moments: 'id,timestamp,commentedBy' });
                window.AppDB_Moments = _db; // Ensure it's globally available
            } catch (e) {
                console.warn('[injected patch] Dexie init failed:', e);
                _db = null;
            }
        }
    } else {
        console.warn('[injected patch] Dexie not available.');
    }

// â–¼â–¼â–¼ åœ¨ renderMomentsSafe å‡½æ•°çš„æ­£ä¸Šæ–¹ï¼Œç²˜è´´è¿™ä¸ªæ–°å‡½æ•° â–¼â–¼â–¼
function getAuthorProfile(authorId) {
    // é»˜è®¤å¤‡ç”¨ä¿¡æ¯
    let profile = { name: 'æœªçŸ¥ç”¨æˆ·', avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg' };

    // 1. æ£€æŸ¥æ˜¯ä¸æ˜¯ç”¨æˆ·è‡ªå·±
    const myProfile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {};
    if (authorId === (myProfile.id || 'user')) {
        return { name: myProfile.name || 'æˆ‘', avatar: myProfile.avatar };
    }

    // 2. åœ¨æ‰€æœ‰AIè§’è‰²ä¸­æŸ¥æ‰¾
    if (window.db && Array.isArray(window.db.characters)) {
        const character = window.db.characters.find(c => c.id === authorId);
        if (character) {
            return { name: character.remarkName, avatar: character.avatar };
        }
    }

    // 3. åœ¨æ‰€æœ‰ç¾¤èŠçš„æˆå‘˜ä¸­æŸ¥æ‰¾ (ä»¥é˜²æ˜¯ç¾¤èŠæˆå‘˜å‘çš„åŠ¨æ€)
    if (window.db && Array.isArray(window.db.groups)) {
        for (const group of window.db.groups) {
            if (Array.isArray(group.members)) {
                const member = group.members.find(m => m.id === authorId);
                if (member) {
                    return { name: member.groupNickname, avatar: member.avatar };
                }
            }
        }
    }
    
    return profile; // å¦‚æœéƒ½æ‰¾ä¸åˆ°ï¼Œè¿”å›é»˜è®¤ä¿¡æ¯
}
// â–²â–²â–² æ·»åŠ ç»“æŸ â–²â–²â–²

// â–¼â–¼â–¼ ç”¨è¿™ä¸ªæ–°ç‰ˆæœ¬ï¼Œå®Œæ•´æ›¿æ¢æ‰æ—§çš„ renderMomentsSafe å‡½æ•° â–¼â–¼â–¼
    window.renderMomentsSafe = async function renderMomentsSafe() {
      try {
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('#moments-container'));
        if (!container) {
          console.warn('[injected patch] No container found for moments.');
          return;
        }
        let list = [];
        if (_db && _db.moments) {
          try {
            list = await _db.moments.orderBy('timestamp').reverse().toArray();
          } catch (e) {
            console.error('[injected patch] Failed reading moments from IndexedDB:', e);
            list = [];
          }
        } else {
          try {
            const maybeDb = window.AppDB_Moments || null;
            if (maybeDb && maybeDb.moments) {
              list = await maybeDb.moments.orderBy('timestamp').reverse().toArray();
            }
          } catch (e) {
            list = [];
          }
        }

        container.innerHTML = '';
        const momentsEmpty = document.getElementById('moments-empty');
        if (!list || !list.length) {
          if (momentsEmpty) momentsEmpty.style.display = 'block';
          else {
            const p = document.createElement('p');
            p.className = 'placeholder-text';
            p.textContent = 'è¿˜æ²¡æœ‰åŠ¨æ€ï¼Œç‚¹å‡»å³ä¸Šè§’å‘å¸ƒå§~';
            container.appendChild(p);
          }
          return;
        } else {
          if (momentsEmpty) momentsEmpty.style.display = 'none';
        }

        list.forEach(m => {
          try {
            const div = document.createElement('div'); div.className = 'moment-item';
            div.dataset.id = m.id || (m.id = (Math.random()+''+Date.now()));
            const head = document.createElement('div'); head.className = 'moment-head';
            const avatar = document.createElement('img'); avatar.className = 'moment-avatar';
            const meta = document.createElement('div'); meta.className = 'moment-meta';
            const name = document.createElement('div'); name.style.fontWeight='700';
            const time = document.createElement('div'); time.style.fontSize='12px'; time.style.color='#999';
            try { time.textContent = new Date(m.timestamp).toLocaleString(); } catch(e) { time.textContent = ''; }
            
            // --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ ---
            const authorInfo = getAuthorProfile(m.authorId); // ä½¿ç”¨æ–°å‡½æ•°æŸ¥æ‰¾ä½œè€…ä¿¡æ¯
            name.textContent = authorInfo.name || m.author || 'æœªçŸ¥ç”¨æˆ·'; // ä¼˜å…ˆç”¨æ–°æ‰¾åˆ°çš„åå­—ï¼Œæ‰¾ä¸åˆ°å†ç”¨å¿«ç…§é‡Œçš„æ—§åå­—
            avatar.src = authorInfo.avatar || m.authorAvatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg'; // ä¼˜å…ˆç”¨æ–°æ‰¾åˆ°çš„å¤´åƒï¼Œæ‰¾ä¸åˆ°å†ç”¨å¿«ç…§é‡Œçš„
            // --- ä¿®æ”¹ç»“æŸ ---

            meta.appendChild(name);
            meta.appendChild(time);
            head.appendChild(avatar);
            head.appendChild(meta);
            div.appendChild(head);

            const txt = document.createElement('div'); txt.className='moment-text'; txt.textContent = m.text || '';
            div.appendChild(txt);

            if (m.imageData && m.imageData !== 'null' && m.imageData !== 'undefined' && m.imageData.length>10) {
              const im = document.createElement('img'); im.className = 'moment-image';
              im.src = m.imageData;
              im.alt = m.imageDesc ? m.imageDesc : (m.text || 'åŠ¨æ€å›¾ç‰‡');
              div.appendChild(im);
              if (m.imageDesc) {
                const desc = document.createElement('div'); desc.style.fontSize='13px'; desc.style.color='#666';
                desc.textContent = 'å›¾ç‰‡ï¼š' + m.imageDesc;
                div.appendChild(desc);
              }
            } else if (m.imageDesc) {
              const descCard = document.createElement('div'); descCard.className = 'moment-image-desc-card';
              if (m.id) descCard.dataset.momentId = m.id || '';
              const descContent = document.createElement('p'); descContent.className = 'desc-content';
              descContent.textContent = m.imageDesc;
              descCard.appendChild(descContent);
              descCard.setAttribute('role', 'img');
              descCard.setAttribute('aria-label', m.imageDesc);
              descCard.addEventListener('click', function () { /* show detail */ });
              div.appendChild(descCard);
            }

            const actions = document.createElement('div');
            actions.className = 'moment-actions';
            
            const likeBtn = document.createElement('button');
            likeBtn.className = 'moment-action-btn';
            const likes = m.likes || [];
            const myProfile = loadProfileFromStorage();
            const myId = myProfile.id || 'user';
            if (likes.includes(myId)) {
                likeBtn.classList.add('liked');
            }
            likeBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg><span>${likes.length > 0 ? likes.length : 'ç‚¹èµ'}</span>`;
            
likeBtn.addEventListener('click', async (event) => {
                event.stopPropagation(); // é˜²æ­¢ç‚¹å‡»ç©¿é€
                const btn = event.currentTarget;
                const momentItem = btn.closest('.moment-item');
                
                // 1. æ›´æ–°æœ¬åœ°æ•°æ®çŠ¶æ€
                const currentLikes = m.likes || [];
                const myIdx = currentLikes.indexOf(myId);

                if (myIdx > -1) {
                    currentLikes.splice(myIdx, 1);
                    btn.classList.remove('liked');
                } else {
                    currentLikes.push(myId);
                    btn.classList.add('liked');
                }
                m.likes = currentLikes;

                // --- ã€æ ¸å¼¹çº§ä¿®å¤ã€‘ç°åœºè¿æ¥æ•°æ®åº“è¿›è¡Œä¿å­˜ ---
                try {
                    // ä¸ç®¡å…¨å±€å˜é‡åœ¨ä¸åœ¨ï¼Œç›´æ¥æ–°å»ºä¸€ä¸ªè¿æ¥ï¼Œä¿è¯ put æ–¹æ³•å­˜åœ¨
                    const safeDb = new Dexie('AppDB_Moments');
                    safeDb.version(1).stores({ moments: 'id,timestamp,commentedBy' });
                    await safeDb.moments.put(m);
                    // console.log('ç‚¹èµçŠ¶æ€å·²ä¿å­˜');
                } catch (e) {
                    console.error("æ•°æ®åº“å†™å…¥å¤±è´¥:", e);
                    alert("ç‚¹èµä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°");
                }
                // ------------------------------------------

                // 2. æ›´æ–°æŒ‰é’®æ–‡å­—
                const span = btn.querySelector('span');
                if (span) {
                    span.textContent = currentLikes.length > 0 ? currentLikes.length : 'ç‚¹èµ';
                }

                // 3. æ›´æ–°ç‚¹èµäººååˆ—è¡¨æ˜¾ç¤º
                const likesWrap = momentItem.querySelector('.moment-likes');
                if (likesWrap) {
                    if (currentLikes.length > 0) {
                        const likeNames = currentLikes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                        likesWrap.innerHTML = `<span class="like-icon">â™¥</span> ${likeNames}`;
                        likesWrap.classList.add('visible');
                    } else {
                        likesWrap.classList.remove('visible');
                    }
                }
            });

            const commentBtn = document.createElement('button');
            commentBtn.className = 'moment-action-btn';
            commentBtn.innerHTML = `<svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg><span>è¯„è®º</span>`;
            commentBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                const btn = event.currentTarget;
                const momentItem = btn.closest('.moment-item');
                if (momentItem) {
                    const inputArea = momentItem.querySelector('.moment-comment-input-area');
                    if (inputArea) {
                        inputArea.classList.toggle('visible');
                        if (inputArea.classList.contains('visible')) {
                            inputArea.querySelector('input').focus();
                        }
                    }
                }
            });

            actions.appendChild(likeBtn);
            actions.appendChild(commentBtn);
            div.appendChild(actions);

            if (likes.length > 0) {
                const likesWrap = document.createElement('div');
                likesWrap.className = 'moment-likes visible';
                const likeNames = likes.map(likeId => window.getAuthorNameById(likeId)).join(', ');
                likesWrap.innerHTML = `<span class="like-icon">â™¥</span> ${likeNames}`;
                div.appendChild(likesWrap);
            }

            const commentsWrap = document.createElement('div'); commentsWrap.className = 'moment-comments';
            if (m.comments && m.comments.length) {
              m.comments.forEach(c => {
                const cm = document.createElement('div'); cm.className='moment-comment';
                const authorName = window.getAuthorNameById(c.roleId || c.role);
                cm.textContent = `${authorName}ï¼š${c.text}`;
                commentsWrap.appendChild(cm);
              });
            } else {
              const none = document.createElement('div'); none.style.color='#bbb'; none.textContent = 'æš‚æ—¶æ²¡æœ‰è¯„è®º';
              commentsWrap.appendChild(none);
            }
            div.appendChild(commentsWrap);

            const commentInputArea = document.createElement('div');
            commentInputArea.className = 'moment-comment-input-area';
            commentInputArea.innerHTML = `
              <input type="text" class="moment-comment-input" placeholder="æ·»åŠ è¯„è®º...">
              <button class="post-comment-btn" data-moment-id="${m.id}">å‘å¸ƒ</button>
            `;
            div.appendChild(commentInputArea);
            container.appendChild(div);
          } catch (innerErr) {
            console.error('[injected patch] render single moment failed', innerErr, m);
          }
        });

      } catch (err) {
        console.error('[injected patch] renderMomentsSafe failed', err);
        const container = document.getElementById('moments-container') || (document.getElementById('moments-screen') && document.getElementById('moments-screen').querySelector('.content'));
        if (container) {
          container.innerHTML = '<div style="color:#b00;padding:12px;border-radius:10px;background:#fff8f8;">åŠ è½½åŠ¨æ€æ—¶å‡ºé”™ï¼ˆè¯¦æƒ…è§ Consoleï¼‰</div>';
        }
      }
    };
// â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–²
  

    // Attach to app:screenChanged and mutation observer
    document.addEventListener('app:screenChanged', (ev) => {
      try {
        if (ev && ev.detail && ev.detail.targetId === 'moments-screen') {
          window.renderMomentsSafe();
        }
      } catch (e) { console.error('[injected patch] app:screenChanged handler failed', e); }
    });

    const phone = document.querySelector('.phone-screen') || document.body;
    const mo = new MutationObserver((mutations) => {
  try {
    // åªåœ¨ phone èŠ‚ç‚¹æœ¬èº«çš„ class å‘ç”Ÿå˜åŒ–æ—¶æ‰è§¦å‘ï¼ˆé¿å…å­å…ƒç´ çš„ class å˜åŠ¨å¯¼è‡´é‡æ¸²æŸ“ï¼‰
    const phoneClassChanged = mutations.some(m =>
      m.type === 'attributes' && m.attributeName === 'class' && m.target === phone
    );
    if (!phoneClassChanged) return;

    const active = document.querySelector('.screen.active');
    if (active && active.id === 'moments-screen') {
      window.renderMomentsSafe();
    }
  } catch (e) { console.error('[injected patch] MutationObserver callback failed', e); }
});
// ä»…è§‚å¯Ÿ phone è‡ªèº«çš„ attributesï¼ˆä¸è¦ subtree=trueï¼‰
mo.observe(phone, { attributes: true, subtree: false, attributeFilter: ['class'] });


    // try initial render
    setTimeout(() => {
      try { window.renderMomentsSafe(); } catch(e) { console.warn('[injected patch] initial render failed', e); }
    }, 300);

  } catch (e) {
    console.error('[injected patch] initialization failed', e);
  }
})();




/* === ç¡®ä¿ #moments-screen æ°¸è¿œåœ¨ .phone-screen å†…ï¼Œå¹¶æ¸…é™¤ä¼šæŠŠå®ƒæ¨å‡ºè§†çª—çš„å†…è”æ ·å¼ (è‡ªåŠ¨æ’å…¥è¡¥ä¸) === */

(function ensureMomentsStaysInPhone() {
  function fixPlacementAndStyles() {
    const phone = document.querySelector('.phone-screen');
    const moments = document.getElementById('moments-screen');
    if (!phone) return;

    // If moments exists, ensure it's inside phone but *do not force inline styles on it*
    if (moments && !phone.contains(moments)) {
      phone.appendChild(moments);
      console.log('[patch] moved #moments-screen into .phone-screen');
    }

    // Only normalize styles for screens *other than* moments-screen or elements managed by injection
    document.querySelectorAll('.screen').forEach(s => {
      if (s.id === 'moments-screen' || s.dataset.managedBy === 'injection') {
        // make sure its stacking context is reasonable but don't clobber its layout
        s.style.zIndex = s.style.zIndex || '0';
        return;
      }
      // Apply conservative safe defaults to other screens
      s.style.position = s.style.position || 'absolute';
      s.style.top = s.style.top || '0';
      s.style.left = s.style.left || '0';
      s.style.right = s.style.right || '0';
      s.style.bottom = s.style.bottom || '0';
      // Avoid removing transforms which some screens might rely on; only clear very specific problematic inline styles
      if ((s.style.transform || '').includes('translate') || (s.style.transform || '').includes('translateY')) {
        // leave transforms intact to avoid breaking animations
      } else {
        s.style.transform = s.style.transform || '';
      }
      s.style.margin = s.style.margin || '';
      // ensure screens stack below nav/modals
      s.style.zIndex = s.style.zIndex || '0';
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', fixPlacementAndStyles);
  } else {
    fixPlacementAndStyles();
  }
  // only run on custom app events; do not poll aggressively to avoid fighting the injected UI
  document.addEventListener('app:screenChanged', fixPlacementAndStyles);
  // run a very infrequent check as a last resort
  setInterval(fixPlacementAndStyles, 5000);
})();



(function(){
    const topSection = document.querySelector('#moments-screen .icity-moments-inner .icity-hero') || document.querySelector('#moments-screen .icity-hero') || document.querySelector('#moments-screen .top-section') || document.querySelector('#moments-screen header');
    const editSheet = document.getElementById('edit-top-section-actionsheet');
    const bgBtn = document.getElementById('edit-bg-btn');
    const avatarBtn = document.getElementById('edit-avatar-btn');
    const cancelBtn = document.getElementById('cancel-edit-top-btn');
    const fileInput = document.getElementById('top-section-file-input');

    let currentEditTarget = null;

    // Restore saved bg & avatar
    const savedBg = localStorage.getItem('myTopBg');
    const savedAvatar = localStorage.getItem('myTopAvatar');
    if(savedBg && topSection) {
        topSection.style.backgroundImage = `url('${savedBg}')`;
        topSection.style.backgroundSize = 'cover';
        topSection.style.backgroundPosition = 'center';
    }
    if(savedAvatar) {
        document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
            if(img.tagName === 'IMG') img.src = savedAvatar;
            else img.style.backgroundImage = `url('${savedAvatar}')`;
        });
    }

    // Previously opened the whole topSection on click â€” removed to avoid accidental edits during publish.
    // Now only explicit edit controls (avatar/background buttons and per-field clicks) will trigger edits.

    cancelBtn.addEventListener('click', ()=>{
        editSheet.classList.remove('visible');
    });

    function chooseSource(targetType) {
        const url = prompt('è¾“å…¥å›¾ç‰‡URLï¼Œæˆ–ç•™ç©ºé€‰æ‹©æœ¬åœ°æ–‡ä»¶ï¼š');
        if(url) {
            applyImage(targetType, url);
        } else {
            currentEditTarget = targetType;
            fileInput.click();
        }
    }

    function applyImage(targetType, dataUrl) {
        if(targetType === 'bg') {
            if(topSection) {
                topSection.style.backgroundImage = `url('${dataUrl}')`;
                topSection.style.backgroundSize = 'cover';
                topSection.style.backgroundPosition = 'center';
            }
            localStorage.setItem('myTopBg', dataUrl);
        } else if(targetType === 'avatar') {
            localStorage.setItem('myTopAvatar', dataUrl);
            document.querySelectorAll('.my-avatar, #moments-screen .top-avatar').forEach(img=>{
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // åŒæ­¥åŠ¨æ€åˆ—è¡¨å¤´åƒï¼ˆmoment-avatar ä¸ºåŠ¨æ€åˆ—è¡¨å¤´åƒç±»ï¼‰
            document.querySelectorAll('.post .avatar-img, .moment-avatar').forEach(img => {
                if(img.tagName === 'IMG') img.src = dataUrl;
                else img.style.backgroundImage = `url('${dataUrl}')`;
            });
            // å°è¯•æ›´æ–°æ•°æ®åº“ä¸­å±äºå½“å‰ç”¨æˆ·(authorIdåŒ¹é…)æˆ–æ—  authorId ä½† author åç§°åŒ¹é…çš„ moments çš„ authorAvatar å­—æ®µï¼ˆè‹¥å­˜åœ¨ dbï¼‰
            try{
                if(window.AppDB_Moments && typeof AppDB_Moments !== 'undefined' && AppDB_Moments.moments){
                    (async ()=>{
                        try{
                            const all = await AppDB_Moments.moments.toArray();
                            const profile = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : {
                                name: localStorage.getItem('myTopName') || 'æˆ‘',
                                id: localStorage.getItem('myTopId') || 'user',
                                avatar: localStorage.getItem('myTopAvatar') || null
                            };
                            for(const m of all){
                                // Update moments that explicitly reference this author's id
                                if((m.authorId && m.authorId === profile.id) || (!m.authorId && m.author === profile.name)){
                                    m.authorAvatar = dataUrl;
                                    // If the moment had no authorId, bind it to current profile.id so future syncs work
                                    if(!m.authorId) m.authorId = profile.id;
                                    try{ await AppDB_Moments.moments.put(m); }catch(e){ /* ignore put errors for individual items */ }
                                }
                            }
                            // After DB updates, re-render moments so DOM reflects DB changes
                            if(typeof renderMoments === 'function') try{ renderMoments(); }catch(e){}
                            else if(typeof window.renderMomentsSafe === 'function') try{ window.renderMomentsSafe(); }catch(e){}
                        }catch(e){}
                    })();
                }
            }catch(e){}
            // Ensure profile render + sync runs to update in-memory DOM and trigger any re-renders
            try{ if(typeof renderProfileAndSync === 'function') renderProfileAndSync(); }catch(e){}
        }
    }
fileInput.addEventListener('change', async (e)=>{
        const file = e.target.files[0];
        if(file) {
            try {
                const compressedUrl = await compressImage(file, { quality: 0.85, maxWidth: 1080, maxHeight: 1920 });
                applyImage(currentEditTarget, compressedUrl);
            } catch (error) {
                if(typeof showToast === 'function') showToast('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                console.error('Background image compression failed:', error);
            }
        }
    });

    bgBtn.addEventListener('click', ()=> chooseSource('bg'));
    avatarBtn.addEventListener('click', ()=> chooseSource('avatar'));
})();

// === /Avatar & Background Edit Feature === 


// Avatar sync patch: non-invasive, appended to avoid modifying original logic.
//     Purpose: ensure top avatar updates immediately and moments list does not revert
//     by synchronizing DOM and (if possible) the DB after avatar changes.

    
(function(){
  'use strict';

  // Utility: load profile from existing function if available, otherwise from localStorage
  function loadProfileFallback(){
    try {
      if(typeof loadProfileFromStorage === 'function'){
        var p = loadProfileFromStorage();
        if(p && (p.avatar || p.id || p.name)) return p;
      }
    } catch(e){}
    // fallback to localStorage keys used by the app
    try {
      return {
        id: localStorage.getItem('myTopId') || localStorage.getItem('icity-id') || localStorage.getItem('userId') || null,
        name: localStorage.getItem('myTopName') || localStorage.getItem('icity-name') || localStorage.getItem('userName') || null,
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('icity-avatar-src') || localStorage.getItem('userAvatar') || null,
        signature: localStorage.getItem('myTopSignature') || null,
        location: localStorage.getItem('myTopLocation') || null
      };
    } catch(e){
      return {};
    }
  }

  // Robustly update top-profile DOM elements and common avatar selectors
  function updateTopProfileAndAvatars(){
    try {
      var p = loadProfileFallback() || {};
      var avatar = p.avatar || null;
      // find common top avatar elements
      var avatarSelectors = [
        '#icity-avatar', // explicit id
        '.icity-avatar-wrap img',
        '.top-avatar',
        '.my-avatar',
        '.header-avatar img',
        '.profile-avatar img'
      ];
      avatarSelectors.forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){
          try {
            if(!el) return;
            if(el.tagName === 'IMG'){
              if(avatar) el.src = avatar;
            } else {
              if(avatar) el.style.backgroundImage = "url('"+avatar+"')";
            }
          } catch(e){}
        });
      });

      // update textual profile elements defensively
      var nameEls = [document.getElementById('icity-name'), document.querySelector('.icity-name'), document.querySelector('.profile-name')];
      nameEls.forEach(function(el){
        if(el && p.name) try{ el.textContent = p.name; }catch(e){}
      });
      var sigEls = [document.getElementById('icity-signature'), document.querySelector('.icity-signature')];
      sigEls.forEach(function(el){
        if(el && p.signature) try{ el.textContent = p.signature; }catch(e){}
      });

      // update moments list avatars for moments authored by current profile (best-effort)
      try {
        var id = p.id || null;
        var name = p.name || null;
        var avatars = document.querySelectorAll('.moment-avatar, .post .avatar-img, .post .author-avatar, .item .avatar, .comment .avatar, img[data-role="avatar"]');
        avatars.forEach(function(img){
          try {
            if(!img) return;
            // try dataset or attributes
            var authorId = img.getAttribute('data-author-id') || img.dataset && img.dataset.authorId || null;
            var authorName = img.getAttribute('data-author') || img.getAttribute('data-author-name') || img.dataset && img.dataset.author || null;

            // also try to find author id/name from closest ancestor
            if(!authorId || !authorName){
              var ancestor = img.closest('[data-author-id], [data-author], .moment, .post');
              if(ancestor){
                if(!authorId) authorId = ancestor.getAttribute('data-author-id') || ancestor.getAttribute('data-author') || null;
                if(!authorName) authorName = ancestor.getAttribute('data-author-name') || ancestor.getAttribute('data-author') || null;
                // check for .author-name text
                if(!authorName){
                  var an = ancestor.querySelector('.author-name, .name, .post-author');
                  if(an) authorName = (an.textContent || '').trim();
                }
              }
            }

            // Decision: if authorId matches, or authorName matches (best-effort), update the img.src
            var shouldUpdate = false;
            if(id && authorId && String(authorId) === String(id)) shouldUpdate = true;
            if(!shouldUpdate && name && authorName && String((authorName||'').trim()) === String((name||'').trim())) shouldUpdate = true;

            if(shouldUpdate && avatar){
              if(img.tagName === 'IMG'){
                img.src = avatar;
              } else {
                img.style.backgroundImage = "url('"+avatar+"')";
              }
            }
          } catch(e){}
        });
      } catch(e){}
    } catch(e){}
  }

  // Try to update a Dexie/DB moments table authorAvatar entries for current user (best-effort, non-blocking)
  function tryUpdateDBMomentsAvatar(newAvatar){
    try {
      var p = loadProfileFallback();
      if(!p || !p.id || !newAvatar) return;
      // if window.AppDB_Moments and Dexie-like table exists, try to update entries where authorId matches
      if(window.AppDB_Moments && window.AppDB_Moments.moments){
        try {
          // If it's Dexie or has where API
          if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.toArray === 'function'){
            // best-effort: update authorAvatar for matching authorId
            // .where('authorId').equals(p.id).modify({ authorAvatar: newAvatar }) might exist
            if(typeof window.AppDB_Moments.moments.where === 'function'){
              try {
                var q = window.AppDB_Moments.moments.where('authorId').equals(p.id);
                if(q && typeof q.modify === 'function'){
                  q.modify(function(obj){ obj.authorAvatar = newAvatar; });
                } else {
                  // fallback: scan and put
                  window.AppDB_Moments.moments.toArray().then(function(arr){
                    arr.forEach(function(item){
                      try {
                        if(item.authorId && String(item.authorId) === String(p.id)){
                          item.authorAvatar = newAvatar;
                          if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item);
                        }
                      } catch(e){}
                    });
                  }).catch(function(){});
                }
              } catch(e){}
            }
          } else if(typeof window.AppDB_Moments.moments.update === 'function'){
            // unknown API: attempt to update each by scanning
            try {
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = newAvatar;
                    try { window.AppDB_Moments.moments.update(item.id, item); } catch(e){}
                  }
                });
              }).catch(function(){});
            } catch(e){}
          }
        } catch(e){}
      }
    } catch(e){}
  }

  // Wrap existing applyImage (if present) so after changing avatar we sync
  if(typeof window.applyImage === 'function'){
    try {
      var origApplyImage = window.applyImage;
      window.applyImage = function(){
        try {
          var res = origApplyImage.apply(this, arguments);
          // schedule sync shortly after (some apps update DOM async)
          setTimeout(function(){
            try {
              updateTopProfileAndAvatars();
              var p = loadProfileFallback();
              if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
            } catch(e){}
          }, 100);
          return res;
        } catch(e){
          try { return origApplyImage.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  } else {
    // If applyImage not found, expose a safe function for callers to use
    window.__syncAvatarsAfterChange = function(){
      try {
        updateTopProfileAndAvatars();
        var p = loadProfileFallback();
        if(p && p.avatar) tryUpdateDBMomentsAvatar(p.avatar);
      } catch(e){}
    };
  }

  // If renderMomentsSafe exists, wrap it to call our sync after running original
  if(typeof window.renderMomentsSafe === 'function'){
    try {
      var _origRenderMomentsSafe = window.renderMomentsSafe;
      window.renderMomentsSafe = function(){
        try {
          var res = _origRenderMomentsSafe.apply(this, arguments);
          // after render, ensure our avatars are applied
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMomentsSafe.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Also wrap any generic renderMoments function if present
  if(typeof window.renderMoments === 'function'){
    try {
      var _origRenderMoments = window.renderMoments;
      window.renderMoments = function(){
        try {
          var res = _origRenderMoments.apply(this, arguments);
          setTimeout(function(){ updateTopProfileAndAvatars(); }, 20);
          return res;
        } catch(e){
          try { return _origRenderMoments.apply(this, arguments); } catch(e){ return undefined; }
        }
      };
    } catch(e){}
  }

  // Run once at load to align UI with stored avatar (without waiting for user action)
  try { setTimeout(updateTopProfileAndAvatars, 50); } catch(e){}

  // Expose for debugging (non-enumerable)
  try { Object.defineProperty(window, '__updateProfileAndAvatars', { value: updateTopProfileAndAvatars, writable: false }); } catch(e){}

  // Do not interfere with bottom navigation: avoid touching elements with ids/classes typically used by navbars.
  // The script only touches avatar/name related selectors and moment avatars; it is intentionally conservative.

})();


// Stronger enforcement: bind moment avatars to top avatar persistently 

(function(){
  'use strict';
  // Helper to read top avatar from DOM or storage
  function getTopAvatar(){
    try {
      // Try common selectors for top avatar
      var selectors = ['#icity-avatar', '.icity-avatar-wrap img', '.top-avatar', '.header-avatar img', '.profile-avatar img', '.my-avatar'];
      for(var i=0;i<selectors.length;i++){
        var el = document.querySelector(selectors[i]);
        if(el){
          if(el.tagName === 'IMG' && el.src) return el.src;
          var bg = window.getComputedStyle(el).backgroundImage;
          if(bg && bg !== 'none'){
            // extract url("...") content
            var m = bg.match(/url\(["']?(.*?)["']?\)/);
            if(m && m[1]) return m[1];
          }
        }
      }
      // fallback to storage
      var p = null;
      try { if(typeof loadProfileFromStorage === 'function') p = loadProfileFromStorage(); } catch(e){}
      if(!p) p = {
        avatar: localStorage.getItem('myTopAvatar') || localStorage.getItem('userAvatar') || localStorage.getItem('icity-avatar-src')
      };
      if(p && p.avatar) return p.avatar;
    } catch(e){}
    return null;
  }

  // Helper to determine if an avatar img belongs to current user (best-effort)
  function isAvatarForCurrentUser(imgEl){
    try {
      if(!imgEl) return false;
      var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : null;
      if(!p) p = { id: localStorage.getItem('myTopId'), name: localStorage.getItem('myTopName') };
      var authorId = imgEl.getAttribute('data-author-id') || (imgEl.dataset && imgEl.dataset.authorId) || null;
      var authorName = imgEl.getAttribute('data-author') || imgEl.getAttribute('data-author-name') || (imgEl.dataset && imgEl.dataset.author) || null;
      if(!authorId && !authorName){
        var anc = imgEl.closest('[data-author-id], [data-author], .moment, .post, .item');
        if(anc){
          authorId = authorId || anc.getAttribute('data-author-id') || anc.getAttribute('data-author');
          authorName = authorName || anc.getAttribute('data-author-name') || anc.getAttribute('data-author');
          if(!authorName){
            var authorNameNode = anc.querySelector('.author-name, .name, .post-author, .author');
            if(authorNameNode) authorName = (authorNameNode.textContent || '').trim();
          }
        }
      }
      if(p && p.id && authorId && String(p.id) === String(authorId)) return true;
      if(p && p.name && authorName && String((p.name||'').trim()) === String((authorName||'').trim())) return true;
      // Also check if img has attribute data-me or class 'me' etc
      if(imgEl.hasAttribute('data-me') || imgEl.classList.contains('me') || imgEl.classList.contains('self')) return true;
    } catch(e){}
    return false;
  }

  // Enforce top avatar on matching nodes
  function enforceTopAvatarOnNode(imgEl, topAvatar){
    try {
      if(!imgEl || !topAvatar) return;
      // Avoid touching nav icons: check ancestor tags that might be navbars
      var navAncestor = imgEl.closest('nav, .navbar, .bottom-nav, .footer');
      if(navAncestor) return; // don't modify nav images
      // Only enforce if this img seems like a moment/post avatar
      var selMatch = /(^|\s)(moment-avatar|avatar-img|author-avatar|post-avatar|item-avatar|my-avatar|top-avatar|author-avatar-img)(\s|$)/i;
      var classStr = imgEl.className || '';
      // If it looks like an avatar or is IMG inside .moment/.post, proceed
      var likelyAvatar = classStr && selMatch.test(classStr) || imgEl.closest('.moment, .post, .item, .comment') || imgEl.getAttribute('data-role') === 'avatar';
      if(!likelyAvatar) return;
      if(!isAvatarForCurrentUser(imgEl)) return;
      // If current src differs, set it
      if(imgEl.tagName === 'IMG'){
        if(imgEl.src !== topAvatar){
          try { imgEl.src = topAvatar; } catch(e){}
        }
      } else {
        try { imgEl.style.backgroundImage = "url('"+topAvatar+"')"; } catch(e){}
      }
      // mark as forced to avoid loops
      try { imgEl.setAttribute('data-avatar-forced','1'); } catch(e){}
    } catch(e){}
  }

  // Enforce across the document
  function enforceTopAvatarAll(topAvatar){
    if(!topAvatar) return;
    var selectors = ['.moment-avatar', '.post .avatar-img', '.post .author-avatar', '.item .avatar', '.comment .avatar', 'img[data-role="avatar"]', '.avatar-img'];
    selectors.forEach(function(sel){
      document.querySelectorAll(sel).forEach(function(img){
        enforceTopAvatarOnNode(img, topAvatar);
      });
    });
  }

  // Mutation observer to catch src changes and new nodes
  var observer = new MutationObserver(function(muts){
    try {
      var top = getTopAvatar();
      muts.forEach(function(m){
        try {
          if(m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'style' || m.attributeName === 'data-author-id' || m.attributeName === 'data-author')){
            var target = m.target;
            if(target && (target.tagName === 'IMG' || target.nodeType === 1)){
              enforceTopAvatarOnNode(target, top);
            }
          } else if(m.type === 'childList' && m.addedNodes && m.addedNodes.length){
            m.addedNodes.forEach(function(node){
              try {
                if(node.nodeType !== 1) return;
                // find descendant avatar images
                var imgs = node.querySelectorAll && node.querySelectorAll('.moment-avatar, .avatar-img, img[data-role="avatar"], .author-avatar');
                if(imgs && imgs.length){
                  imgs.forEach(function(img){ enforceTopAvatarOnNode(img, top); });
                }
                // also if the node itself is an IMG
                if(node.tagName === 'IMG') enforceTopAvatarOnNode(node, top);
              } catch(e){}
            });
          }
        } catch(e){}
      });
    } catch(e){}
  });

  try {
    observer.observe(document.body, { attributes: true, childList: true, subtree: true, attributeFilter: ['src','style','data-author-id','data-author','data-author-name'] });
  } catch(e){}

  // Also run periodic enforcement for initial seconds to handle race conditions
  var enforcementRuns = 0;
  var enforcementTimer = setInterval(function(){
    try {
      enforcementRuns++;
      var top = getTopAvatar();
      if(top) enforceTopAvatarAll(top);
      // Try to update DB as well to persist
      try {
        if(top && typeof window.__updateProfileAndAvatars === 'function'){
          window.__updateProfileAndAvatars();
        }
      } catch(e){}
      if(enforcementRuns > 40) { // run ~40 times at 200ms => 8 seconds then stop
        clearInterval(enforcementTimer);
      }
    } catch(e){}
  }, 200);

  // Expose a function to explicitly bind list avatars to top avatar and optionally persist to DB
  window.bindMomentsAvatarsToTop = function(persistToDB){
    try {
      var top = getTopAvatar();
      if(!top) return;
      enforceTopAvatarAll(top);
      if(persistToDB){
        // try to update DB entries authorAvatar for current user
        try {
          var p = (typeof loadProfileFromStorage === 'function') ? loadProfileFromStorage() : { id: localStorage.getItem('myTopId') };
          if(p && p.id && window.AppDB_Moments && window.AppDB_Moments.moments){
            if(typeof window.AppDB_Moments.moments.where === 'function' && typeof window.AppDB_Moments.moments.modify === 'function'){
              try { window.AppDB_Moments.moments.where('authorId').equals(p.id).modify(function(o){ o.authorAvatar = top; }); } catch(e){}
            } else if(typeof window.AppDB_Moments.moments.toArray === 'function'){
              window.AppDB_Moments.moments.toArray().then(function(arr){
                arr.forEach(function(item){
                  if(item && item.authorId && String(item.authorId) === String(p.id)){
                    item.authorAvatar = top;
                    try { if(window.AppDB_Moments.moments.put) window.AppDB_Moments.moments.put(item); } catch(e){}
                  }
                });
              }).catch(function(){});
            }
          }
        } catch(e){}
      }
    } catch(e){}
  };

  // Attempt immediate bind once loaded
  try { setTimeout(function(){ window.bindMomentsAvatarsToTop(true); }, 100); } catch(e){}

  // defensive cleanup if script re-inserted: no-op

})();


document.addEventListener('DOMContentLoaded', () => {
    // ä¿®å¤ï¼šä¸ºèŠå¤©å®¤çš„è¿”å›æŒ‰é’®å¢åŠ ç‰¹æ®Šå¤„ç†ï¼Œä»¥ç¡®ä¿åº•éƒ¨å¯¼èˆªæ èƒ½æ­£ç¡®æ˜¾ç¤º
    const chatRoomBackBtn = document.querySelector('#chat-room-screen .back-btn');
    if (chatRoomBackBtn) {
        chatRoomBackBtn.addEventListener('click', () => {
            const targetScreenId = chatRoomBackBtn.dataset.target;
            const navHost = document.getElementById('bottom-nav-host');
            
            // å®šä¹‰å“ªäº›é¡µé¢åº”è¯¥æ˜¾ç¤ºåº•éƒ¨å¯¼èˆªæ 
            const screensWithNav = ['chat-list-screen', 'moments-screen', 'forum-screen', 'wallet-screen'];
            
            if (navHost && screensWithNav.includes(targetScreenId)) {
                navHost.style.display = ''; // æˆ–è€… 'flex'ï¼Œå–å†³äºä½ çš„å¸ƒå±€
            }
        });
    }

    // ä¿®å¤ï¼šç¡®ä¿æ‰€æœ‰æ‰“å¼€èŠå¤©å®¤çš„å…¥å£éƒ½ä¼šå¼ºåˆ¶éšè—åº•éƒ¨å¯¼èˆªæ 
    // æˆ‘ä»¬é€šè¿‡ç›‘å¬ä¸€ä¸ªå…±åŒçš„çˆ¶å…ƒç´ æ¥å®ç°ï¼Œè¿™æ¯”ä¿®æ”¹å¤šä¸ªå‡½æ•°æ›´é«˜æ•ˆ
    const phoneScreen = document.querySelector('.phone-screen');
    if (phoneScreen) {
        phoneScreen.addEventListener('click', (e) => {
            // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦æ˜¯ä¸€ä¸ªæŒ‡å‘èŠå¤©å®¤çš„èŠå¤©æ¡ç›®
            const chatItem = e.target.closest('.chat-item');
            if (chatItem && chatItem.dataset.id && chatItem.dataset.type) {
                const navHost = document.getElementById('bottom-nav-host');
                if (navHost) {
                    navHost.style.display = 'none';
                }
            }
        });
    }
});